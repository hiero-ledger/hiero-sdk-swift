//
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the protocol buffer compiler.
// Source: consensus_service.proto
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


///*
/// The Hedera Consensus Service (HCS) provides the ability for a Hashgraph to
/// provide aBFT consensus as to the order and validity of messages submitted to
/// a *topic*, as well as a *consensus timestamp* for those messages.
///
/// Usage: instantiate `Proto_ConsensusServiceClient`, then call methods of this protocol to make API calls.
public protocol Proto_ConsensusServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? { get }

  func createTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func updateTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func deleteTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func submitMessage(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func getTopicInfo(
    _ request: Proto_Query,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Query, Proto_Response>
}

extension Proto_ConsensusServiceClientProtocol {
  public var serviceName: String {
    return "proto.ConsensusService"
  }

  ///*
  /// Create an HCS topic.
  /// <p>
  /// On success, the resulting TransactionReceipt SHALL contain the newly
  /// created TopicId.<br/>
  /// If the `adminKey` is set on the topic, this transaction MUST be signed
  /// by that key.<br/>
  /// If the `adminKey` is _not_ set on the topic, this transaction MUST NOT
  /// set an `autoRenewAccount`. The new topic will be immutable and must be
  /// renewed manually.<br/>
  /// If the `autoRenewAccount` is set on the topic, this transaction MUST be
  /// signed by that account.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
  ///
  /// - Parameters:
  ///   - request: Request to send to createTopic.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func createTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.createTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateTopicInterceptors() ?? []
    )
  }

  ///*
  /// Update an HCS topic.
  /// <p>
  /// If the `adminKey` is not set on the topic, this transaction MUST extend
  /// the `expirationTime` and MUST NOT modify any other field.<br/>
  /// If the `adminKey` is set on the topic, this transaction MUST be signed
  /// by that key.<br/>
  /// If this transaction sets a new `adminKey`, this transaction MUST be
  /// signed by <strong>_both_</strong> keys, the pre-update `adminKey` and
  /// the post-update `adminKey`.<br/>
  /// If this transaction sets a new, non-null, `autoRenewAccount`, the newly
  /// set account MUST sign this transaction.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
  ///
  /// - Parameters:
  ///   - request: Request to send to updateTopic.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func updateTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.updateTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? []
    )
  }

  ///*
  /// Delete an HCS topic.
  /// <p>
  /// If this transaction succeeds, all subsequent transactions referencing
  /// the deleted topic SHALL fail.<br/>
  /// The `adminKey` MUST be set on the topic and this transaction MUST be
  /// signed by that key.<br/>
  /// If the `adminKey` is not set on the topic, this transaction SHALL fail
  /// with a response code of `UNAUTHORIZED`. A topic without an `adminKey`
  /// cannot be deleted, but MAY expire.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
  ///
  /// - Parameters:
  ///   - request: Request to send to deleteTopic.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func deleteTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.deleteTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? []
    )
  }

  ///*
  /// Submit a message to an HCS topic.
  /// <p>
  /// Valid and authorized messages on valid topics will be ordered by the
  /// consensus service, published in the block stream, and available to all
  /// subscribers on this topic via the mirror nodes.<br/>
  /// If this transaction succeeds the resulting TransactionReceipt SHALL
  /// contain the latest topicSequenceNumber and topicRunningHash for the
  /// topic.<br/>
  /// If the topic has a `submitKey` then that key MUST sign this
  /// transaction.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
  ///
  /// - Parameters:
  ///   - request: Request to send to submitMessage.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func submitMessage(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.submitMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? []
    )
  }

  ///*
  /// Retrieve the latest state of a topic. This method is unrestricted and
  /// allowed on any topic by any payer account.
  /// <p>
  /// The request body MUST be a
  /// [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)<br/>
  /// The response body SHALL be a
  /// [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
  ///
  /// - Parameters:
  ///   - request: Request to send to getTopicInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getTopicInfo(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Query, Proto_Response> {
    return self.makeUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? []
    )
  }
}

@available(*, deprecated)
extension Proto_ConsensusServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Proto_ConsensusServiceNIOClient")
public final class Proto_ConsensusServiceClient: Proto_ConsensusServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the proto.ConsensusService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Proto_ConsensusServiceNIOClient: Proto_ConsensusServiceClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the proto.ConsensusService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

///*
/// The Hedera Consensus Service (HCS) provides the ability for a Hashgraph to
/// provide aBFT consensus as to the order and validity of messages submitted to
/// a *topic*, as well as a *consensus timestamp* for those messages.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Proto_ConsensusServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? { get }

  func makeCreateTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeUpdateTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeDeleteTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeSubmitMessageCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeGetTopicInfoCall(
    _ request: Proto_Query,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Proto_ConsensusServiceAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Proto_ConsensusServiceClientMetadata.serviceDescriptor
  }

  public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeCreateTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.createTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateTopicInterceptors() ?? []
    )
  }

  public func makeUpdateTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.updateTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? []
    )
  }

  public func makeDeleteTopicCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.deleteTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? []
    )
  }

  public func makeSubmitMessageCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.submitMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? []
    )
  }

  public func makeGetTopicInfoCall(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response> {
    return self.makeAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Proto_ConsensusServiceAsyncClientProtocol {
  public func createTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.createTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateTopicInterceptors() ?? []
    )
  }

  public func updateTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.updateTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? []
    )
  }

  public func deleteTopic(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.deleteTopic.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? []
    )
  }

  public func submitMessage(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.submitMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? []
    )
  }

  public func getTopicInfo(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_Response {
    return try await self.performAsyncUnaryCall(
      path: Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Proto_ConsensusServiceAsyncClient: Proto_ConsensusServiceAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_ConsensusServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

public protocol Proto_ConsensusServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'createTopic'.
  func makecreateTopicInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'updateTopic'.
  func makeupdateTopicInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'deleteTopic'.
  func makedeleteTopicInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'submitMessage'.
  func makesubmitMessageInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'getTopicInfo'.
  func makegetTopicInfoInterceptors() -> [ClientInterceptor<Proto_Query, Proto_Response>]
}

public enum Proto_ConsensusServiceClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "ConsensusService",
    fullName: "proto.ConsensusService",
    methods: [
      Proto_ConsensusServiceClientMetadata.Methods.createTopic,
      Proto_ConsensusServiceClientMetadata.Methods.updateTopic,
      Proto_ConsensusServiceClientMetadata.Methods.deleteTopic,
      Proto_ConsensusServiceClientMetadata.Methods.submitMessage,
      Proto_ConsensusServiceClientMetadata.Methods.getTopicInfo,
    ]
  )

  public enum Methods {
    public static let createTopic = GRPCMethodDescriptor(
      name: "createTopic",
      path: "/proto.ConsensusService/createTopic",
      type: GRPCCallType.unary
    )

    public static let updateTopic = GRPCMethodDescriptor(
      name: "updateTopic",
      path: "/proto.ConsensusService/updateTopic",
      type: GRPCCallType.unary
    )

    public static let deleteTopic = GRPCMethodDescriptor(
      name: "deleteTopic",
      path: "/proto.ConsensusService/deleteTopic",
      type: GRPCCallType.unary
    )

    public static let submitMessage = GRPCMethodDescriptor(
      name: "submitMessage",
      path: "/proto.ConsensusService/submitMessage",
      type: GRPCCallType.unary
    )

    public static let getTopicInfo = GRPCMethodDescriptor(
      name: "getTopicInfo",
      path: "/proto.ConsensusService/getTopicInfo",
      type: GRPCCallType.unary
    )
  }
}

///*
/// The Hedera Consensus Service (HCS) provides the ability for a Hashgraph to
/// provide aBFT consensus as to the order and validity of messages submitted to
/// a *topic*, as well as a *consensus timestamp* for those messages.
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Proto_ConsensusServiceProvider: CallHandlerProvider {
  var interceptors: Proto_ConsensusServiceServerInterceptorFactoryProtocol? { get }

  ///*
  /// Create an HCS topic.
  /// <p>
  /// On success, the resulting TransactionReceipt SHALL contain the newly
  /// created TopicId.<br/>
  /// If the `adminKey` is set on the topic, this transaction MUST be signed
  /// by that key.<br/>
  /// If the `adminKey` is _not_ set on the topic, this transaction MUST NOT
  /// set an `autoRenewAccount`. The new topic will be immutable and must be
  /// renewed manually.<br/>
  /// If the `autoRenewAccount` is set on the topic, this transaction MUST be
  /// signed by that account.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
  func createTopic(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Update an HCS topic.
  /// <p>
  /// If the `adminKey` is not set on the topic, this transaction MUST extend
  /// the `expirationTime` and MUST NOT modify any other field.<br/>
  /// If the `adminKey` is set on the topic, this transaction MUST be signed
  /// by that key.<br/>
  /// If this transaction sets a new `adminKey`, this transaction MUST be
  /// signed by <strong>_both_</strong> keys, the pre-update `adminKey` and
  /// the post-update `adminKey`.<br/>
  /// If this transaction sets a new, non-null, `autoRenewAccount`, the newly
  /// set account MUST sign this transaction.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
  func updateTopic(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Delete an HCS topic.
  /// <p>
  /// If this transaction succeeds, all subsequent transactions referencing
  /// the deleted topic SHALL fail.<br/>
  /// The `adminKey` MUST be set on the topic and this transaction MUST be
  /// signed by that key.<br/>
  /// If the `adminKey` is not set on the topic, this transaction SHALL fail
  /// with a response code of `UNAUTHORIZED`. A topic without an `adminKey`
  /// cannot be deleted, but MAY expire.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
  func deleteTopic(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Submit a message to an HCS topic.
  /// <p>
  /// Valid and authorized messages on valid topics will be ordered by the
  /// consensus service, published in the block stream, and available to all
  /// subscribers on this topic via the mirror nodes.<br/>
  /// If this transaction succeeds the resulting TransactionReceipt SHALL
  /// contain the latest topicSequenceNumber and topicRunningHash for the
  /// topic.<br/>
  /// If the topic has a `submitKey` then that key MUST sign this
  /// transaction.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
  func submitMessage(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Retrieve the latest state of a topic. This method is unrestricted and
  /// allowed on any topic by any payer account.
  /// <p>
  /// The request body MUST be a
  /// [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)<br/>
  /// The response body SHALL be a
  /// [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
  func getTopicInfo(request: Proto_Query, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_Response>
}

extension Proto_ConsensusServiceProvider {
  public var serviceName: Substring {
    return Proto_ConsensusServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "createTopic":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makecreateTopicInterceptors() ?? [],
        userFunction: self.createTopic(request:context:)
      )

    case "updateTopic":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? [],
        userFunction: self.updateTopic(request:context:)
      )

    case "deleteTopic":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? [],
        userFunction: self.deleteTopic(request:context:)
      )

    case "submitMessage":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? [],
        userFunction: self.submitMessage(request:context:)
      )

    case "getTopicInfo":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Query>(),
        responseSerializer: ProtobufSerializer<Proto_Response>(),
        interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? [],
        userFunction: self.getTopicInfo(request:context:)
      )

    default:
      return nil
    }
  }
}

///*
/// The Hedera Consensus Service (HCS) provides the ability for a Hashgraph to
/// provide aBFT consensus as to the order and validity of messages submitted to
/// a *topic*, as well as a *consensus timestamp* for those messages.
///
/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Proto_ConsensusServiceAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Proto_ConsensusServiceServerInterceptorFactoryProtocol? { get }

  ///*
  /// Create an HCS topic.
  /// <p>
  /// On success, the resulting TransactionReceipt SHALL contain the newly
  /// created TopicId.<br/>
  /// If the `adminKey` is set on the topic, this transaction MUST be signed
  /// by that key.<br/>
  /// If the `adminKey` is _not_ set on the topic, this transaction MUST NOT
  /// set an `autoRenewAccount`. The new topic will be immutable and must be
  /// renewed manually.<br/>
  /// If the `autoRenewAccount` is set on the topic, this transaction MUST be
  /// signed by that account.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
  func createTopic(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Update an HCS topic.
  /// <p>
  /// If the `adminKey` is not set on the topic, this transaction MUST extend
  /// the `expirationTime` and MUST NOT modify any other field.<br/>
  /// If the `adminKey` is set on the topic, this transaction MUST be signed
  /// by that key.<br/>
  /// If this transaction sets a new `adminKey`, this transaction MUST be
  /// signed by <strong>_both_</strong> keys, the pre-update `adminKey` and
  /// the post-update `adminKey`.<br/>
  /// If this transaction sets a new, non-null, `autoRenewAccount`, the newly
  /// set account MUST sign this transaction.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
  func updateTopic(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Delete an HCS topic.
  /// <p>
  /// If this transaction succeeds, all subsequent transactions referencing
  /// the deleted topic SHALL fail.<br/>
  /// The `adminKey` MUST be set on the topic and this transaction MUST be
  /// signed by that key.<br/>
  /// If the `adminKey` is not set on the topic, this transaction SHALL fail
  /// with a response code of `UNAUTHORIZED`. A topic without an `adminKey`
  /// cannot be deleted, but MAY expire.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
  func deleteTopic(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Submit a message to an HCS topic.
  /// <p>
  /// Valid and authorized messages on valid topics will be ordered by the
  /// consensus service, published in the block stream, and available to all
  /// subscribers on this topic via the mirror nodes.<br/>
  /// If this transaction succeeds the resulting TransactionReceipt SHALL
  /// contain the latest topicSequenceNumber and topicRunningHash for the
  /// topic.<br/>
  /// If the topic has a `submitKey` then that key MUST sign this
  /// transaction.<br/>
  /// <p>
  /// The request body MUST be a
  /// [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
  func submitMessage(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Retrieve the latest state of a topic. This method is unrestricted and
  /// allowed on any topic by any payer account.
  /// <p>
  /// The request body MUST be a
  /// [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)<br/>
  /// The response body SHALL be a
  /// [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
  func getTopicInfo(
    request: Proto_Query,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_Response
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Proto_ConsensusServiceAsyncProvider {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Proto_ConsensusServiceServerMetadata.serviceDescriptor
  }

  public var serviceName: Substring {
    return Proto_ConsensusServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  public var interceptors: Proto_ConsensusServiceServerInterceptorFactoryProtocol? {
    return nil
  }

  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "createTopic":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makecreateTopicInterceptors() ?? [],
        wrapping: { try await self.createTopic(request: $0, context: $1) }
      )

    case "updateTopic":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeupdateTopicInterceptors() ?? [],
        wrapping: { try await self.updateTopic(request: $0, context: $1) }
      )

    case "deleteTopic":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makedeleteTopicInterceptors() ?? [],
        wrapping: { try await self.deleteTopic(request: $0, context: $1) }
      )

    case "submitMessage":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makesubmitMessageInterceptors() ?? [],
        wrapping: { try await self.submitMessage(request: $0, context: $1) }
      )

    case "getTopicInfo":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Query>(),
        responseSerializer: ProtobufSerializer<Proto_Response>(),
        interceptors: self.interceptors?.makegetTopicInfoInterceptors() ?? [],
        wrapping: { try await self.getTopicInfo(request: $0, context: $1) }
      )

    default:
      return nil
    }
  }
}

public protocol Proto_ConsensusServiceServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'createTopic'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makecreateTopicInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'updateTopic'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeupdateTopicInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'deleteTopic'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makedeleteTopicInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'submitMessage'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makesubmitMessageInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'getTopicInfo'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makegetTopicInfoInterceptors() -> [ServerInterceptor<Proto_Query, Proto_Response>]
}

public enum Proto_ConsensusServiceServerMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "ConsensusService",
    fullName: "proto.ConsensusService",
    methods: [
      Proto_ConsensusServiceServerMetadata.Methods.createTopic,
      Proto_ConsensusServiceServerMetadata.Methods.updateTopic,
      Proto_ConsensusServiceServerMetadata.Methods.deleteTopic,
      Proto_ConsensusServiceServerMetadata.Methods.submitMessage,
      Proto_ConsensusServiceServerMetadata.Methods.getTopicInfo,
    ]
  )

  public enum Methods {
    public static let createTopic = GRPCMethodDescriptor(
      name: "createTopic",
      path: "/proto.ConsensusService/createTopic",
      type: GRPCCallType.unary
    )

    public static let updateTopic = GRPCMethodDescriptor(
      name: "updateTopic",
      path: "/proto.ConsensusService/updateTopic",
      type: GRPCCallType.unary
    )

    public static let deleteTopic = GRPCMethodDescriptor(
      name: "deleteTopic",
      path: "/proto.ConsensusService/deleteTopic",
      type: GRPCCallType.unary
    )

    public static let submitMessage = GRPCMethodDescriptor(
      name: "submitMessage",
      path: "/proto.ConsensusService/submitMessage",
      type: GRPCCallType.unary
    )

    public static let getTopicInfo = GRPCMethodDescriptor(
      name: "getTopicInfo",
      path: "/proto.ConsensusService/getTopicInfo",
      type: GRPCCallType.unary
    )
  }
}
