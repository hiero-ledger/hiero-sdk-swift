// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: state/history/history_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A set of proof keys for a node; that is, the key the node is
/// currently using and the key it wants to use in assembling the
/// next address book in the ledger id's chain of trust.
public struct Com_Hedera_Hapi_Node_State_History_ProofKeySet: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The consensus time when the network adopted the active
  /// proof key in this set. An adoption time that is sufficiently
  /// tardy relative to the latest assembly start time may result
  /// in the node's key being omitted from the address book.
  public var adoptionTime: Proto_Timestamp {
    get {return _adoptionTime ?? Proto_Timestamp()}
    set {_adoptionTime = newValue}
  }
  /// Returns true if `adoptionTime` has been explicitly set.
  public var hasAdoptionTime: Bool {return self._adoptionTime != nil}
  /// Clears the value of `adoptionTime`. Subsequent reads from it will return its default value.
  public mutating func clearAdoptionTime() {self._adoptionTime = nil}

  ///*
  /// The proof key the node is using.
  public var key: Data = Data()

  ///*
  /// If set, the proof key the node wants to start using in the
  /// address book.
  public var nextKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _adoptionTime: Proto_Timestamp? = nil
}

///*
/// A record of the proof key a node had in a particular address
/// book. Necessary to keep at each point history so that nodes
/// can verify the correct key was used to sign in transitions
/// starting from the current address book; no matter how keys
/// have been rotated from the time the address book was created.
public struct Com_Hedera_Hapi_Node_State_History_ProofKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The node id.
  public var nodeID: UInt64 = 0

  ///*
  /// The key.
  public var key: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A piece of new history in the form of an address book hash and
/// associated metadata.
public struct Com_Hedera_Hapi_Node_State_History_History: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The address book hash of the new history.
  public var addressBookHash: Data = Data()

  ///*
  /// The metadata associated to the address book.
  public var metadata: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A proof that some address book history belongs to the ledger id's
/// chain of trust.
public struct Com_Hedera_Hapi_Node_State_History_HistoryProof: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The hash of the source address book.
  public var sourceAddressBookHash: Data = Data()

  ///*
  /// The proof keys for the target address book, needed to keep
  /// constructing proofs after adopting the target address book's
  /// roster at a handoff.
  public var targetProofKeys: [Com_Hedera_Hapi_Node_State_History_ProofKey] = []

  ///*
  /// The target history of the proof.
  public var targetHistory: Com_Hedera_Hapi_Node_State_History_History {
    get {return _targetHistory ?? Com_Hedera_Hapi_Node_State_History_History()}
    set {_targetHistory = newValue}
  }
  /// Returns true if `targetHistory` has been explicitly set.
  public var hasTargetHistory: Bool {return self._targetHistory != nil}
  /// Clears the value of `targetHistory`. Subsequent reads from it will return its default value.
  public mutating func clearTargetHistory() {self._targetHistory = nil}

  ///*
  /// The proof of chain of trust from the ledger id.
  public var proof: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _targetHistory: Com_Hedera_Hapi_Node_State_History_History? = nil
}

///*
/// Summary of the status of constructing a metadata proof, necessary to
/// ensure deterministic construction ending in a roster with sufficient
/// weight to enact its own constructions.
public struct Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The construction id.
  public var constructionID: UInt64 = 0

  ///*
  /// The hash of the roster whose weights are used to determine when
  /// certain thresholds are during construction.
  public var sourceRosterHash: Data = Data()

  ///*
  /// If set, the proof that the address book of the source roster belongs
  /// to the the ledger id's chain of trust; if not set, the source roster's
  /// address book must *be* the ledger id.
  public var sourceProof: Com_Hedera_Hapi_Node_State_History_HistoryProof {
    get {return _sourceProof ?? Com_Hedera_Hapi_Node_State_History_HistoryProof()}
    set {_sourceProof = newValue}
  }
  /// Returns true if `sourceProof` has been explicitly set.
  public var hasSourceProof: Bool {return self._sourceProof != nil}
  /// Clears the value of `sourceProof`. Subsequent reads from it will return its default value.
  public mutating func clearSourceProof() {self._sourceProof = nil}

  ///*
  /// The hash of the roster whose weights are used to assess progress
  /// toward obtaining proof keys for parties that hold at least a
  /// strong minority of the stake in that roster.
  public var targetRosterHash: Data = Data()

  public var proofState: Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction.OneOf_ProofState? = nil

  ///*
  /// If the network is still gathering proof keys for this
  /// construction, the next time at which nodes should stop waiting
  /// for tardy proof keys and assembly the history to be proven as
  /// soon as it has the associated metadata and proof keys for nodes
  /// with >2/3 weight in the target roster.
  public var gracePeriodEndTime: Proto_Timestamp {
    get {
      if case .gracePeriodEndTime(let v)? = proofState {return v}
      return Proto_Timestamp()
    }
    set {proofState = .gracePeriodEndTime(newValue)}
  }

  ///*
  /// If the network has gathered enough proof keys to assemble the
  /// history for this construction, the cutoff time at which those
  /// keys must have been adopted to be included in the final history.
  public var assemblyStartTime: Proto_Timestamp {
    get {
      if case .assemblyStartTime(let v)? = proofState {return v}
      return Proto_Timestamp()
    }
    set {proofState = .assemblyStartTime(newValue)}
  }

  ///*
  /// When this construction is complete, the recursive proof that
  /// the target roster's address book and associated metadata belong
  /// to the ledger id's chain of trust.
  public var targetProof: Com_Hedera_Hapi_Node_State_History_HistoryProof {
    get {
      if case .targetProof(let v)? = proofState {return v}
      return Com_Hedera_Hapi_Node_State_History_HistoryProof()
    }
    set {proofState = .targetProof(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ProofState: Equatable, Sendable {
    ///*
    /// If the network is still gathering proof keys for this
    /// construction, the next time at which nodes should stop waiting
    /// for tardy proof keys and assembly the history to be proven as
    /// soon as it has the associated metadata and proof keys for nodes
    /// with >2/3 weight in the target roster.
    case gracePeriodEndTime(Proto_Timestamp)
    ///*
    /// If the network has gathered enough proof keys to assemble the
    /// history for this construction, the cutoff time at which those
    /// keys must have been adopted to be included in the final history.
    case assemblyStartTime(Proto_Timestamp)
    ///*
    /// When this construction is complete, the recursive proof that
    /// the target roster's address book and associated metadata belong
    /// to the ledger id's chain of trust.
    case targetProof(Com_Hedera_Hapi_Node_State_History_HistoryProof)

  }

  public init() {}

  fileprivate var _sourceProof: Com_Hedera_Hapi_Node_State_History_HistoryProof? = nil
}

///*
/// A construction-scoped node id.
public struct Com_Hedera_Hapi_Node_State_History_ConstructionNodeId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The unique id of a history proof construction.
  public var constructionID: UInt64 = 0

  ///*
  /// The unique id of a node.
  public var nodeID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A node's vote for a particular history proof; either by explicitly
/// giving the proof, or by identifying a node that already voted for it.
public struct Com_Hedera_Hapi_Node_State_History_HistoryProofVote: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vote: Com_Hedera_Hapi_Node_State_History_HistoryProofVote.OneOf_Vote? = nil

  ///*
  /// The history proof the submitting node is voting for.
  public var proof: Com_Hedera_Hapi_Node_State_History_HistoryProof {
    get {
      if case .proof(let v)? = vote {return v}
      return Com_Hedera_Hapi_Node_State_History_HistoryProof()
    }
    set {vote = .proof(newValue)}
  }

  ///*
  /// The id of another node that already voted for the exact proof
  /// the submitting node is voting for.
  public var congruentNodeID: UInt64 {
    get {
      if case .congruentNodeID(let v)? = vote {return v}
      return 0
    }
    set {vote = .congruentNodeID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Vote: Equatable, Sendable {
    ///*
    /// The history proof the submitting node is voting for.
    case proof(Com_Hedera_Hapi_Node_State_History_HistoryProof)
    ///*
    /// The id of another node that already voted for the exact proof
    /// the submitting node is voting for.
    case congruentNodeID(UInt64)

  }

  public init() {}
}

///*
/// A node's signature blessing some new history.
public struct Com_Hedera_Hapi_Node_State_History_HistorySignature: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The new history the node is signing.
  public var history: Com_Hedera_Hapi_Node_State_History_History {
    get {return _history ?? Com_Hedera_Hapi_Node_State_History_History()}
    set {_history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  public var hasHistory: Bool {return self._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  public mutating func clearHistory() {self._history = nil}

  ///*
  /// The node's signature on the canonical serialization of
  /// the new history.
  public var signature: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _history: Com_Hedera_Hapi_Node_State_History_History? = nil
}

///*
/// A signature on some new history recorded at a certain time.
public struct Com_Hedera_Hapi_Node_State_History_RecordedHistorySignature: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The time at which the signature was recorded.
  public var signingTime: Proto_Timestamp {
    get {return _signingTime ?? Proto_Timestamp()}
    set {_signingTime = newValue}
  }
  /// Returns true if `signingTime` has been explicitly set.
  public var hasSigningTime: Bool {return self._signingTime != nil}
  /// Clears the value of `signingTime`. Subsequent reads from it will return its default value.
  public mutating func clearSigningTime() {self._signingTime = nil}

  ///*
  /// The signature on some new history.
  public var historySignature: Com_Hedera_Hapi_Node_State_History_HistorySignature {
    get {return _historySignature ?? Com_Hedera_Hapi_Node_State_History_HistorySignature()}
    set {_historySignature = newValue}
  }
  /// Returns true if `historySignature` has been explicitly set.
  public var hasHistorySignature: Bool {return self._historySignature != nil}
  /// Clears the value of `historySignature`. Subsequent reads from it will return its default value.
  public mutating func clearHistorySignature() {self._historySignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _signingTime: Proto_Timestamp? = nil
  fileprivate var _historySignature: Com_Hedera_Hapi_Node_State_History_HistorySignature? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.hedera.hapi.node.state.history"

extension Com_Hedera_Hapi_Node_State_History_ProofKeySet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProofKeySet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "adoption_time"),
    3: .same(proto: "key"),
    4: .standard(proto: "next_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._adoptionTime) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nextKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._adoptionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 3)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_ProofKeySet, rhs: Com_Hedera_Hapi_Node_State_History_ProofKeySet) -> Bool {
    if lhs._adoptionTime != rhs._adoptionTime {return false}
    if lhs.key != rhs.key {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_ProofKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProofKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.nodeID, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_ProofKey, rhs: Com_Hedera_Hapi_Node_State_History_ProofKey) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_History: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".History"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "address_book_hash"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.addressBookHash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addressBookHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.addressBookHash, fieldNumber: 1)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_History, rhs: Com_Hedera_Hapi_Node_State_History_History) -> Bool {
    if lhs.addressBookHash != rhs.addressBookHash {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_HistoryProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoryProof"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_address_book_hash"),
    2: .standard(proto: "target_proof_keys"),
    3: .standard(proto: "target_history"),
    4: .same(proto: "proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sourceAddressBookHash) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.targetProofKeys) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._targetHistory) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.proof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sourceAddressBookHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.sourceAddressBookHash, fieldNumber: 1)
    }
    if !self.targetProofKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targetProofKeys, fieldNumber: 2)
    }
    try { if let v = self._targetHistory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.proof.isEmpty {
      try visitor.visitSingularBytesField(value: self.proof, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_HistoryProof, rhs: Com_Hedera_Hapi_Node_State_History_HistoryProof) -> Bool {
    if lhs.sourceAddressBookHash != rhs.sourceAddressBookHash {return false}
    if lhs.targetProofKeys != rhs.targetProofKeys {return false}
    if lhs._targetHistory != rhs._targetHistory {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoryProofConstruction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "construction_id"),
    2: .standard(proto: "source_roster_hash"),
    3: .standard(proto: "source_proof"),
    4: .standard(proto: "target_roster_hash"),
    5: .standard(proto: "grace_period_end_time"),
    6: .standard(proto: "assembly_start_time"),
    7: .standard(proto: "target_proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.constructionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sourceRosterHash) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sourceProof) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.targetRosterHash) }()
      case 5: try {
        var v: Proto_Timestamp?
        var hadOneofValue = false
        if let current = self.proofState {
          hadOneofValue = true
          if case .gracePeriodEndTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proofState = .gracePeriodEndTime(v)
        }
      }()
      case 6: try {
        var v: Proto_Timestamp?
        var hadOneofValue = false
        if let current = self.proofState {
          hadOneofValue = true
          if case .assemblyStartTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proofState = .assemblyStartTime(v)
        }
      }()
      case 7: try {
        var v: Com_Hedera_Hapi_Node_State_History_HistoryProof?
        var hadOneofValue = false
        if let current = self.proofState {
          hadOneofValue = true
          if case .targetProof(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proofState = .targetProof(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.constructionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.constructionID, fieldNumber: 1)
    }
    if !self.sourceRosterHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.sourceRosterHash, fieldNumber: 2)
    }
    try { if let v = self._sourceProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.targetRosterHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.targetRosterHash, fieldNumber: 4)
    }
    switch self.proofState {
    case .gracePeriodEndTime?: try {
      guard case .gracePeriodEndTime(let v)? = self.proofState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .assemblyStartTime?: try {
      guard case .assemblyStartTime(let v)? = self.proofState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .targetProof?: try {
      guard case .targetProof(let v)? = self.proofState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction, rhs: Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction) -> Bool {
    if lhs.constructionID != rhs.constructionID {return false}
    if lhs.sourceRosterHash != rhs.sourceRosterHash {return false}
    if lhs._sourceProof != rhs._sourceProof {return false}
    if lhs.targetRosterHash != rhs.targetRosterHash {return false}
    if lhs.proofState != rhs.proofState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_ConstructionNodeId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConstructionNodeId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "construction_id"),
    2: .standard(proto: "node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.constructionID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nodeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.constructionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.constructionID, fieldNumber: 1)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.nodeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_ConstructionNodeId, rhs: Com_Hedera_Hapi_Node_State_History_ConstructionNodeId) -> Bool {
    if lhs.constructionID != rhs.constructionID {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_HistoryProofVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoryProofVote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proof"),
    2: .standard(proto: "congruent_node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Hedera_Hapi_Node_State_History_HistoryProof?
        var hadOneofValue = false
        if let current = self.vote {
          hadOneofValue = true
          if case .proof(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vote = .proof(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.vote != nil {try decoder.handleConflictingOneOf()}
          self.vote = .congruentNodeID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.vote {
    case .proof?: try {
      guard case .proof(let v)? = self.vote else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .congruentNodeID?: try {
      guard case .congruentNodeID(let v)? = self.vote else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_HistoryProofVote, rhs: Com_Hedera_Hapi_Node_State_History_HistoryProofVote) -> Bool {
    if lhs.vote != rhs.vote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_HistorySignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistorySignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "history"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_HistorySignature, rhs: Com_Hedera_Hapi_Node_State_History_HistorySignature) -> Bool {
    if lhs._history != rhs._history {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_RecordedHistorySignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordedHistorySignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signing_time"),
    2: .standard(proto: "history_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signingTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._historySignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signingTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._historySignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_RecordedHistorySignature, rhs: Com_Hedera_Hapi_Node_State_History_RecordedHistorySignature) -> Bool {
    if lhs._signingTime != rhs._signingTime {return false}
    if lhs._historySignature != rhs._historySignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
