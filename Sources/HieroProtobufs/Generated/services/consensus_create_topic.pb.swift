// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/consensus_create_topic.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Create Topic
/// Create a new topic for the Hedera Consensus Service (HCS).
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Create a topic to accept and group consensus messages.
///
/// If `autoRenewAccount` is specified, that account Key MUST also sign this
/// transaction.<br/>
/// If `adminKey` is set, that Key MUST sign the transaction.<br/>
/// On success, the resulting `TransactionReceipt` SHALL contain the newly
/// created `TopicId`.
///
/// The `autoRenewPeriod` on a topic MUST be set to a value between
/// `autoRenewPeriod.minDuration` and `autoRenewPeriod.maxDuration`. These
/// values are configurable, typically 30 and 92 days.<br/>
/// This also sets the initial expirationTime of the topic.
///
/// If no `adminKey` is set on a topic
///   -`autoRenewAccount` SHALL NOT be set on the topic.
///   - A `deleteTopic` transaction SHALL fail.
///   - An `updateTopic` transaction that only extends the expirationTime MAY
///     succeed.
///   - Any other `updateTopic` transaction SHALL fail.
///
/// If the topic expires and is not automatically renewed, the topic SHALL enter
/// the `EXPIRED` state.
///   - All transactions on the topic SHALL fail with TOPIC_EXPIRED
///      - Except an updateTopic() call that only extends the expirationTime.
///   - getTopicInfo() SHALL succeed, and show the topic is expired.
/// The topic SHALL remain in the `EXPIRED` state for a time determined by the
/// `autorenew.gracePeriod` (configurable, originally 7 days).<br/>
/// After the grace period, if the topic's expirationTime is not extended, the
/// topic SHALL be automatically deleted from state entirely, and cannot be
/// recovered or recreated.
///
/// ### Block Stream Effects
/// None
public struct Proto_ConsensusCreateTopicTransactionBody: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A short memo for this topic.
  /// <p>
  /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
  /// (default 100) bytes when encoded as UTF-8.
  public var memo: String = String()

  ///*
  /// Access control for modification of the topic after it is created.
  /// <p>
  /// If this field is set, that key MUST sign this transaction.<br/>
  /// If this field is set, that key MUST sign each future transaction to
  /// update or delete the topic.<br/>
  /// An updateTopic transaction that _only_ extends the topic expirationTime
  /// (a "manual renewal" transaction) SHALL NOT require admin key
  /// signature.<br/>
  /// A topic without an admin key SHALL be immutable, except for expiration
  /// and renewal.<br/>
  /// If adminKey is not set, then `autoRenewAccount` SHALL NOT be set.
  public var adminKey: Proto_Key {
    get {return _adminKey ?? Proto_Key()}
    set {_adminKey = newValue}
  }
  /// Returns true if `adminKey` has been explicitly set.
  public var hasAdminKey: Bool {return self._adminKey != nil}
  /// Clears the value of `adminKey`. Subsequent reads from it will return its default value.
  public mutating func clearAdminKey() {self._adminKey = nil}

  ///*
  /// Access control for message submission to the topic.
  /// <p>
  /// If this field is set, that key MUST sign each consensus submit message
  /// for this topic.<br/>
  /// If this field is not set then any account may submit a message on the
  /// topic, without restriction.
  public var submitKey: Proto_Key {
    get {return _submitKey ?? Proto_Key()}
    set {_submitKey = newValue}
  }
  /// Returns true if `submitKey` has been explicitly set.
  public var hasSubmitKey: Bool {return self._submitKey != nil}
  /// Clears the value of `submitKey`. Subsequent reads from it will return its default value.
  public mutating func clearSubmitKey() {self._submitKey = nil}

  ///*
  /// The initial lifetime, in seconds, for the topic.<br/>
  /// This is also the number of seconds for which the topic SHALL be
  /// automatically renewed upon expiring, if it has a valid auto-renew
  /// account.
  /// <p>
  /// This value MUST be set.<br/>
  /// This value MUST be greater than the configured
  /// MIN_AUTORENEW_PERIOD.<br/>
  /// This value MUST be less than the configured MAX_AUTORENEW_PERIOD.
  public var autoRenewPeriod: Proto_Duration {
    get {return _autoRenewPeriod ?? Proto_Duration()}
    set {_autoRenewPeriod = newValue}
  }
  /// Returns true if `autoRenewPeriod` has been explicitly set.
  public var hasAutoRenewPeriod: Bool {return self._autoRenewPeriod != nil}
  /// Clears the value of `autoRenewPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewPeriod() {self._autoRenewPeriod = nil}

  ///*
  /// The ID of the account to be charged renewal fees at the topic's
  /// expirationTime to extend the lifetime of the topic.
  /// <p>
  /// The topic lifetime SHALL be extended by the smallest of the following:
  /// <ul>
  ///   <li>The current `autoRenewPeriod` duration.</li>
  ///   <li>The maximum duration that this account has funds to purchase.</li>
  ///   <li>The configured MAX_AUTORENEW_PERIOD at the time of automatic
  ///       renewal.</li>
  /// </ul>
  /// If this value is set, the referenced account MUST sign this
  /// transaction.<br/>
  /// If this value is set, the `adminKey` field MUST also be set (though that
  /// key MAY not have any correlation to this account).
  public var autoRenewAccount: Proto_AccountID {
    get {return _autoRenewAccount ?? Proto_AccountID()}
    set {_autoRenewAccount = newValue}
  }
  /// Returns true if `autoRenewAccount` has been explicitly set.
  public var hasAutoRenewAccount: Bool {return self._autoRenewAccount != nil}
  /// Clears the value of `autoRenewAccount`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewAccount() {self._autoRenewAccount = nil}

  ///*
  /// Access control for update or delete of custom fees.
  /// <p>
  /// If set, subsequent `consensus_update_topic` transactions signed with this
  /// key MAY update or delete the custom fees for this topic.<br/>
  /// If not set, the custom fees for this topic SHALL BE immutable.<br/>
  /// If not set when the topic is created, this field CANNOT be set via
  /// update.<br/>
  /// If set when the topic is created, this field MAY be changed via update.
  public var feeScheduleKey: Proto_Key {
    get {return _feeScheduleKey ?? Proto_Key()}
    set {_feeScheduleKey = newValue}
  }
  /// Returns true if `feeScheduleKey` has been explicitly set.
  public var hasFeeScheduleKey: Bool {return self._feeScheduleKey != nil}
  /// Clears the value of `feeScheduleKey`. Subsequent reads from it will return its default value.
  public mutating func clearFeeScheduleKey() {self._feeScheduleKey = nil}

  ///*
  /// A set of keys.<br/>
  /// Keys in this list are permitted to submit messages to this topic without
  /// paying custom fees associated with this topic.
  /// <p>
  /// If a submit transaction is signed by _any_ key included in this set,
  /// custom fees SHALL NOT be charged for that transaction.<br/>
  /// This field MUST NOT contain more than 10 keys.<br/>
  /// fee_exempt_key_list SHALL NOT contain any duplicate keys.<br/>
  /// fee_exempt_key_list MAY contain keys for accounts that are inactive,
  /// deleted, or non-existent.<br/>
  /// If fee_exempt_key_list is unset in this transaction, there SHALL NOT be
  /// any fee-exempt keys.  In particular, the following keys SHALL NOT be
  /// implicitly or automatically added to this list:
  /// `adminKey`, `submitKey`, `fee_schedule_key`.
  public var feeExemptKeyList: [Proto_Key] = []

  ///*
  /// A set of custom fee definitions.<br/>
  /// These are fees to be assessed for each submit to this topic.
  /// <p>
  /// Each fee defined in this set SHALL be evaluated for
  /// each message submitted to this topic, and the resultant
  /// total assessed fees SHALL be charged.<br/>
  /// Custom fees defined here SHALL be assessed in addition to the base
  /// network and node fees.<br/>
  /// custom_fees list SHALL NOT contain more than
  /// `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
  public var customFees: [Proto_FixedCustomFee] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _adminKey: Proto_Key? = nil
  fileprivate var _submitKey: Proto_Key? = nil
  fileprivate var _autoRenewPeriod: Proto_Duration? = nil
  fileprivate var _autoRenewAccount: Proto_AccountID? = nil
  fileprivate var _feeScheduleKey: Proto_Key? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ConsensusCreateTopicTransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsensusCreateTopicTransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memo"),
    2: .same(proto: "adminKey"),
    3: .same(proto: "submitKey"),
    6: .same(proto: "autoRenewPeriod"),
    7: .same(proto: "autoRenewAccount"),
    8: .standard(proto: "fee_schedule_key"),
    9: .standard(proto: "fee_exempt_key_list"),
    10: .standard(proto: "custom_fees"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.memo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._adminKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._submitKey) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._autoRenewPeriod) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._autoRenewAccount) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._feeScheduleKey) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.feeExemptKeyList) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.customFees) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 1)
    }
    try { if let v = self._adminKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._submitKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._autoRenewPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._autoRenewAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._feeScheduleKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.feeExemptKeyList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feeExemptKeyList, fieldNumber: 9)
    }
    if !self.customFees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customFees, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ConsensusCreateTopicTransactionBody, rhs: Proto_ConsensusCreateTopicTransactionBody) -> Bool {
    if lhs.memo != rhs.memo {return false}
    if lhs._adminKey != rhs._adminKey {return false}
    if lhs._submitKey != rhs._submitKey {return false}
    if lhs._autoRenewPeriod != rhs._autoRenewPeriod {return false}
    if lhs._autoRenewAccount != rhs._autoRenewAccount {return false}
    if lhs._feeScheduleKey != rhs._feeScheduleKey {return false}
    if lhs.feeExemptKeyList != rhs.feeExemptKeyList {return false}
    if lhs.customFees != rhs.customFees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
