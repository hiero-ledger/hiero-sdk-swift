// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/contract_update.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Contract Update
/// Modify a smart contract. Any change other than updating the expiration time
/// requires that the contract be modifiable (has a valid `adminKey`) and that
/// the transaction be signed by the `adminKey`
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Modify the current state of a smart contract.
///
/// ### Requirements
/// - The `adminKey` MUST sign all contract update transactions except one
///   that only updates the `expirationTime`.
/// - A transaction that modifies any field other than `expirationTime` for
///   a contract without a valid `adminKey` set SHALL fail with response
///   code `MODIFYING_IMMUTABLE_CONTRACT`.
/// - Fields set to non-default values in this transaction SHALL be updated on
///   success. Fields not set to non-default values SHALL NOT be
///   updated on success.
///
/// ### Block Stream Effects
/// None
public struct Proto_ContractUpdateTransactionBody: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The contact ID that identifies the smart contract to be updated.<br/>
  /// This field MUST be set, and MUST NOT be a default ID (`0.0.0`).
  public var contractID: Proto_ContractID {
    get {return _storage._contractID ?? Proto_ContractID()}
    set {_uniqueStorage()._contractID = newValue}
  }
  /// Returns true if `contractID` has been explicitly set.
  public var hasContractID: Bool {return _storage._contractID != nil}
  /// Clears the value of `contractID`. Subsequent reads from it will return its default value.
  public mutating func clearContractID() {_uniqueStorage()._contractID = nil}

  ///*
  /// If set, modify the time at which this contract will expire.<br/>
  /// An expired contract requires a rent payment to "renew" the contract.
  /// A transaction to update this field is how that rent payment is made.
  /// <p>
  /// This value MUST NOT be less than the current `expirationTime`
  /// of the contract. If this value is earlier than the current
  /// value, the transaction SHALL fail with response
  /// code `EXPIRATION_REDUCTION_NOT_ALLOWED`.
  public var expirationTime: Proto_Timestamp {
    get {return _storage._expirationTime ?? Proto_Timestamp()}
    set {_uniqueStorage()._expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  public var hasExpirationTime: Bool {return _storage._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

  ///*
  /// If set, modify the key that authorizes updates to the contract.
  /// <p>
  /// If this field is set to a valid Key, this key and the previously set key
  /// MUST both sign this transaction.<br/>
  /// If this value is an empty `KeyList`, the prior key MUST sign this
  /// transaction, and the smart contract SHALL be immutable after this
  /// transaction completes, except for expiration and renewal.<br/>
  /// If this value is not an empty `KeyList`, but does not contain any
  /// cryptographic keys, or is otherwise malformed, this transaction SHALL
  /// fail with response code `INVALID_ADMIN_KEY`.
  public var adminKey: Proto_Key {
    get {return _storage._adminKey ?? Proto_Key()}
    set {_uniqueStorage()._adminKey = newValue}
  }
  /// Returns true if `adminKey` has been explicitly set.
  public var hasAdminKey: Bool {return _storage._adminKey != nil}
  /// Clears the value of `adminKey`. Subsequent reads from it will return its default value.
  public mutating func clearAdminKey() {_uniqueStorage()._adminKey = nil}

  ///*
  /// Replaced with `staked_id` alternatives.
  /// This field is unused and SHALL NOT modify the contract state.<br/>
  /// The id of an account to which the contract is proxy staked
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var proxyAccountID: Proto_AccountID {
    get {return _storage._proxyAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._proxyAccountID = newValue}
  }
  /// Returns true if `proxyAccountID` has been explicitly set.
  public var hasProxyAccountID: Bool {return _storage._proxyAccountID != nil}
  /// Clears the value of `proxyAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearProxyAccountID() {_uniqueStorage()._proxyAccountID = nil}

  ///*
  /// If set, modify the duration added to expiration time by each
  /// auto-renewal to this value.
  public var autoRenewPeriod: Proto_Duration {
    get {return _storage._autoRenewPeriod ?? Proto_Duration()}
    set {_uniqueStorage()._autoRenewPeriod = newValue}
  }
  /// Returns true if `autoRenewPeriod` has been explicitly set.
  public var hasAutoRenewPeriod: Bool {return _storage._autoRenewPeriod != nil}
  /// Clears the value of `autoRenewPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewPeriod() {_uniqueStorage()._autoRenewPeriod = nil}

  ///*
  /// This field is unused and SHALL NOT modify the contract state.<br/>
  /// Previously, an ID of a file containing the bytecode of the Solidity
  /// transaction that created this contract.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var fileID: Proto_FileID {
    get {return _storage._fileID ?? Proto_FileID()}
    set {_uniqueStorage()._fileID = newValue}
  }
  /// Returns true if `fileID` has been explicitly set.
  public var hasFileID: Bool {return _storage._fileID != nil}
  /// Clears the value of `fileID`. Subsequent reads from it will return its default value.
  public mutating func clearFileID() {_uniqueStorage()._fileID = nil}

  /// This should be condensed to just a field instead of a oneof and field 9 reserved.
  public var memoField: OneOf_MemoField? {
    get {return _storage._memoField}
    set {_uniqueStorage()._memoField = newValue}
  }

  ///*
  /// This value could not accurately distinguish unset or deliberately
  /// empty. memoWrapper should be used instead.<br/>
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var memo: String {
    get {
      if case .memo(let v)? = _storage._memoField {return v}
      return String()
    }
    set {_uniqueStorage()._memoField = .memo(newValue)}
  }

  ///*
  /// If set, modify the short memo for this smart contract.
  /// <p>
  /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
  /// (default 100) bytes when encoded as UTF-8.
  public var memoWrapper: SwiftProtobuf.Google_Protobuf_StringValue {
    get {
      if case .memoWrapper(let v)? = _storage._memoField {return v}
      return SwiftProtobuf.Google_Protobuf_StringValue()
    }
    set {_uniqueStorage()._memoField = .memoWrapper(newValue)}
  }

  ///*
  /// If set, modify the maximum number of tokens that can be auto-associated with the
  /// contract.
  /// <p>
  /// If this is set and less than or equal to `used_auto_associations`, or 0, then this contract
  /// MUST manually associate with a token before transacting in that token.<br/>
  /// This value MAY also be `-1` to indicate no limit.<br/>
  /// This value MUST NOT be less than `-1`.
  public var maxAutomaticTokenAssociations: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._maxAutomaticTokenAssociations ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._maxAutomaticTokenAssociations = newValue}
  }
  /// Returns true if `maxAutomaticTokenAssociations` has been explicitly set.
  public var hasMaxAutomaticTokenAssociations: Bool {return _storage._maxAutomaticTokenAssociations != nil}
  /// Clears the value of `maxAutomaticTokenAssociations`. Subsequent reads from it will return its default value.
  public mutating func clearMaxAutomaticTokenAssociations() {_uniqueStorage()._maxAutomaticTokenAssociations = nil}

  ///*
  /// If set, modify the account, in the same shard and realm as this smart
  /// contract, that has agreed to allow the network to use its balance, when
  /// needed, to automatically extend this contract's expiration time.
  /// <p>
  /// If this field is set to a non-default value, that Account MUST sign this
  /// transaction.<br/>
  /// If this field is set to a default AccountID value (`0.0.0`), any
  /// pre-existing `auto_renew_account_id` value SHALL be removed on success.
  public var autoRenewAccountID: Proto_AccountID {
    get {return _storage._autoRenewAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._autoRenewAccountID = newValue}
  }
  /// Returns true if `autoRenewAccountID` has been explicitly set.
  public var hasAutoRenewAccountID: Bool {return _storage._autoRenewAccountID != nil}
  /// Clears the value of `autoRenewAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewAccountID() {_uniqueStorage()._autoRenewAccountID = nil}

  public var stakedID: OneOf_StakedID? {
    get {return _storage._stakedID}
    set {_uniqueStorage()._stakedID = newValue}
  }

  ///*
  /// An account identifier.<br/>
  /// A staked account acts as a proxy, and this contract effectively
  /// nominates the same node as the identified account.
  /// <p>
  /// If set, modify this smart contract such that it SHALL stake its HBAR
  /// to the same node as the identified account.<br/>
  /// If this field is set to a default AccountID value (`0.0.0`), any
  /// pre-existing `staked_account_id` value SHALL be removed on success.
  public var stakedAccountID: Proto_AccountID {
    get {
      if case .stakedAccountID(let v)? = _storage._stakedID {return v}
      return Proto_AccountID()
    }
    set {_uniqueStorage()._stakedID = .stakedAccountID(newValue)}
  }

  ///*
  /// A node identifier.<br/>
  /// A staked node identifier indicates the consensus node that this
  /// account nominates for staking.
  /// <p>
  /// If set, modify this smart contract such that it SHALL stake its HBAR
  /// to this node.
  /// If set to a the value `-1` any pre-existing `staked_node_id` value
  /// SHALL be removed on success.
  /// <p>
  /// <blockquote>Note: node IDs do fluctuate as node operators change.
  /// Most contracts are immutable, and a contract staking to an invalid
  /// node ID SHALL NOT participate in staking. Immutable contracts may
  /// find it more reliable to use a proxy account for staking (via
  /// `staked_account_id`) to enable updating the _effective_ staking node
  /// ID when necessary through updating the proxy account.</blockquote>
  public var stakedNodeID: Int64 {
    get {
      if case .stakedNodeID(let v)? = _storage._stakedID {return v}
      return 0
    }
    set {_uniqueStorage()._stakedID = .stakedNodeID(newValue)}
  }

  ///*
  /// A flag indicating if staking rewards are declined.<br/>
  /// If set, modify the flag indicating if this contract declines to accept
  /// rewards for staking its HBAR to secure the network.
  /// <p>
  /// If set to true, this smart contract SHALL NOT receive any reward for
  /// staking its HBAR balance to help secure the network, regardless of
  /// staking configuration, but MAY stake HBAR to support the network
  /// without reward.
  public var declineReward: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._declineReward ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._declineReward = newValue}
  }
  /// Returns true if `declineReward` has been explicitly set.
  public var hasDeclineReward: Bool {return _storage._declineReward != nil}
  /// Clears the value of `declineReward`. Subsequent reads from it will return its default value.
  public mutating func clearDeclineReward() {_uniqueStorage()._declineReward = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// This should be condensed to just a field instead of a oneof and field 9 reserved.
  public enum OneOf_MemoField: Equatable, Sendable {
    ///*
    /// This value could not accurately distinguish unset or deliberately
    /// empty. memoWrapper should be used instead.<br/>
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    case memo(String)
    ///*
    /// If set, modify the short memo for this smart contract.
    /// <p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    case memoWrapper(SwiftProtobuf.Google_Protobuf_StringValue)

  }

  public enum OneOf_StakedID: Equatable, Sendable {
    ///*
    /// An account identifier.<br/>
    /// A staked account acts as a proxy, and this contract effectively
    /// nominates the same node as the identified account.
    /// <p>
    /// If set, modify this smart contract such that it SHALL stake its HBAR
    /// to the same node as the identified account.<br/>
    /// If this field is set to a default AccountID value (`0.0.0`), any
    /// pre-existing `staked_account_id` value SHALL be removed on success.
    case stakedAccountID(Proto_AccountID)
    ///*
    /// A node identifier.<br/>
    /// A staked node identifier indicates the consensus node that this
    /// account nominates for staking.
    /// <p>
    /// If set, modify this smart contract such that it SHALL stake its HBAR
    /// to this node.
    /// If set to a the value `-1` any pre-existing `staked_node_id` value
    /// SHALL be removed on success.
    /// <p>
    /// <blockquote>Note: node IDs do fluctuate as node operators change.
    /// Most contracts are immutable, and a contract staking to an invalid
    /// node ID SHALL NOT participate in staking. Immutable contracts may
    /// find it more reliable to use a proxy account for staking (via
    /// `staked_account_id`) to enable updating the _effective_ staking node
    /// ID when necessary through updating the proxy account.</blockquote>
    case stakedNodeID(Int64)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ContractUpdateTransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContractUpdateTransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "expirationTime"),
    3: .same(proto: "adminKey"),
    6: .same(proto: "proxyAccountID"),
    7: .same(proto: "autoRenewPeriod"),
    8: .same(proto: "fileID"),
    9: .same(proto: "memo"),
    10: .same(proto: "memoWrapper"),
    11: .standard(proto: "max_automatic_token_associations"),
    12: .standard(proto: "auto_renew_account_id"),
    13: .standard(proto: "staked_account_id"),
    14: .standard(proto: "staked_node_id"),
    15: .standard(proto: "decline_reward"),
  ]

  fileprivate class _StorageClass {
    var _contractID: Proto_ContractID? = nil
    var _expirationTime: Proto_Timestamp? = nil
    var _adminKey: Proto_Key? = nil
    var _proxyAccountID: Proto_AccountID? = nil
    var _autoRenewPeriod: Proto_Duration? = nil
    var _fileID: Proto_FileID? = nil
    var _memoField: Proto_ContractUpdateTransactionBody.OneOf_MemoField?
    var _maxAutomaticTokenAssociations: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _autoRenewAccountID: Proto_AccountID? = nil
    var _stakedID: Proto_ContractUpdateTransactionBody.OneOf_StakedID?
    var _declineReward: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _contractID = source._contractID
      _expirationTime = source._expirationTime
      _adminKey = source._adminKey
      _proxyAccountID = source._proxyAccountID
      _autoRenewPeriod = source._autoRenewPeriod
      _fileID = source._fileID
      _memoField = source._memoField
      _maxAutomaticTokenAssociations = source._maxAutomaticTokenAssociations
      _autoRenewAccountID = source._autoRenewAccountID
      _stakedID = source._stakedID
      _declineReward = source._declineReward
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._contractID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._expirationTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._adminKey) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._proxyAccountID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewPeriod) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._fileID) }()
        case 9: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._memoField != nil {try decoder.handleConflictingOneOf()}
            _storage._memoField = .memo(v)
          }
        }()
        case 10: try {
          var v: SwiftProtobuf.Google_Protobuf_StringValue?
          var hadOneofValue = false
          if let current = _storage._memoField {
            hadOneofValue = true
            if case .memoWrapper(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._memoField = .memoWrapper(v)
          }
        }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._maxAutomaticTokenAssociations) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewAccountID) }()
        case 13: try {
          var v: Proto_AccountID?
          var hadOneofValue = false
          if let current = _storage._stakedID {
            hadOneofValue = true
            if case .stakedAccountID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._stakedID = .stakedAccountID(v)
          }
        }()
        case 14: try {
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {
            if _storage._stakedID != nil {try decoder.handleConflictingOneOf()}
            _storage._stakedID = .stakedNodeID(v)
          }
        }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._declineReward) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._contractID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._adminKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._proxyAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._autoRenewPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._fileID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      switch _storage._memoField {
      case .memo?: try {
        guard case .memo(let v)? = _storage._memoField else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }()
      case .memoWrapper?: try {
        guard case .memoWrapper(let v)? = _storage._memoField else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
      try { if let v = _storage._maxAutomaticTokenAssociations {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._autoRenewAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      switch _storage._stakedID {
      case .stakedAccountID?: try {
        guard case .stakedAccountID(let v)? = _storage._stakedID else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .stakedNodeID?: try {
        guard case .stakedNodeID(let v)? = _storage._stakedID else { preconditionFailure() }
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 14)
      }()
      case nil: break
      }
      try { if let v = _storage._declineReward {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ContractUpdateTransactionBody, rhs: Proto_ContractUpdateTransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contractID != rhs_storage._contractID {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._adminKey != rhs_storage._adminKey {return false}
        if _storage._proxyAccountID != rhs_storage._proxyAccountID {return false}
        if _storage._autoRenewPeriod != rhs_storage._autoRenewPeriod {return false}
        if _storage._fileID != rhs_storage._fileID {return false}
        if _storage._memoField != rhs_storage._memoField {return false}
        if _storage._maxAutomaticTokenAssociations != rhs_storage._maxAutomaticTokenAssociations {return false}
        if _storage._autoRenewAccountID != rhs_storage._autoRenewAccountID {return false}
        if _storage._stakedID != rhs_storage._stakedID {return false}
        if _storage._declineReward != rhs_storage._declineReward {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
