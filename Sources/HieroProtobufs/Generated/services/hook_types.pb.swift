// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/hook_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///**
/// The Hiero extension points that accept a hook.
public enum Com_Hedera_Hapi_Node_Hooks_HookExtensionPoint: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// Used to customize an account's allowances during a CryptoTransfer transaction.
  case accountAllowanceHook // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .accountAllowanceHook
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .accountAllowanceHook
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .accountAllowanceHook: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Com_Hedera_Hapi_Node_Hooks_HookExtensionPoint] = [
    .accountAllowanceHook,
  ]

}

///*
/// Specifies the creation of a new hook at the given id for the given entity.
public struct Com_Hedera_Hapi_Node_Hooks_HookCreation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The id of the hook's entity.
  public var entityID: Proto_HookEntityId {
    get {return _entityID ?? Proto_HookEntityId()}
    set {_entityID = newValue}
  }
  /// Returns true if `entityID` has been explicitly set.
  public var hasEntityID: Bool {return self._entityID != nil}
  /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
  public mutating func clearEntityID() {self._entityID = nil}

  ///*
  /// The creation details.
  public var details: Com_Hedera_Hapi_Node_Hooks_HookCreationDetails {
    get {return _details ?? Com_Hedera_Hapi_Node_Hooks_HookCreationDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  public var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  public mutating func clearDetails() {self._details = nil}

  ///*
  /// If set, the id of the hook following this one in the owner's
  /// doubly-linked list of hooks.
  public var nextHookID: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _nextHookID ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_nextHookID = newValue}
  }
  /// Returns true if `nextHookID` has been explicitly set.
  public var hasNextHookID: Bool {return self._nextHookID != nil}
  /// Clears the value of `nextHookID`. Subsequent reads from it will return its default value.
  public mutating func clearNextHookID() {self._nextHookID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entityID: Proto_HookEntityId? = nil
  fileprivate var _details: Com_Hedera_Hapi_Node_Hooks_HookCreationDetails? = nil
  fileprivate var _nextHookID: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

///**
/// The details of a hook's creation.
public struct Com_Hedera_Hapi_Node_Hooks_HookCreationDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The extension point for the hook.
  public var extensionPoint: Com_Hedera_Hapi_Node_Hooks_HookExtensionPoint = .accountAllowanceHook

  ///*
  /// The id to create the hook at.
  public var hookID: Int64 = 0

  ///*
  /// The hook implementation.
  public var hook: Com_Hedera_Hapi_Node_Hooks_HookCreationDetails.OneOf_Hook? = nil

  ///*
  /// A hook programmed in EVM bytecode that does not require access to state
  /// or interactions with external contracts.
  public var pureEvmHook: Com_Hedera_Hapi_Node_Hooks_PureEvmHook {
    get {
      if case .pureEvmHook(let v)? = hook {return v}
      return Com_Hedera_Hapi_Node_Hooks_PureEvmHook()
    }
    set {hook = .pureEvmHook(newValue)}
  }

  ///*
  /// A hook programmed in EVM bytecode that may access state or interact with
  /// external contracts.
  public var lambdaEvmHook: Com_Hedera_Hapi_Node_Hooks_LambdaEvmHook {
    get {
      if case .lambdaEvmHook(let v)? = hook {return v}
      return Com_Hedera_Hapi_Node_Hooks_LambdaEvmHook()
    }
    set {hook = .lambdaEvmHook(newValue)}
  }

  ///*
  /// If set, a key that that can be used to remove or replace the hook; or (if
  /// applicable, as with a lambda EVM hook) perform transactions that customize
  /// the hook.
  public var adminKey: Proto_Key {
    get {return _adminKey ?? Proto_Key()}
    set {_adminKey = newValue}
  }
  /// Returns true if `adminKey` has been explicitly set.
  public var hasAdminKey: Bool {return self._adminKey != nil}
  /// Clears the value of `adminKey`. Subsequent reads from it will return its default value.
  public mutating func clearAdminKey() {self._adminKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// The hook implementation.
  public enum OneOf_Hook: Equatable, Sendable {
    ///*
    /// A hook programmed in EVM bytecode that does not require access to state
    /// or interactions with external contracts.
    case pureEvmHook(Com_Hedera_Hapi_Node_Hooks_PureEvmHook)
    ///*
    /// A hook programmed in EVM bytecode that may access state or interact with
    /// external contracts.
    case lambdaEvmHook(Com_Hedera_Hapi_Node_Hooks_LambdaEvmHook)

  }

  public init() {}

  fileprivate var _adminKey: Proto_Key? = nil
}

///*
/// Definition of a lambda EVM hook.
public struct Com_Hedera_Hapi_Node_Hooks_PureEvmHook: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The specification for the hook.
  public var spec: Com_Hedera_Hapi_Node_Hooks_EvmHookSpec {
    get {return _spec ?? Com_Hedera_Hapi_Node_Hooks_EvmHookSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  public var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  public mutating func clearSpec() {self._spec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spec: Com_Hedera_Hapi_Node_Hooks_EvmHookSpec? = nil
}

///*
/// Definition of a lambda EVM hook.
public struct Com_Hedera_Hapi_Node_Hooks_LambdaEvmHook: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The specification for the hook.
  public var spec: Com_Hedera_Hapi_Node_Hooks_EvmHookSpec {
    get {return _spec ?? Com_Hedera_Hapi_Node_Hooks_EvmHookSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  public var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  public mutating func clearSpec() {self._spec = nil}

  ///*
  /// Initial storage updates for the lambda, if any.
  public var storageUpdates: [Com_Hedera_Hapi_Node_Hooks_LambdaStorageUpdate] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spec: Com_Hedera_Hapi_Node_Hooks_EvmHookSpec? = nil
}

///*
/// Shared specifications for an EVM hook. May be used for any extension point.
public struct Com_Hedera_Hapi_Node_Hooks_EvmHookSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The source of the EVM bytecode for the hook.
  public var bytecodeSource: Com_Hedera_Hapi_Node_Hooks_EvmHookSpec.OneOf_BytecodeSource? = nil

  ///*
  /// The id of a contract that implements the extension point API with EVM bytecode.
  public var contractID: Proto_ContractID {
    get {
      if case .contractID(let v)? = bytecodeSource {return v}
      return Proto_ContractID()
    }
    set {bytecodeSource = .contractID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// The source of the EVM bytecode for the hook.
  public enum OneOf_BytecodeSource: Equatable, Sendable {
    ///*
    /// The id of a contract that implements the extension point API with EVM bytecode.
    case contractID(Proto_ContractID)

  }

  public init() {}
}

///*
/// Specifies a key/value pair in the storage of a lambda, either by the explicit storage
/// slot contents; or by a combination of a Solidity mapping's slot key and the key into
/// that mapping.
public struct Com_Hedera_Hapi_Node_Hooks_LambdaStorageUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var update: Com_Hedera_Hapi_Node_Hooks_LambdaStorageUpdate.OneOf_Update? = nil

  ///*
  /// An explicit storage slot update.
  public var storageSlot: Com_Hedera_Hapi_Node_Hooks_LambdaStorageSlot {
    get {
      if case .storageSlot(let v)? = update {return v}
      return Com_Hedera_Hapi_Node_Hooks_LambdaStorageSlot()
    }
    set {update = .storageSlot(newValue)}
  }

  ///*
  /// Implicit storage slot updates specified as Solidity mapping entries.
  public var mappingEntries: Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntries {
    get {
      if case .mappingEntries(let v)? = update {return v}
      return Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntries()
    }
    set {update = .mappingEntries(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Update: Equatable, Sendable {
    ///*
    /// An explicit storage slot update.
    case storageSlot(Com_Hedera_Hapi_Node_Hooks_LambdaStorageSlot)
    ///*
    /// Implicit storage slot updates specified as Solidity mapping entries.
    case mappingEntries(Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntries)

  }

  public init() {}
}

///*
/// Specifies storage slot updates via indirection into a Solidity mapping.
/// <p>
/// Concretely, if the Solidity mapping is itself at slot `mapping_slot`, then
/// the * storage slot for key `key` in the mapping is defined by the relationship
/// `key_storage_slot = keccak256(abi.encodePacked(mapping_slot, key))`.
/// <p>
/// This message lets a metaprotocol be specified in terms of changes to a
/// Solidity mapping's entries. If only raw slots could be updated, then a block
/// stream consumer following the metaprotocol would have to invert the Keccak256
/// hash to determine which mapping entry was being updated, which is not possible.
public struct Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntries: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The slot that corresponds to the Solidity mapping itself. Must use a
  /// minimal byte representation (no leading zeros).
  public var mappingSlot: Data = Data()

  ///*
  /// The entries in the mapping at the given slot.
  public var entries: [Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// An entry in a Solidity mapping. Very helpful for protocols that apply
/// `LambdaSStore` to manage the entries of a hook contract's mapping instead
/// its raw storage slots.
/// <p>
/// This is especially attractive when the mapping value itself fits in a single
/// word; for more complicated value storage layouts it becomes necessary to
/// combine the mapping update with additional `LambdaStorageSlot` updates that
/// specify the complete storage slots of the value type.
public struct Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntry: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entryKey: Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntry.OneOf_EntryKey? = nil

  ///*
  /// The explicit bytes of the mapping entry. Must use a minimal byte representation;
  /// may not exceed 32 bytes in length.
  public var key: Data {
    get {
      if case .key(let v)? = entryKey {return v}
      return Data()
    }
    set {entryKey = .key(newValue)}
  }

  ///*
  /// The bytes that are the preimage of the Keccak256 hash that forms the mapping key.
  /// May be longer or shorter than 32 bytes and may have leading zeros, since Solidity
  /// supports variable-length keys in mappings.
  public var preimage: Data {
    get {
      if case .preimage(let v)? = entryKey {return v}
      return Data()
    }
    set {entryKey = .preimage(newValue)}
  }

  ///*
  /// If the mapping entry is present and non-zero, its value. May not be longer than
  /// 32 bytes in length; must use a minimal byte representation (no leading zeros).
  /// Leaving this field empty in an update removes the entry from the mapping.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_EntryKey: Equatable, @unchecked Sendable {
    ///*
    /// The explicit bytes of the mapping entry. Must use a minimal byte representation;
    /// may not exceed 32 bytes in length.
    case key(Data)
    ///*
    /// The bytes that are the preimage of the Keccak256 hash that forms the mapping key.
    /// May be longer or shorter than 32 bytes and may have leading zeros, since Solidity
    /// supports variable-length keys in mappings.
    case preimage(Data)

  }

  public init() {}
}

///*
/// A slot in the storage of a lambda EVM hook.
public struct Com_Hedera_Hapi_Node_Hooks_LambdaStorageSlot: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The key of the slot. Must use a minimal byte representation (no
  /// leading zeros); may not exceed 32 bytes in length.
  public var key: Data = Data()

  ///*
  /// If the slot is present and non-zero, its value. Must use a minimal
  /// byte representation (no leading zeros); may not exceed 32 bytes in
  /// length Leaving this field empty in an update removes the slot from
  /// storage.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.hedera.hapi.node.hooks"

extension Com_Hedera_Hapi_Node_Hooks_HookExtensionPoint: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCOUNT_ALLOWANCE_HOOK"),
  ]
}

extension Com_Hedera_Hapi_Node_Hooks_HookCreation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HookCreation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .same(proto: "details"),
    9: .standard(proto: "next_hook_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entityID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._nextHookID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entityID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nextHookID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_Hooks_HookCreation, rhs: Com_Hedera_Hapi_Node_Hooks_HookCreation) -> Bool {
    if lhs._entityID != rhs._entityID {return false}
    if lhs._details != rhs._details {return false}
    if lhs._nextHookID != rhs._nextHookID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_Hooks_HookCreationDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HookCreationDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "extension_point"),
    2: .standard(proto: "hook_id"),
    3: .standard(proto: "pure_evm_hook"),
    4: .standard(proto: "lambda_evm_hook"),
    5: .standard(proto: "admin_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.extensionPoint) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.hookID) }()
      case 3: try {
        var v: Com_Hedera_Hapi_Node_Hooks_PureEvmHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .pureEvmHook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .pureEvmHook(v)
        }
      }()
      case 4: try {
        var v: Com_Hedera_Hapi_Node_Hooks_LambdaEvmHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .lambdaEvmHook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .lambdaEvmHook(v)
        }
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._adminKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.extensionPoint != .accountAllowanceHook {
      try visitor.visitSingularEnumField(value: self.extensionPoint, fieldNumber: 1)
    }
    if self.hookID != 0 {
      try visitor.visitSingularInt64Field(value: self.hookID, fieldNumber: 2)
    }
    switch self.hook {
    case .pureEvmHook?: try {
      guard case .pureEvmHook(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .lambdaEvmHook?: try {
      guard case .lambdaEvmHook(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try { if let v = self._adminKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_Hooks_HookCreationDetails, rhs: Com_Hedera_Hapi_Node_Hooks_HookCreationDetails) -> Bool {
    if lhs.extensionPoint != rhs.extensionPoint {return false}
    if lhs.hookID != rhs.hookID {return false}
    if lhs.hook != rhs.hook {return false}
    if lhs._adminKey != rhs._adminKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_Hooks_PureEvmHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PureEvmHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_Hooks_PureEvmHook, rhs: Com_Hedera_Hapi_Node_Hooks_PureEvmHook) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_Hooks_LambdaEvmHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LambdaEvmHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spec"),
    2: .standard(proto: "storage_updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.storageUpdates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.storageUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storageUpdates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_Hooks_LambdaEvmHook, rhs: Com_Hedera_Hapi_Node_Hooks_LambdaEvmHook) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.storageUpdates != rhs.storageUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_Hooks_EvmHookSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvmHookSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_ContractID?
        var hadOneofValue = false
        if let current = self.bytecodeSource {
          hadOneofValue = true
          if case .contractID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.bytecodeSource = .contractID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .contractID(let v)? = self.bytecodeSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_Hooks_EvmHookSpec, rhs: Com_Hedera_Hapi_Node_Hooks_EvmHookSpec) -> Bool {
    if lhs.bytecodeSource != rhs.bytecodeSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_Hooks_LambdaStorageUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LambdaStorageUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "storage_slot"),
    2: .standard(proto: "mapping_entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Hedera_Hapi_Node_Hooks_LambdaStorageSlot?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .storageSlot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .storageSlot(v)
        }
      }()
      case 2: try {
        var v: Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntries?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .mappingEntries(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .mappingEntries(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.update {
    case .storageSlot?: try {
      guard case .storageSlot(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .mappingEntries?: try {
      guard case .mappingEntries(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_Hooks_LambdaStorageUpdate, rhs: Com_Hedera_Hapi_Node_Hooks_LambdaStorageUpdate) -> Bool {
    if lhs.update != rhs.update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntries: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LambdaMappingEntries"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mapping_slot"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.mappingSlot) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mappingSlot.isEmpty {
      try visitor.visitSingularBytesField(value: self.mappingSlot, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntries, rhs: Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntries) -> Bool {
    if lhs.mappingSlot != rhs.mappingSlot {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LambdaMappingEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "preimage"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.entryKey != nil {try decoder.handleConflictingOneOf()}
          self.entryKey = .key(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.entryKey != nil {try decoder.handleConflictingOneOf()}
          self.entryKey = .preimage(v)
        }
      }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.entryKey {
    case .key?: try {
      guard case .key(let v)? = self.entryKey else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .preimage?: try {
      guard case .preimage(let v)? = self.entryKey else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntry, rhs: Com_Hedera_Hapi_Node_Hooks_LambdaMappingEntry) -> Bool {
    if lhs.entryKey != rhs.entryKey {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_Hooks_LambdaStorageSlot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LambdaStorageSlot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_Hooks_LambdaStorageSlot, rhs: Com_Hedera_Hapi_Node_Hooks_LambdaStorageSlot) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
