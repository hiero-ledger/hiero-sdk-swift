// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/basic_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Basic Types
/// Fundamental message types used across transactions and state as field types.
///
/// ### Requirements for identifier values
/// - Most entities in the network SHALL be identified by a multi-part
///   identifier. These identifier values SHALL consist of a shard, a realm, and
///   an entity identifier.
/// - Shard, Realm, and Entity Number MUST all be whole numbers.
/// - A Shard SHALL be globally unique.
/// - A Realm MAY be reused between shards, but SHALL be unique within a shard.
/// - An Entity Number MAY be reused between shards and realms, but SHALL be
///   unique within each combination of shard and realm.
/// - Every object (e.g. account, file, token, etc...) SHALL be scoped to exactly
///   one realm and shard. Thus a File has a FileID, a numeric triplet, such as
///   0.0.2 for shard 0, realm 0, entity 2.
/// - Identifier values SHOULD use an Entity Number as the third component of the
///   identifier. Some, however, MAY use alternative or composite values for the
///   Entity portion of the three part identifier. Any such alternative or
///   composite value MUST be unique within that shard and realm combination.
/// - The entity portion of the identifier, regardless of type, MUST be unique
///   within that realm and shard combination and MAY be globally unique.
/// - The triplet of shard.realm.entity MUST be globally unique, even across
///   different identifier types.
/// - Each realm SHALL maintain a single counter for entity numbers, so if there
///   is an identifier with value 0.1.2, then there MUST NOT be an identifier
///   with value 0.1.2 for any other object.
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A specific hash algorithm.
///
/// We did not reuse Record Stream `HashAlgorithm` here because in all cases,
/// currently, this will be `SHA2_384` and if that is the default value then
/// we can save space by not serializing it, whereas `HASH_ALGORITHM_UNKNOWN`
/// is the default for Record Stream `HashAlgorithm`.
///
/// Note that enum values here MUST NOT match the name of any other enum value
/// in the same `package`, as protobuf follows `C++` scope rules and all enum
/// _names_ are treated as global constants within the `package`.
public enum Proto_BlockHashAlgorithm: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// A SHA2 algorithm SHA-384 hash.
  /// <p>
  /// This is the default value, if a field of this enumerated type is
  /// not set, then this is the value that will be decoded when the
  /// serialized message is read.
  case sha2384 // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .sha2384
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sha2384
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sha2384: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_BlockHashAlgorithm] = [
    .sha2384,
  ]

}

///*
/// Possible Token Types (IWA Compatibility).
///
/// Apart from fungible and non-fungible, Tokens can have either a common or
/// unique representation. Furthermore, tokens can have intrinsic or referential
/// value, and can be whole and indivisible or fractional.<br/>
/// These distinction might seem subtle, but it is important when considering
/// how tokens can be traced, used, transferred, and if they can have isolated
/// unique properties.
///
/// A few examples (these may not match enumerations below) using IWA taxonomy.
/// <dl>
///   <dt>fungible, whole, intrinsic, unique</dt>
///     <dd>Physical fiat currency</dd>
///   <dt>fungible, fractional, intrinsic, common</dt>
///     <dd>bank balance fiat currency</dd>
///   <dt>non-fungible, fractional, reference, unique</dt>
///     <dd>"mutual" collectible/art/property ownership</dd>
///   <dt>non-fungible, whole, intrinsic, unique</dt>
///     <dd>Physical work of fine art</dd>
///   <dt>non-fungible, whole, reference, unique</dt>
///     <dd>Registered property title</dd>
/// </dl>
public enum Proto_TokenType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// A fungible/common token.<br/>
  /// Tokens of this type are interchangeable with one another, where any
  /// quantity of tokens has the same value as another equal quantity, if
  /// they are in the same class. Tokens share a single set of properties,
  /// and are not distinct from one another. Ownership is represented as a
  /// balance or quantity associated to a given account. Tokens may be
  /// divided into fractional tokens, within reasonable limits.
  /// <p>
  /// IWA taxonomy _fungible, fractional, intrinsic, common_
  case fungibleCommon // = 0

  ///*
  /// A non-fungible/unique token.<br/>
  /// Tokens of this type are unique, and are not interchangeable with other
  /// tokens of the same type. Each token carries a serial number which is
  /// unique for that token, these tokens may have a different trade value
  /// for each individual token. The tokens are individually accounted and
  /// often carry additional unique properties. Tokens cannot be subdivided,
  /// and value is related to what the individual token represents.
  /// <p>
  /// IWA taxonomy _non-fungible, whole, reference, unique_
  case nonFungibleUnique // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .fungibleCommon
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fungibleCommon
    case 1: self = .nonFungibleUnique
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .fungibleCommon: return 0
    case .nonFungibleUnique: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_TokenType] = [
    .fungibleCommon,
    .nonFungibleUnique,
  ]

}

///*
/// A transaction sub type.<br/>
/// This enumeration enables a set of transaction base fees to be broadly
/// defined for a type of operation and also be modified, when necessary,
/// based on specifics of the operation.
///
/// ### Explanation
/// The resource cost for a TokenMint operation is different between minting
/// fungible/common and non-fungible/unique tokens. This `enum` is used to
/// "mark" a cost as applying to one or the other.<br/>
/// Similarly, the resource cost for a basic `tokenCreate` without a custom
/// fee schedule may yield a _base_ fee of $1. The resource cost for a
/// `tokenCreate` _with_ a custom fee schedule is different and may yield a
/// _base_ fee of $2 or more.
public enum Proto_SubType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// The resource cost for the transaction type has no additional attributes
  case `default` // = 0

  ///*
  /// The resource cost for the transaction type includes an operation on a
  /// fungible/common token
  case tokenFungibleCommon // = 1

  ///*
  /// The resource cost for the transaction type includes an operation on
  /// a non-fungible/unique token
  case tokenNonFungibleUnique // = 2

  ///*
  /// The resource cost for the transaction type includes an operation on a
  /// fungible/common token with a custom fee schedule
  case tokenFungibleCommonWithCustomFees // = 3

  ///*
  /// The resource cost for the transaction type includes an operation on a
  /// non-fungible/unique token with a custom fee schedule
  case tokenNonFungibleUniqueWithCustomFees // = 4

  ///*
  /// The resource cost for the transaction type includes a ScheduleCreate
  /// containing a ContractCall.
  case scheduleCreateContractCall // = 5

  ///*
  /// The resource cost for the transaction type includes a TopicCreate
  /// with custom fees.
  case topicCreateWithCustomFees // = 6

  ///*
  /// The resource cost for the transaction type includes a ConsensusSubmitMessage
  /// for a topic with custom fees.
  case submitMessageWithCustomFees // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .tokenFungibleCommon
    case 2: self = .tokenNonFungibleUnique
    case 3: self = .tokenFungibleCommonWithCustomFees
    case 4: self = .tokenNonFungibleUniqueWithCustomFees
    case 5: self = .scheduleCreateContractCall
    case 6: self = .topicCreateWithCustomFees
    case 7: self = .submitMessageWithCustomFees
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .tokenFungibleCommon: return 1
    case .tokenNonFungibleUnique: return 2
    case .tokenFungibleCommonWithCustomFees: return 3
    case .tokenNonFungibleUniqueWithCustomFees: return 4
    case .scheduleCreateContractCall: return 5
    case .topicCreateWithCustomFees: return 6
    case .submitMessageWithCustomFees: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_SubType] = [
    .default,
    .tokenFungibleCommon,
    .tokenNonFungibleUnique,
    .tokenFungibleCommonWithCustomFees,
    .tokenNonFungibleUniqueWithCustomFees,
    .scheduleCreateContractCall,
    .topicCreateWithCustomFees,
    .submitMessageWithCustomFees,
  ]

}

///*
/// Possible Token Supply Types (IWA Compatibility).
///
/// This `enum` indicates the limit of tokens that can exist during the
/// lifetime of a token definition. The "infinite" supply is only theoretically
/// infinite, as it is still limited to the magnitude of a 64-bit signed
/// integer. A "finite" supply is further limited to a value specified when
/// the token is created (or updated, if not immutable).
public enum Proto_TokenSupplyType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// An unlimited supply.<br/>
  /// This indicates that tokens of this type have an upper bound of
  /// Long.MAX_VALUE.<br/>
  /// The supply is accounted in the smallest units of the token
  /// (i.e. 10<sup>-`decimals`</sup> whole tokens)
  case infinite // = 0

  ///*
  /// A limited supply.<br/>
  /// This indicates that tokens of this type have an upper bound of
  /// `maxSupply`.<br/>
  /// The maximum supply SHALL be provided on token creation, but MAY be
  /// changed thereafter if the token has an `admin_key` set.
  case finite // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .infinite
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .infinite
    case 1: self = .finite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .infinite: return 0
    case .finite: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_TokenSupplyType] = [
    .infinite,
    .finite,
  ]

}

///*
/// Types of validation strategies for token keys.
public enum Proto_TokenKeyValidation: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// Perform all token key validations.<br/>
  /// This is the default value and behavior.
  case fullValidation // = 0

  ///*
  /// Perform no validations at all for all passed token keys.
  case noValidation // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .fullValidation
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fullValidation
    case 1: self = .noValidation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .fullValidation: return 0
    case .noValidation: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_TokenKeyValidation] = [
    .fullValidation,
    .noValidation,
  ]

}

///*
/// Possible token freeze status values.
///
/// This is returned by `TokenGetInfoQuery` or `CryptoGetInfoResponse`
/// in `TokenRelationship`.
public enum Proto_TokenFreezeStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// The token does not support freeze or cannot be frozen for the designated
  /// account.<br/>
  /// Typically this indicates that the token does not have a `freeze_key` set.
  case freezeNotApplicable // = 0

  ///*
  /// The token is currently frozen for the designated account.
  case frozen // = 1

  ///*
  /// The token is not currently frozen for the designated account.
  case unfrozen // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .freezeNotApplicable
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .freezeNotApplicable
    case 1: self = .frozen
    case 2: self = .unfrozen
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .freezeNotApplicable: return 0
    case .frozen: return 1
    case .unfrozen: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_TokenFreezeStatus] = [
    .freezeNotApplicable,
    .frozen,
    .unfrozen,
  ]

}

///*
/// Possible token "KYC" status values.
///
/// This is returned by `TokenGetInfoQuery` or `CryptoGetInfoResponse`
/// in `TokenRelationship`.
public enum Proto_TokenKycStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// The token does not support KYC or cannot grant KYC for the
  /// designated account.<br/>
  /// Typically this indicates that the token does not have a `kyc_key` set.
  case kycNotApplicable // = 0

  ///*
  /// The designated account is currently granted KYC status for the
  /// designated token.
  case granted // = 1

  ///*
  /// The designated account is not currently granted KYC status for the
  /// designated token.
  case revoked // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .kycNotApplicable
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .kycNotApplicable
    case 1: self = .granted
    case 2: self = .revoked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .kycNotApplicable: return 0
    case .granted: return 1
    case .revoked: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_TokenKycStatus] = [
    .kycNotApplicable,
    .granted,
    .revoked,
  ]

}

///*
/// Possible Pause status values.
///
/// This is returned by `TokenGetInfoQuery` in `TokenRelationship`.
public enum Proto_TokenPauseStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// The token does not support pause or cannot be paused.<br/>
  /// Typically this indicates that the token does not have a `pause_key` set.
  case pauseNotApplicable // = 0

  ///*
  /// The token is currently paused.
  case paused // = 1

  ///*
  /// The token is not currently paused.
  case unpaused // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .pauseNotApplicable
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pauseNotApplicable
    case 1: self = .paused
    case 2: self = .unpaused
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .pauseNotApplicable: return 0
    case .paused: return 1
    case .unpaused: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_TokenPauseStatus] = [
    .pauseNotApplicable,
    .paused,
    .unpaused,
  ]

}

///*
/// The transactions and queries supported by Hedera Hashgraph.
public enum Proto_HederaFunctionality: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// Unused - The first value is unused because this default value is
  /// ambiguous with an "unset" value and therefore should not be used.
  case none // = 0

  ///*
  /// Transfer tokens among accounts.
  case cryptoTransfer // = 1

  ///*
  /// Update an account.
  case cryptoUpdate // = 2

  ///*
  /// Delete an account.
  case cryptoDelete // = 3

  ///*
  /// Add a livehash to an account
  ///
  /// NOTE: This enum value was marked as deprecated in the .proto file
  case cryptoAddLiveHash // = 4

  ///*
  /// Delete a livehash from an account
  ///
  /// NOTE: This enum value was marked as deprecated in the .proto file
  case cryptoDeleteLiveHash // = 5

  ///*
  /// Execute a smart contract call.
  case contractCall // = 6

  ///*
  /// Create a smart contract.
  case contractCreate // = 7

  ///*
  /// Update a smart contract.
  case contractUpdate // = 8

  ///*
  /// Create a "file" stored in the ledger.
  case fileCreate // = 9

  ///*
  /// Append data to a "file" stored in the ledger.
  case fileAppend // = 10

  ///*
  /// Update a "file" stored in the ledger.
  case fileUpdate // = 11

  ///*
  /// Delete a "file" stored in the ledger.
  case fileDelete // = 12

  ///*
  /// Get the balance for an account.
  case cryptoGetAccountBalance // = 13

  ///*
  /// Get a full account record.
  case cryptoGetAccountRecords // = 14

  ///*
  /// Get information about a token.
  case cryptoGetInfo // = 15

  ///*
  /// Execute a local smart contract call.<br/>
  /// Used by contracts to call other contracts.
  case contractCallLocal // = 16

  ///*
  /// Get information about a smart contract.
  case contractGetInfo // = 17

  ///*
  /// Get the compiled bytecode that implements a smart contract.
  case contractGetBytecode // = 18

  ///*
  /// Get a smart contract record by reference to the solidity ID.
  case getBySolidityID // = 19

  ///*
  /// Get a smart contract by reference to the contract key.
  case getByKey // = 20

  ///*
  /// Get the live hash for an account
  ///
  /// NOTE: This enum value was marked as deprecated in the .proto file
  case cryptoGetLiveHash // = 21

  ///*
  /// Get the accounts proxy staking to a given account.
  ///
  /// NOTE: This enum value was marked as deprecated in the .proto file
  case cryptoGetStakers // = 22

  ///*
  /// Get the contents of a "file" stored in the ledger.
  case fileGetContents // = 23

  ///*
  /// Get the metadata for a "file" stored in the ledger.
  case fileGetInfo // = 24

  ///*
  /// Get transaction record(s) for a specified transaction ID.
  case transactionGetRecord // = 25

  ///*
  /// Get all transaction records for a specified contract ID in
  /// the past 24 hours.<br/>
  /// deprecated since version 0.9.0
  ///
  /// NOTE: This enum value was marked as deprecated in the .proto file
  case contractGetRecords // = 26

  ///*
  /// Create a new account
  case cryptoCreate // = 27

  ///*
  /// Delete a "system" "file" stored in the ledger.<br/>
  /// "System" files are files with special purpose and ID values within a
  /// specific range.<br/>
  /// These files require additional controls and can only be deleted when
  /// authorized by accounts with elevated privilege.
  case systemDelete // = 28

  ///*
  /// Undo the delete of a "system" "file" stored in the ledger.<br/>
  /// "System" files are files with special purpose and ID values within a
  /// specific range.<br/>
  /// These files require additional controls and can only be deleted when
  /// authorized by accounts with elevated privilege. This operation allows
  /// such files to be restored, within a reasonable timeframe, if
  /// deleted improperly.
  case systemUndelete // = 29

  ///*
  /// Delete a smart contract
  case contractDelete // = 30

  ///*
  /// Stop all processing and "freeze" the entire network.<br/>
  /// This is generally sent immediately prior to upgrading the network.<br/>
  /// After processing this transactions all nodes enter a quiescent state.
  case freeze // = 31

  ///*
  /// Create a Transaction Record.<br/>
  /// This appears to be purely internal and unused.
  case createTransactionRecord // = 32

  ///*
  /// Auto-renew an account.<br/>
  /// This is used for internal fee calculations.
  case cryptoAccountAutoRenew // = 33

  ///*
  /// Auto-renew a smart contract.<br/>
  /// This is used for internal fee calculations.
  case contractAutoRenew // = 34

  ///*
  /// Get version information for the ledger.<br/>
  /// This returns a the version of the software currently running the network
  /// for both the protocol buffers and the network services (node).
  case getVersionInfo // = 35

  ///*
  /// Get a receipt for a specified transaction ID.
  case transactionGetReceipt // = 36

  ///*
  /// Create a topic for the Hedera Consensus Service (HCS).
  case consensusCreateTopic // = 50

  ///*
  /// Update an HCS topic.
  case consensusUpdateTopic // = 51

  ///*
  /// Delete an HCS topic.
  case consensusDeleteTopic // = 52

  ///*
  /// Get metadata (information) for an HCS topic.
  case consensusGetTopicInfo // = 53

  ///*
  /// Publish a message to an HCS topic.
  case consensusSubmitMessage // = 54

  ///*
  /// Submit a transaction, bypassing intake checking.
  /// Only enabled in local-mode.
  case uncheckedSubmit // = 55

  ///*
  /// Create a token for the Hedera Token Service (HTS).
  case tokenCreate // = 56

  ///*
  /// Get metadata (information) for an HTS token.
  case tokenGetInfo // = 58

  ///*
  /// Freeze a specific account with respect to a specific HTS token.
  /// <p>
  /// Once this transaction completes that account CANNOT send or receive
  /// the specified token.
  case tokenFreezeAccount // = 59

  ///*
  /// Remove a "freeze" from an account with respect to a specific HTS token.
  case tokenUnfreezeAccount // = 60

  ///*
  /// Grant KYC status to an account for a specific HTS token.
  case tokenGrantKycToAccount // = 61

  ///*
  /// Revoke KYC status from an account for a specific HTS token.
  case tokenRevokeKycFromAccount // = 62

  ///*
  /// Delete a specific HTS token.
  case tokenDelete // = 63

  ///*
  /// Update a specific HTS token.
  case tokenUpdate // = 64

  ///*
  /// Mint HTS token amounts to the treasury account for that token.
  case tokenMint // = 65

  ///*
  /// Burn HTS token amounts from the treasury account for that token.
  case tokenBurn // = 66

  ///*
  /// Wipe all amounts for a specific HTS token from a specified account.
  case tokenAccountWipe // = 67

  ///*
  /// Associate a specific HTS token to an account.
  case tokenAssociateToAccount // = 68

  ///*
  /// Dissociate a specific HTS token from an account.
  case tokenDissociateFromAccount // = 69

  ///*
  /// Create a scheduled transaction
  case scheduleCreate // = 70

  ///*
  /// Delete a scheduled transaction
  case scheduleDelete // = 71

  ///*
  /// Sign a scheduled transaction
  case scheduleSign // = 72

  ///*
  /// Get metadata (information) for a scheduled transaction
  case scheduleGetInfo // = 73

  ///*
  /// Get NFT metadata (information) for a range of NFTs associated to a
  /// specific non-fungible/unique HTS token and owned by a specific account.
  ///
  /// NOTE: This enum value was marked as deprecated in the .proto file
  case tokenGetAccountNftInfos // = 74

  ///*
  /// Get metadata (information) for a specific NFT identified by token and
  /// serial number.
  ///
  /// NOTE: This enum value was marked as deprecated in the .proto file
  case tokenGetNftInfo // = 75

  ///*
  /// Get NFT metadata (information) for a range of NFTs associated to a
  /// specific non-fungible/unique HTS token.
  case tokenGetNftInfos // = 76

  ///*
  /// Update a token's custom fee schedule.
  /// <p>
  /// If a transaction of this type is not signed by the token
  /// `fee_schedule_key` it SHALL fail with INVALID_SIGNATURE, or
  /// TOKEN_HAS_NO_FEE_SCHEDULE_KEY if there is no `fee_schedule_key` set.
  case tokenFeeScheduleUpdate // = 77

  ///*
  /// Get execution time(s) for one or more "recent" TransactionIDs.
  ///
  /// NOTE: This enum value was marked as deprecated in the .proto file
  case networkGetExecutionTime // = 78

  ///*
  /// Pause a specific HTS token
  case tokenPause // = 79

  ///*
  /// Unpause a paused HTS token.
  case tokenUnpause // = 80

  ///*
  /// Approve an allowance for a spender relative to the owner account, which
  /// MUST sign the transaction.
  case cryptoApproveAllowance // = 81

  ///*
  /// Delete (unapprove) an allowance previously approved
  /// for the owner account.
  case cryptoDeleteAllowance // = 82

  ///*
  /// Get all the information about an account, including balance
  /// and allowances.<br/>
  /// This does not get a list of account records.
  case getAccountDetails // = 83

  ///*
  /// Perform an Ethereum (EVM) transaction.<br/>
  /// CallData may be inline if small, or in a "file" if large.
  case ethereumTransaction // = 84

  ///*
  /// Used to indicate when the network has updated the staking information
  /// at the end of a staking period and to indicate a new staking period
  /// has started.
  case nodeStakeUpdate // = 85

  ///*
  /// Generate and return a pseudorandom number based on network state.
  case utilPrng // = 86

  ///*
  /// Get a record for a "recent" transaction.
  ///
  /// NOTE: This enum value was marked as deprecated in the .proto file
  case transactionGetFastRecord // = 87

  ///*
  /// Update the metadata of one or more NFT's of a specific token type.
  case tokenUpdateNfts // = 88

  ///*
  /// Create a node
  case nodeCreate // = 89

  ///*
  /// Update a node
  case nodeUpdate // = 90

  ///*
  /// Delete a node
  case nodeDelete // = 91

  ///*
  /// Transfer one or more token balances held by the requesting account
  /// to the treasury for each token type.
  case tokenReject // = 92

  ///*
  /// Airdrop one or more tokens to one or more accounts.
  case tokenAirdrop // = 93

  ///*
  /// Remove one or more pending airdrops from state on behalf of
  /// the sender(s) for each airdrop.
  case tokenCancelAirdrop // = 94

  ///*
  /// Claim one or more pending airdrops
  case tokenClaimAirdrop // = 95

  ///*
  /// Submit a signature of a state root hash gossiped to other nodes
  case stateSignatureTransaction // = 100

  ///*
  /// Publish a hinTS key to the network.
  case hintsKeyPublication // = 101

  ///*
  /// Vote for a particular preprocessing output of a hinTS construction.
  case hintsPreprocessingVote // = 102

  ///*
  /// Sign a partial signature for the active hinTS construction.
  case hintsPartialSignature // = 103

  ///*
  /// Sign a particular history assembly.
  case historyAssemblySignature // = 104

  ///*
  /// Publish a roster history proof key to the network.
  case historyProofKeyPublication // = 105

  ///*
  /// Vote for a particular history proof.
  case historyProofVote // = 106

  ///*
  /// Publish a random CRS to the network.
  case crsPublication // = 107

  ///*
  /// Submit a batch of transactions to run atomically
  case atomicBatch // = 108

  ///*
  /// Update one or more storage slots in an lambda EVM hook.
  case lambdaSstore // = 109

  ///*
  /// (Internal-only) Dispatch a hook action.
  case hookDispatch // = 110
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .cryptoTransfer
    case 2: self = .cryptoUpdate
    case 3: self = .cryptoDelete
    case 4: self = .cryptoAddLiveHash
    case 5: self = .cryptoDeleteLiveHash
    case 6: self = .contractCall
    case 7: self = .contractCreate
    case 8: self = .contractUpdate
    case 9: self = .fileCreate
    case 10: self = .fileAppend
    case 11: self = .fileUpdate
    case 12: self = .fileDelete
    case 13: self = .cryptoGetAccountBalance
    case 14: self = .cryptoGetAccountRecords
    case 15: self = .cryptoGetInfo
    case 16: self = .contractCallLocal
    case 17: self = .contractGetInfo
    case 18: self = .contractGetBytecode
    case 19: self = .getBySolidityID
    case 20: self = .getByKey
    case 21: self = .cryptoGetLiveHash
    case 22: self = .cryptoGetStakers
    case 23: self = .fileGetContents
    case 24: self = .fileGetInfo
    case 25: self = .transactionGetRecord
    case 26: self = .contractGetRecords
    case 27: self = .cryptoCreate
    case 28: self = .systemDelete
    case 29: self = .systemUndelete
    case 30: self = .contractDelete
    case 31: self = .freeze
    case 32: self = .createTransactionRecord
    case 33: self = .cryptoAccountAutoRenew
    case 34: self = .contractAutoRenew
    case 35: self = .getVersionInfo
    case 36: self = .transactionGetReceipt
    case 50: self = .consensusCreateTopic
    case 51: self = .consensusUpdateTopic
    case 52: self = .consensusDeleteTopic
    case 53: self = .consensusGetTopicInfo
    case 54: self = .consensusSubmitMessage
    case 55: self = .uncheckedSubmit
    case 56: self = .tokenCreate
    case 58: self = .tokenGetInfo
    case 59: self = .tokenFreezeAccount
    case 60: self = .tokenUnfreezeAccount
    case 61: self = .tokenGrantKycToAccount
    case 62: self = .tokenRevokeKycFromAccount
    case 63: self = .tokenDelete
    case 64: self = .tokenUpdate
    case 65: self = .tokenMint
    case 66: self = .tokenBurn
    case 67: self = .tokenAccountWipe
    case 68: self = .tokenAssociateToAccount
    case 69: self = .tokenDissociateFromAccount
    case 70: self = .scheduleCreate
    case 71: self = .scheduleDelete
    case 72: self = .scheduleSign
    case 73: self = .scheduleGetInfo
    case 74: self = .tokenGetAccountNftInfos
    case 75: self = .tokenGetNftInfo
    case 76: self = .tokenGetNftInfos
    case 77: self = .tokenFeeScheduleUpdate
    case 78: self = .networkGetExecutionTime
    case 79: self = .tokenPause
    case 80: self = .tokenUnpause
    case 81: self = .cryptoApproveAllowance
    case 82: self = .cryptoDeleteAllowance
    case 83: self = .getAccountDetails
    case 84: self = .ethereumTransaction
    case 85: self = .nodeStakeUpdate
    case 86: self = .utilPrng
    case 87: self = .transactionGetFastRecord
    case 88: self = .tokenUpdateNfts
    case 89: self = .nodeCreate
    case 90: self = .nodeUpdate
    case 91: self = .nodeDelete
    case 92: self = .tokenReject
    case 93: self = .tokenAirdrop
    case 94: self = .tokenCancelAirdrop
    case 95: self = .tokenClaimAirdrop
    case 100: self = .stateSignatureTransaction
    case 101: self = .hintsKeyPublication
    case 102: self = .hintsPreprocessingVote
    case 103: self = .hintsPartialSignature
    case 104: self = .historyAssemblySignature
    case 105: self = .historyProofKeyPublication
    case 106: self = .historyProofVote
    case 107: self = .crsPublication
    case 108: self = .atomicBatch
    case 109: self = .lambdaSstore
    case 110: self = .hookDispatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .cryptoTransfer: return 1
    case .cryptoUpdate: return 2
    case .cryptoDelete: return 3
    case .cryptoAddLiveHash: return 4
    case .cryptoDeleteLiveHash: return 5
    case .contractCall: return 6
    case .contractCreate: return 7
    case .contractUpdate: return 8
    case .fileCreate: return 9
    case .fileAppend: return 10
    case .fileUpdate: return 11
    case .fileDelete: return 12
    case .cryptoGetAccountBalance: return 13
    case .cryptoGetAccountRecords: return 14
    case .cryptoGetInfo: return 15
    case .contractCallLocal: return 16
    case .contractGetInfo: return 17
    case .contractGetBytecode: return 18
    case .getBySolidityID: return 19
    case .getByKey: return 20
    case .cryptoGetLiveHash: return 21
    case .cryptoGetStakers: return 22
    case .fileGetContents: return 23
    case .fileGetInfo: return 24
    case .transactionGetRecord: return 25
    case .contractGetRecords: return 26
    case .cryptoCreate: return 27
    case .systemDelete: return 28
    case .systemUndelete: return 29
    case .contractDelete: return 30
    case .freeze: return 31
    case .createTransactionRecord: return 32
    case .cryptoAccountAutoRenew: return 33
    case .contractAutoRenew: return 34
    case .getVersionInfo: return 35
    case .transactionGetReceipt: return 36
    case .consensusCreateTopic: return 50
    case .consensusUpdateTopic: return 51
    case .consensusDeleteTopic: return 52
    case .consensusGetTopicInfo: return 53
    case .consensusSubmitMessage: return 54
    case .uncheckedSubmit: return 55
    case .tokenCreate: return 56
    case .tokenGetInfo: return 58
    case .tokenFreezeAccount: return 59
    case .tokenUnfreezeAccount: return 60
    case .tokenGrantKycToAccount: return 61
    case .tokenRevokeKycFromAccount: return 62
    case .tokenDelete: return 63
    case .tokenUpdate: return 64
    case .tokenMint: return 65
    case .tokenBurn: return 66
    case .tokenAccountWipe: return 67
    case .tokenAssociateToAccount: return 68
    case .tokenDissociateFromAccount: return 69
    case .scheduleCreate: return 70
    case .scheduleDelete: return 71
    case .scheduleSign: return 72
    case .scheduleGetInfo: return 73
    case .tokenGetAccountNftInfos: return 74
    case .tokenGetNftInfo: return 75
    case .tokenGetNftInfos: return 76
    case .tokenFeeScheduleUpdate: return 77
    case .networkGetExecutionTime: return 78
    case .tokenPause: return 79
    case .tokenUnpause: return 80
    case .cryptoApproveAllowance: return 81
    case .cryptoDeleteAllowance: return 82
    case .getAccountDetails: return 83
    case .ethereumTransaction: return 84
    case .nodeStakeUpdate: return 85
    case .utilPrng: return 86
    case .transactionGetFastRecord: return 87
    case .tokenUpdateNfts: return 88
    case .nodeCreate: return 89
    case .nodeUpdate: return 90
    case .nodeDelete: return 91
    case .tokenReject: return 92
    case .tokenAirdrop: return 93
    case .tokenCancelAirdrop: return 94
    case .tokenClaimAirdrop: return 95
    case .stateSignatureTransaction: return 100
    case .hintsKeyPublication: return 101
    case .hintsPreprocessingVote: return 102
    case .hintsPartialSignature: return 103
    case .historyAssemblySignature: return 104
    case .historyProofKeyPublication: return 105
    case .historyProofVote: return 106
    case .crsPublication: return 107
    case .atomicBatch: return 108
    case .lambdaSstore: return 109
    case .hookDispatch: return 110
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_HederaFunctionality] = [
    .none,
    .cryptoTransfer,
    .cryptoUpdate,
    .cryptoDelete,
    .cryptoAddLiveHash,
    .cryptoDeleteLiveHash,
    .contractCall,
    .contractCreate,
    .contractUpdate,
    .fileCreate,
    .fileAppend,
    .fileUpdate,
    .fileDelete,
    .cryptoGetAccountBalance,
    .cryptoGetAccountRecords,
    .cryptoGetInfo,
    .contractCallLocal,
    .contractGetInfo,
    .contractGetBytecode,
    .getBySolidityID,
    .getByKey,
    .cryptoGetLiveHash,
    .cryptoGetStakers,
    .fileGetContents,
    .fileGetInfo,
    .transactionGetRecord,
    .contractGetRecords,
    .cryptoCreate,
    .systemDelete,
    .systemUndelete,
    .contractDelete,
    .freeze,
    .createTransactionRecord,
    .cryptoAccountAutoRenew,
    .contractAutoRenew,
    .getVersionInfo,
    .transactionGetReceipt,
    .consensusCreateTopic,
    .consensusUpdateTopic,
    .consensusDeleteTopic,
    .consensusGetTopicInfo,
    .consensusSubmitMessage,
    .uncheckedSubmit,
    .tokenCreate,
    .tokenGetInfo,
    .tokenFreezeAccount,
    .tokenUnfreezeAccount,
    .tokenGrantKycToAccount,
    .tokenRevokeKycFromAccount,
    .tokenDelete,
    .tokenUpdate,
    .tokenMint,
    .tokenBurn,
    .tokenAccountWipe,
    .tokenAssociateToAccount,
    .tokenDissociateFromAccount,
    .scheduleCreate,
    .scheduleDelete,
    .scheduleSign,
    .scheduleGetInfo,
    .tokenGetAccountNftInfos,
    .tokenGetNftInfo,
    .tokenGetNftInfos,
    .tokenFeeScheduleUpdate,
    .networkGetExecutionTime,
    .tokenPause,
    .tokenUnpause,
    .cryptoApproveAllowance,
    .cryptoDeleteAllowance,
    .getAccountDetails,
    .ethereumTransaction,
    .nodeStakeUpdate,
    .utilPrng,
    .transactionGetFastRecord,
    .tokenUpdateNfts,
    .nodeCreate,
    .nodeUpdate,
    .nodeDelete,
    .tokenReject,
    .tokenAirdrop,
    .tokenCancelAirdrop,
    .tokenClaimAirdrop,
    .stateSignatureTransaction,
    .hintsKeyPublication,
    .hintsPreprocessingVote,
    .hintsPartialSignature,
    .historyAssemblySignature,
    .historyProofKeyPublication,
    .historyProofVote,
    .crsPublication,
    .atomicBatch,
    .lambdaSstore,
    .hookDispatch,
  ]

}

///*
/// A shard identifier.<br/>
/// A shard is a partition of nodes running the network that processes
/// transactions separately from other shards. Each shard is effectively an
/// independent instance of the overall network that shares the same virtual
/// distributed ledger, and may gossip cross-shard transactions with other
/// shards to maintain overall correct processing of the ledger.
public struct Proto_ShardID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A whole number shard identifier.
  public var shardNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A realm identifier.<br/>
/// Within a given shard, every realm has a unique numeric identifier.
/// Each account, file, and contract instance belongs to exactly one realm.
public struct Proto_RealmID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A whole number shard identifier.
  public var shardNum: Int64 = 0

  ///*
  /// A whole number realm identifier.
  public var realmNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Unique identifier for a token.<br/>
/// As with all entity identifiers within the network, a token identifier
/// consists of a combination of shard number, realm number, and entity number.
/// Each of these numbers is unique within its scope (shard > realm > entity).
public struct Proto_TokenID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A whole number shard identifier.
  public var shardNum: Int64 = 0

  ///*
  /// A whole number realm identifier.
  public var realmNum: Int64 = 0

  ///*
  /// A whole number token identifier.
  public var tokenNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A unique identifier for an Hedera account.
///
/// An account identifier is of the form `shard.realm.[number|alias]`.<br/>
/// The identifier MAY use the alias form when transferring HBAR to a public key
/// before the account for that key is created, when only the alias value is
/// known, or in some smart contracts that use the EVM address style alias to
/// refer to Accounts.<br/>
/// When the account entry is completed, the alias SHALL be stored separately in
/// the Account record, and the identifier in the Account SHALL use the
/// `accountNum` form.
///
/// ---
/// ### Additional Notes
///
/// #### Alias
/// There is considerable complexity with `alias` (aka `evm_address`) for
/// Accounts. Much of this comes from the existence of a "hidden" alias for
/// almost all accounts, and the reuse of the alias field for both EVM reference
/// and "automatic" account creation.<br/>
/// For the purposes of this specification, we will use the following terms for
/// clarity.
///   - `key_alias`<br/>
///      The account public key as a protobuf serialized message and used for
///      auto-creation and subsequent lookup. This is only valid if the account
///      key is a single `primitive` key, either Ed25519 or ECDSA_SECP256K1.
///   - `evm_address`<br/>
///     Exists for every account and is one of
///      - `contract_address`<br/>
///        The 20 byte EVM address prescribed by `CREATE` or `CREATE2`
///      - `evm_key_address`<br/>
///        An arbitrary 20 byte EVM address that, for a usable externally owned
///        account (EOA) SHALL be the rightmost 20 bytes of the Keccak-256 hash
///        of a ECDSA_SECP256K1 key.<br/>
///        Such accounts may be created in one of three ways:
///        - Sending hbar or fungible tokens to an unused
///          ECDSA_SECP256K1 key alias.
///        - Sending hbar or fungible tokens to an unassigned 20-byte
///          EVM address.
///        - Submitting a `CryptoCreate` signed with the corresponding
///          private key.
///      - `long_zero`<br/>
///        A synthetic 20 byte address inferred for "normally" created accounts.
///        It is constructed from the "standard" AccountID as follows.
///         1. 4 byte big-endian shard number
///         1. 8 byte big-endian realm number
///         1. 8 byte big-endian entity number<br/>
///
/// The `alias` field in the `Account` message SHALL contain one of four values
/// for any given account.
///   - The `key_alias`, if the account was created by transferring HBAR to the
///     `key_alias` public key value.
///   - The `evm_key_address` if the account was created from an EVM public key
///   - The `contract_address` if the account belongs to an EVM contract
///   - Not-Set/null/Bytes.EMPTY (collectively `null`) if the account was
///     created normally
///
/// If the `alias` field of an `Account` is any form of `null`, then the account
/// MAY be referred to by `alias` in an `AccountID` by using the `long_zero`
/// address for the account.<br/>
/// This "hidden default" alias SHALL NOT be stored, but is synthesized by the
/// node software as needed, and may be synthesized by an EVM contract or client
/// software as well.
///
/// ---
///
/// #### Alias forms
/// An `AccountID` in a transaction MAY reference an `Account` with
/// `shard.realm.alias`.<br/>
/// If the account `alias` field is set for an Account, that value SHALL be the
/// account alias.<br/>
/// If the account `alias` field is not set for an Account, the `long_zero` alias
/// SHALL be the account alias.
public struct Proto_AccountID: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A whole number shard identifier.
  public var shardNum: Int64 = 0

  ///*
  /// A whole number realm identifier.
  public var realmNum: Int64 = 0

  public var account: Proto_AccountID.OneOf_Account? = nil

  ///*
  /// A whole number account number, unique within its realm and shard.
  /// <p>
  /// For any AccountID fields in the query response, transaction records,
  /// transaction receipts, or block stream `accountNum` MUST be used.
  public var accountNum: Int64 {
    get {
      if case .accountNum(let v)? = account {return v}
      return 0
    }
    set {account = .accountNum(newValue)}
  }

  ///*
  /// An alias value.<br/>
  /// Alias is a value used in some contexts to refer to an account when
  /// account number is not available, and may be an alias public key, or
  /// an EVM address.
  public var alias: Data {
    get {
      if case .alias(let v)? = account {return v}
      return Data()
    }
    set {account = .alias(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Account: Equatable, @unchecked Sendable {
    ///*
    /// A whole number account number, unique within its realm and shard.
    /// <p>
    /// For any AccountID fields in the query response, transaction records,
    /// transaction receipts, or block stream `accountNum` MUST be used.
    case accountNum(Int64)
    ///*
    /// An alias value.<br/>
    /// Alias is a value used in some contexts to refer to an account when
    /// account number is not available, and may be an alias public key, or
    /// an EVM address.
    case alias(Data)

  }

  public init() {}
}

///*
/// An identifier for a unique token (or "NFT"), used by both contract
/// and token services.
public struct Proto_NftID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A token identifier.<br/>
  /// This token represents the collection containing this NFT.
  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  ///*
  /// A unique serial number.<br/>
  /// This serial number is unique within its token type.
  public var serialNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
}

///*
/// An identifier for a File within the network.
public struct Proto_FileID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A whole number shard identifier.
  public var shardNum: Int64 = 0

  ///*
  /// A whole number realm identifier.
  public var realmNum: Int64 = 0

  ///*
  /// A whole number file identifier, unique within its realm and shard.
  public var fileNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// An identifier for a smart contract within the network.
public struct Proto_ContractID: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A whole number shard identifier.
  public var shardNum: Int64 = 0

  ///*
  /// A whole number realm identifier.
  public var realmNum: Int64 = 0

  public var contract: Proto_ContractID.OneOf_Contract? = nil

  ///*
  /// A whole number contract identifier, unique within its realm and shard.
  public var contractNum: Int64 {
    get {
      if case .contractNum(let v)? = contract {return v}
      return 0
    }
    set {contract = .contractNum(newValue)}
  }

  ///*
  /// A 20-byte EVM address of the contract to call.
  /// <p>
  /// A contract created via a HAPI `ContractCreate` call SHALL have
  /// an EVM address determined by its `shard.realm.num` identifier.<br/>
  /// This address is as follows
  /// <ol>
  ///     <li>4 byte big-endian shard number</li>
  ///     <li>8 byte big-endian realm number</li>
  ///     <li>8 byte big-endian contract number</li>
  /// </ol>
  /// This address is not stored in state, but is computed when needed.
  /// <p>
  /// Contracts created by any other means, including a HAPI
  /// `EthereumTransaction` whose `to` address is the zero address,
  /// SHALL have the EVM address prescribed by the `CREATE` or
  /// `CREATE2` opcode, as applicable.
  public var evmAddress: Data {
    get {
      if case .evmAddress(let v)? = contract {return v}
      return Data()
    }
    set {contract = .evmAddress(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Contract: Equatable, @unchecked Sendable {
    ///*
    /// A whole number contract identifier, unique within its realm and shard.
    case contractNum(Int64)
    ///*
    /// A 20-byte EVM address of the contract to call.
    /// <p>
    /// A contract created via a HAPI `ContractCreate` call SHALL have
    /// an EVM address determined by its `shard.realm.num` identifier.<br/>
    /// This address is as follows
    /// <ol>
    ///     <li>4 byte big-endian shard number</li>
    ///     <li>8 byte big-endian realm number</li>
    ///     <li>8 byte big-endian contract number</li>
    /// </ol>
    /// This address is not stored in state, but is computed when needed.
    /// <p>
    /// Contracts created by any other means, including a HAPI
    /// `EthereumTransaction` whose `to` address is the zero address,
    /// SHALL have the EVM address prescribed by the `CREATE` or
    /// `CREATE2` opcode, as applicable.
    case evmAddress(Data)

  }

  public init() {}
}

///*
/// An unique identifier for a topic.<br/>
/// Topics are part of the consensus service, messages are published to a topic.
public struct Proto_TopicID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A whole number shard identifier.
  public var shardNum: Int64 = 0

  ///*
  /// A whole number realm identifier.
  public var realmNum: Int64 = 0

  ///*
  /// A whole number topic identifier, unique within its realm and shard.
  public var topicNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// An unique identifier for a Schedule
public struct Proto_ScheduleID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A whole number shard
  public var shardNum: Int64 = 0

  ///*
  /// A whole number realm
  public var realmNum: Int64 = 0

  ///*
  /// A whole number schedule, unique within its realm and shard
  public var scheduleNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A transaction identifier.<br/>
/// This is used for retrieving receipts and records for a transaction
/// and internally by the network for detecting when duplicate transactions are
/// submitted.
///
/// A transaction may be processed more reliably by submitting it to
/// several nodes, each with a different node account, but all with the same
/// TransactionID. Then, the transaction will take effect when the first of all
/// those nodes submits the transaction and it reaches consensus. The other
/// transactions SHALL NOT be executed (and SHALL result in a
/// `DUPLICATE_TRANSACTION` response).<br/>
/// Multiple submission increase reliability on the assumption that an error in,
/// for example, network connectivity will not affect all nodes equally. Latency
/// might be slightly lower, if one node is handling intake significantly slower
/// than others, for example. The base transaction fee is required for each
/// submission, however, so the total fees charged are significantly higher when
/// using this approach.
///
/// ### Requirements
/// Each transaction identifier MUST be unique.<br/>
/// Multiple transactions MAY be submitted with the same transaction
/// identifier, but all except the first SHALL be rejected as duplicate
/// transactions.<br/>
/// An identifier MUST specify a `payer` account to be charged all fees
/// associated with the transaction.<br/>
/// The `payer` account MUST exist and MUST have sufficient HBAR to pay all
/// transaction fees.<br/>
/// An identifier MUST specify a "valid start time".<br/>
/// The "valid start time" MUST be strictly _earlier_ than the current
/// network consensus time when submitted.<br/>
/// The "valid start time" MUST NOT be more than `transaction.maxValidDuration`
/// seconds before the current network consensus time when submitted.<br/>
/// A client-submitted transaction MUST NOT set the `scheduled` flag.
///
/// ### Additional Notes
///
/// Additional items applicable to Scheduled Transactions:
///
///  - The ID of a Scheduled Transaction, once executed, SHALL inherit both
///    `transactionValidStart` and `accountID` from the `ScheduleCreate`
///    transaction that created the schedule.
///  - The `scheduled` property SHALL be set for Scheduled Transactions.
public struct Proto_TransactionID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A timestamp for the transaction start time.<br/>
  /// This is the earliest expected start time for this transaction.
  /// <p>
  /// This value MUST be strictly less than `consensusTimestamp` when the
  /// transaction is submitted.
  public var transactionValidStart: Proto_Timestamp {
    get {return _transactionValidStart ?? Proto_Timestamp()}
    set {_transactionValidStart = newValue}
  }
  /// Returns true if `transactionValidStart` has been explicitly set.
  public var hasTransactionValidStart: Bool {return self._transactionValidStart != nil}
  /// Clears the value of `transactionValidStart`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionValidStart() {self._transactionValidStart = nil}

  ///*
  /// An Account identifier.
  /// <p>
  /// The identified account SHALL pay transaction fees for this transaction.
  public var accountID: Proto_AccountID {
    get {return _accountID ?? Proto_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  ///*
  /// A scheduled transaction flag.<br/>
  /// If set, this transaction represents the execution of a Schedule after
  /// all necessary signatures are gathered.
  /// <p>
  /// This flag MUST NOT be set in a user-submitted transaction.
  public var scheduled: Bool = false

  ///*
  /// An identifier for an internal transaction.<br/>
  /// An internal transaction is one that was spawned as part of handling a
  /// user transaction. These internal transactions share the
  /// transactionValidStart and accountID of the user transaction, so a nonce
  /// is necessary to give them a unique TransactionID.
  /// <p>
  /// An example is when a "parent" ContractCreate or ContractCall transaction
  /// calls one or more HTS precompiled contracts; each of the "child"
  /// transactions spawned for a precompile has a transaction id with a
  /// different nonce.
  /// <p>
  /// This value MUST be unset for user-submitted transactions.
  public var nonce: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transactionValidStart: Proto_Timestamp? = nil
  fileprivate var _accountID: Proto_AccountID? = nil
}

///*
/// Once a hook is created, its full id.
/// <p>
/// A composite of its creating entity's id and an arbitrary 64-bit hook id
/// (which need not be sequential).
public struct Proto_HookId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The hook's creating entity id.
  public var entityID: Proto_HookEntityId {
    get {return _entityID ?? Proto_HookEntityId()}
    set {_entityID = newValue}
  }
  /// Returns true if `entityID` has been explicitly set.
  public var hasEntityID: Bool {return self._entityID != nil}
  /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
  public mutating func clearEntityID() {self._entityID = nil}

  ///*
  /// An arbitrary 64-bit identifier.
  public var hookID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entityID: Proto_HookEntityId? = nil
}

///*
/// The id of an entity using a hook.
public struct Proto_HookEntityId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entityID: Proto_HookEntityId.OneOf_EntityID? = nil

  ///*
  /// An account using a hook.
  public var accountID: Proto_AccountID {
    get {
      if case .accountID(let v)? = entityID {return v}
      return Proto_AccountID()
    }
    set {entityID = .accountID(newValue)}
  }

  ///*
  /// A contract using a hook.
  public var contractID: Proto_ContractID {
    get {
      if case .contractID(let v)? = entityID {return v}
      return Proto_ContractID()
    }
    set {entityID = .contractID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_EntityID: Equatable, Sendable {
    ///*
    /// An account using a hook.
    case accountID(Proto_AccountID)
    ///*
    /// A contract using a hook.
    case contractID(Proto_ContractID)

  }

  public init() {}
}

///*
/// Specifies a call to a hook from within a transaction.
/// <p>
/// Often the hook's entity is implied by the nature of the call site. For example, when using an account allowance hook
/// inside a crypto transfer, the hook's entity is necessarily the account whose authorization is required.
/// <p>
/// For future extension points where the hook owner is not forced by the context, we include the option to fully
/// specify the hook id for the call.
public struct Proto_HookCall: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Proto_HookCall.OneOf_ID? = nil

  ///*
  /// The full id of the hook to call, when the owning entity is not forced by the call site.
  public var fullHookID: Proto_HookId {
    get {
      if case .fullHookID(let v)? = id {return v}
      return Proto_HookId()
    }
    set {id = .fullHookID(newValue)}
  }

  ///*
  /// The numeric id of the hook to call, when the owning entity is forced by the call site.
  public var hookID: Int64 {
    get {
      if case .hookID(let v)? = id {return v}
      return 0
    }
    set {id = .hookID(newValue)}
  }

  ///*
  /// Specifies details of the call.
  public var callSpec: Proto_HookCall.OneOf_CallSpec? = nil

  ///*
  /// Specification of how to call an EVM hook.
  public var evmHookCall: Proto_EvmHookCall {
    get {
      if case .evmHookCall(let v)? = callSpec {return v}
      return Proto_EvmHookCall()
    }
    set {callSpec = .evmHookCall(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ID: Equatable, Sendable {
    ///*
    /// The full id of the hook to call, when the owning entity is not forced by the call site.
    case fullHookID(Proto_HookId)
    ///*
    /// The numeric id of the hook to call, when the owning entity is forced by the call site.
    case hookID(Int64)

  }

  ///*
  /// Specifies details of the call.
  public enum OneOf_CallSpec: Equatable, Sendable {
    ///*
    /// Specification of how to call an EVM hook.
    case evmHookCall(Proto_EvmHookCall)

  }

  public init() {}
}

///*
/// Specifies details of a call to an EVM hook.
public struct Proto_EvmHookCall: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Call data to pass to the hook via the IHieroHook.HookContext#data field.
  public var data: Data = Data()

  ///*
  /// The gas limit to use.
  public var gasLimit: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// An account, and the amount that it sends or receives during a token transfer.
///
/// This message is only relevant to fungible/common token transfers.
/// Non-fungible/unique (NFT) token transfers MUST use the NftTransfer message.
public struct Proto_AccountAmount: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// An account identifier that will send or receive token(s).
  public var accountID: Proto_AccountID {
    get {return _accountID ?? Proto_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  ///*
  /// An amount to send (negative) or receive (positive).
  /// <p>
  /// This amount MUST be denominated in the smallest unit of the relevant
  /// token.<br/>
  /// For HBAR this SHALL be tinybar (10<sup>-8</sup> HBAR).<br/>
  /// For other fungible/common tokens this SHALL depend on the value of
  /// `decimals` for that token.
  public var amount: Int64 = 0

  ///*
  /// An approved allowance flag.<br/>
  /// If true then the transfer is expected to be an approved allowance.
  /// <p>
  /// If set, `accountID` SHALL be the owner that previously approved
  /// the allowance.<br/>
  /// The default value SHALL be false (unset).
  public var isApproval: Bool = false

  ///*
  /// If set, a call to a hook of type `ACCOUNT_ALLOWANCE_HOOK` on scoped
  /// account; the hook's invoked methods must not revert and must return
  /// true for the containing CryptoTransfer to succeed.
  /// <p>
  /// Cannot be set if `is_approval` is true.
  public var hookCall: Proto_AccountAmount.OneOf_HookCall? = nil

  ///*
  /// A single call made before attempting the CryptoTransfer, to a
  /// method with logical signature allow(HookContext, ProposedTransfers)
  public var preTxAllowanceHook: Proto_HookCall {
    get {
      if case .preTxAllowanceHook(let v)? = hookCall {return v}
      return Proto_HookCall()
    }
    set {hookCall = .preTxAllowanceHook(newValue)}
  }

  ///*
  /// Two calls, the first call before attempting the CryptoTransfer, to a
  /// method with logical signature allowPre(HookContext, ProposedTransfers);
  /// and the second call after attempting the CryptoTransfer, to a method
  /// with logical signature allowPost(HookContext, ProposedTransfers).
  public var prePostTxAllowanceHook: Proto_HookCall {
    get {
      if case .prePostTxAllowanceHook(let v)? = hookCall {return v}
      return Proto_HookCall()
    }
    set {hookCall = .prePostTxAllowanceHook(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// If set, a call to a hook of type `ACCOUNT_ALLOWANCE_HOOK` on scoped
  /// account; the hook's invoked methods must not revert and must return
  /// true for the containing CryptoTransfer to succeed.
  /// <p>
  /// Cannot be set if `is_approval` is true.
  public enum OneOf_HookCall: Equatable, Sendable {
    ///*
    /// A single call made before attempting the CryptoTransfer, to a
    /// method with logical signature allow(HookContext, ProposedTransfers)
    case preTxAllowanceHook(Proto_HookCall)
    ///*
    /// Two calls, the first call before attempting the CryptoTransfer, to a
    /// method with logical signature allowPre(HookContext, ProposedTransfers);
    /// and the second call after attempting the CryptoTransfer, to a method
    /// with logical signature allowPost(HookContext, ProposedTransfers).
    case prePostTxAllowanceHook(Proto_HookCall)

  }

  public init() {}

  fileprivate var _accountID: Proto_AccountID? = nil
}

///*
/// A list of accounts and amounts to transfer.
///
/// Each `AccountAmount` SHALL specify the account and the amount to
/// send(negative) or receive(positive).<br/>
/// Each `TransferList` SHALL be contained in another message that contains
/// other details required to complete a transfer. This is typically a
/// `CryptoTransferTransactionBody` or `TransactionRecord`.<br/>
/// The `TransferList` SHALL only be used for HBAR transfers. Other token types
/// MUST use the `TokenTransferList` message.
public struct Proto_TransferList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A list of AccountAmount pairs.<br/>
  /// Each entry in this list is an account and an amount to transfer
  /// into it (positive) or out of it (negative)
  public var accountAmounts: [Proto_AccountAmount] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A NFT transfer.<br/>
/// This refers to a sender account, a receiver account, and the serial number
/// of an NFT to transfer from sender to receiver.
///
/// Each `NftTransfer` SHALL be contained in another message (typically
/// `TokenTransferList`) that details which `Token` type applies to this NFT
/// transfer.
public struct Proto_NftTransfer: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// An Account identifier for the sender.
  public var senderAccountID: Proto_AccountID {
    get {return _storage._senderAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._senderAccountID = newValue}
  }
  /// Returns true if `senderAccountID` has been explicitly set.
  public var hasSenderAccountID: Bool {return _storage._senderAccountID != nil}
  /// Clears the value of `senderAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearSenderAccountID() {_uniqueStorage()._senderAccountID = nil}

  ///*
  /// An Account identifier for the receiver.
  public var receiverAccountID: Proto_AccountID {
    get {return _storage._receiverAccountID ?? Proto_AccountID()}
    set {_uniqueStorage()._receiverAccountID = newValue}
  }
  /// Returns true if `receiverAccountID` has been explicitly set.
  public var hasReceiverAccountID: Bool {return _storage._receiverAccountID != nil}
  /// Clears the value of `receiverAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearReceiverAccountID() {_uniqueStorage()._receiverAccountID = nil}

  ///*
  /// A serial number for the NFT to transfer.
  public var serialNumber: Int64 {
    get {return _storage._serialNumber}
    set {_uniqueStorage()._serialNumber = newValue}
  }

  ///*
  /// An approved allowance flag.<br/>
  /// If true then the transfer is expected to be an approved allowance.
  /// <p>
  /// If set, `senderAccountID` SHALL be the owner that previously approved
  /// the allowance.<br/>
  /// If set, the `senderAccountID` MUST be the "payer" account for
  /// the transaction <br/>
  /// The default value SHALL be false (unset).
  public var isApproval: Bool {
    get {return _storage._isApproval}
    set {_uniqueStorage()._isApproval = newValue}
  }

  ///*
  /// If set, a call to a hook of type `ACCOUNT_ALLOWANCE_HOOK` installed on
  /// senderAccountID that must succeed for the transaction to occur.
  /// <p>
  /// Cannot be set if `is_approval` is true.
  public var senderAllowanceHookCall: OneOf_SenderAllowanceHookCall? {
    get {return _storage._senderAllowanceHookCall}
    set {_uniqueStorage()._senderAllowanceHookCall = newValue}
  }

  ///*
  /// A single call made before attempting the CryptoTransfer, to a
  /// method with logical signature allow(HookContext, ProposedTransfers)
  public var preTxSenderAllowanceHook: Proto_HookCall {
    get {
      if case .preTxSenderAllowanceHook(let v)? = _storage._senderAllowanceHookCall {return v}
      return Proto_HookCall()
    }
    set {_uniqueStorage()._senderAllowanceHookCall = .preTxSenderAllowanceHook(newValue)}
  }

  ///*
  /// Two calls, the first call before attempting the CryptoTransfer, to a
  /// method with logical signature allowPre(HookContext, ProposedTransfers);
  /// and the second call after attempting the CryptoTransfer, to a method
  /// with logical signature allowPost(HookContext, ProposedTransfers).
  public var prePostTxSenderAllowanceHook: Proto_HookCall {
    get {
      if case .prePostTxSenderAllowanceHook(let v)? = _storage._senderAllowanceHookCall {return v}
      return Proto_HookCall()
    }
    set {_uniqueStorage()._senderAllowanceHookCall = .prePostTxSenderAllowanceHook(newValue)}
  }

  ///*
  /// If set, a call to a hook of type `ACCOUNT_ALLOWANCE_HOOK` installed on
  /// receiverAccountID that must succeed for the transaction to occur.
  /// <p>
  /// May be set even if `is_approval` is true. In this case, the approval applies
  /// to the sender authorization, and the hook applies to the receiver authorization
  /// (if needed, e.g. because of a fallback royalty fee or receiver signature
  /// requirement).
  public var receiverAllowanceHookCall: OneOf_ReceiverAllowanceHookCall? {
    get {return _storage._receiverAllowanceHookCall}
    set {_uniqueStorage()._receiverAllowanceHookCall = newValue}
  }

  ///*
  /// A single call made before attempting the CryptoTransfer, to a
  /// method with logical signature allow(HookContext, ProposedTransfers)
  public var preTxReceiverAllowanceHook: Proto_HookCall {
    get {
      if case .preTxReceiverAllowanceHook(let v)? = _storage._receiverAllowanceHookCall {return v}
      return Proto_HookCall()
    }
    set {_uniqueStorage()._receiverAllowanceHookCall = .preTxReceiverAllowanceHook(newValue)}
  }

  ///*
  /// Two calls, the first call before attempting the CryptoTransfer, to a
  /// method with logical signature allowPre(HookContext, ProposedTransfers);
  /// and the second call after attempting the CryptoTransfer, to a method
  /// with logical signature allowPost(HookContext, ProposedTransfers).
  public var prePostTxReceiverAllowanceHook: Proto_HookCall {
    get {
      if case .prePostTxReceiverAllowanceHook(let v)? = _storage._receiverAllowanceHookCall {return v}
      return Proto_HookCall()
    }
    set {_uniqueStorage()._receiverAllowanceHookCall = .prePostTxReceiverAllowanceHook(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// If set, a call to a hook of type `ACCOUNT_ALLOWANCE_HOOK` installed on
  /// senderAccountID that must succeed for the transaction to occur.
  /// <p>
  /// Cannot be set if `is_approval` is true.
  public enum OneOf_SenderAllowanceHookCall: Equatable, Sendable {
    ///*
    /// A single call made before attempting the CryptoTransfer, to a
    /// method with logical signature allow(HookContext, ProposedTransfers)
    case preTxSenderAllowanceHook(Proto_HookCall)
    ///*
    /// Two calls, the first call before attempting the CryptoTransfer, to a
    /// method with logical signature allowPre(HookContext, ProposedTransfers);
    /// and the second call after attempting the CryptoTransfer, to a method
    /// with logical signature allowPost(HookContext, ProposedTransfers).
    case prePostTxSenderAllowanceHook(Proto_HookCall)

  }

  ///*
  /// If set, a call to a hook of type `ACCOUNT_ALLOWANCE_HOOK` installed on
  /// receiverAccountID that must succeed for the transaction to occur.
  /// <p>
  /// May be set even if `is_approval` is true. In this case, the approval applies
  /// to the sender authorization, and the hook applies to the receiver authorization
  /// (if needed, e.g. because of a fallback royalty fee or receiver signature
  /// requirement).
  public enum OneOf_ReceiverAllowanceHookCall: Equatable, Sendable {
    ///*
    /// A single call made before attempting the CryptoTransfer, to a
    /// method with logical signature allow(HookContext, ProposedTransfers)
    case preTxReceiverAllowanceHook(Proto_HookCall)
    ///*
    /// Two calls, the first call before attempting the CryptoTransfer, to a
    /// method with logical signature allowPre(HookContext, ProposedTransfers);
    /// and the second call after attempting the CryptoTransfer, to a method
    /// with logical signature allowPost(HookContext, ProposedTransfers).
    case prePostTxReceiverAllowanceHook(Proto_HookCall)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A list of transfers for a particular (non-HBAR) token type.
///
/// A `TokenTransferList` applies to a single token type, but may contain many
/// individual transfers.<br/>
/// Each transfer of a fungible/common token MUST specify an `accountID` and
/// `amount`. Amount SHALL be positive when the account receives tokens, and
/// SHALL be negative when the account sends tokens. The amount SHOULD NOT be
/// `0`.<br/>
/// In a transfer list containing fungible/common tokens in the `transfers`
/// list, the sum of all such transfers MUST be zero (`0`).
/// Each transfer of a unique token SHALL specify both sender and receiver, as
/// well as the serial number transferred.<br/>
/// A single `TokenTransferList` MUST contain `transfers` or `nftTransfers`,
/// but MUST NOT contain both.
public struct Proto_TokenTransferList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A token identifier.<br/>
  /// This is the token to be transferred.
  public var token: Proto_TokenID {
    get {return _token ?? Proto_TokenID()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  ///*
  /// A list of account amounts.
  /// <p>
  /// Each entry SHALL have an account and amount.<br/>
  /// These transfers SHALL be "double-entry" style; the credits (positive
  /// amount) and debits (negative amount) MUST sum to 0, unless this
  /// transfer list is part of a `mint` or `burn` operation.<br/>
  /// This SHALL be be set for fungible/common tokens and MUST be
  /// empty otherwise.
  public var transfers: [Proto_AccountAmount] = []

  ///*
  /// A list of NftTransfers.
  /// <p>
  /// Each entry SHALL have a sender and receiver account, and the
  /// serial number of the unique token to transfer.<br/>
  /// This SHALL be be set for non-fungible/unique tokens and SHALL be
  /// empty otherwise.
  public var nftTransfers: [Proto_NftTransfer] = []

  ///*
  /// An expected decimal precision.<br/>
  /// This is the number of decimals a fungible/common token type is
  /// _expected_ to have.
  /// <p>
  /// The transfer SHALL fail with response code `UNEXPECTED_TOKEN_DECIMALS`
  /// if this is set and the actual decimals specified for the `Token` differ
  /// from this value.<br/>
  /// If `nftTransfers` is set, then this value SHOULD NOT be set.
  public var expectedDecimals: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _expectedDecimals ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_expectedDecimals = newValue}
  }
  /// Returns true if `expectedDecimals` has been explicitly set.
  public var hasExpectedDecimals: Bool {return self._expectedDecimals != nil}
  /// Clears the value of `expectedDecimals`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedDecimals() {self._expectedDecimals = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Proto_TokenID? = nil
  fileprivate var _expectedDecimals: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

///*
/// A rational number.<br/>
/// A common use is to set the amount of a value transfer to collect as a
/// custom fee.
///
/// It is RECOMMENDED that both numerator and denominator be no larger than
/// necessary to express the required fraction. A very large numerator, in
/// particular, may not be reliable.
/// Both fields are REQUIRED and SHOULD be positive integers.
public struct Proto_Fraction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A fractional number's numerator.
  public var numerator: Int64 = 0

  ///*
  /// A fractional number's denominator.
  /// <p>
  /// A zero value SHALL fail with response code `FRACTION_DIVIDES_BY_ZERO`.
  public var denominator: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A Key is an entity representing one or more cryptographic public/private key
/// pairs and, optionally, the structure for how multiple signatures may be
/// composed to meet complex multiple-signature authorization requirements.
///
/// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1)
/// signature schemes. In the ECDSA(secp256k1) case we require the 33-byte
/// compressed form of the public key. For simplicity, we call these
/// cryptographic public keys `primitive` keys.<br/>
/// If an entity has a primitive key associated to it, then the corresponding
/// private key must sign any transaction to send tokens or perform other
/// actions requiring authorization.
///
/// A Key can also be the ID of a smart contract, which SHALL authorize that
/// contract to execute any system contract with signing requirements that are
/// met by the key.<br/>
/// > Example
/// >> If account `0.0.A` has a threshold key whose threshold is satisfied
/// >> by a contract ID key for contract `0.0.C`, then when `0.0.C` is called,
/// >> it is authorized to use system contracts to manage any asset owned by
/// >> `0.0.A`. If the contract ID key is "delegatable", then `0.0.C` can even
/// >> perform these actions when running code accessed via `DELEGATECALL`.
///
/// A Key can be a "threshold key", which is a list of N keys, any M of which
/// may sign in order for the signature to be considered valid. The value of
/// M for a given threshold key MUST be less than or equal to N. A threshold
/// key is sometimes called a "M-of-N" key.
///
/// A Key can be a "key list" where all keys in the list must sign unless
/// specified otherwise in the documentation for a specific transaction
/// type (e.g. FileDeleteTransactionBody).<br/>
/// This implies that the use of a key list is dependent on context. For
/// example, an Hedera file that is created with a list of keys, SHALL require
/// that all of those keys must sign a transaction to create or modify the file,
/// but only one key from that list MUST sign a transaction to delete the file.
/// So it is a single list that sometimes acts as a N-of-N threshold key, and
/// sometimes acts as a 1-of-N threshold key.<br/>
/// To reduce confusion this may cause, a key list SHALL always be considered
/// N-of-N, unless specified otherwise in official documentation.<br/>
/// A key list MAY have repeated primitive public keys, but the signature
/// requirement for all keys in a repeated set SHALL be satisfied by a single
/// valid signature. There is no mechanism to require a single key to sign a
/// single transaction more than once.
///
/// Any list or threshold key MAY have nested key lists or threshold keys.
/// This allows, for example, the keys within a threshold signature to
/// themselves be threshold, list, contract, or primitive keys. This nesting
/// structure enables complex asymmetric multi-party signature requirements to
/// be met.
///
/// To ensure adequate performance and transaction security, key nesting is
/// limited to at most fifteen(15) levels.
public struct Proto_Key: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Proto_Key.OneOf_Key? = nil

  ///*
  /// A smart contract instance that is authorized implicitly.
  /// <p>
  /// This key type SHALL require that the code in the active message frame
  /// belong to the contract with the given id.
  public var contractID: Proto_ContractID {
    get {
      if case .contractID(let v)? = key {return v}
      return Proto_ContractID()
    }
    set {key = .contractID(newValue)}
  }

  ///*
  /// An array of Ed25519 public key bytes.
  public var ed25519: Data {
    get {
      if case .ed25519(let v)? = key {return v}
      return Data()
    }
    set {key = .ed25519(newValue)}
  }

  ///*
  /// This option is not currently supported.<br/>
  /// An array of RSA-3072 public key bytes.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = key {return v}
      return Data()
    }
    set {key = .rsa3072(newValue)}
  }

  ///*
  /// This option is not currently supported.<br/>
  /// An array of ECDSA, using the p-384 curve, public key bytes.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = key {return v}
      return Data()
    }
    set {key = .ecdsa384(newValue)}
  }

  ///*
  /// A threshold, M, combined with a list of N keys, any M of which are
  /// sufficient to form a valid signature.
  public var thresholdKey: Proto_ThresholdKey {
    get {
      if case .thresholdKey(let v)? = key {return v}
      return Proto_ThresholdKey()
    }
    set {key = .thresholdKey(newValue)}
  }

  ///*
  /// A list of keys. This may be treated like a "N-of-N" threshold key,
  /// as a component of another key, or in some other manner as documented.
  public var keyList: Proto_KeyList {
    get {
      if case .keyList(let v)? = key {return v}
      return Proto_KeyList()
    }
    set {key = .keyList(newValue)}
  }

  ///*
  /// A set of compressed ECDSA(secp256k1) public key bytes.<br/>
  /// This is an EVM compatibility format.
  public var ecdsaSecp256K1: Data {
    get {
      if case .ecdsaSecp256K1(let v)? = key {return v}
      return Data()
    }
    set {key = .ecdsaSecp256K1(newValue)}
  }

  ///*
  /// A smart contract that, if the recipient of the active message frame,
  /// SHALL be imputed authorization.<br/>
  /// Setting this key type is a more permissive version of setting a
  /// contractID key.
  /// <p>
  /// This key form SHALL NOT strictly require that the code being executed
  /// in the frame belong to the given contract. The code in frame MAY be
  /// running another contract via a `delegatecall`.
  public var delegatableContractID: Proto_ContractID {
    get {
      if case .delegatableContractID(let v)? = key {return v}
      return Proto_ContractID()
    }
    set {key = .delegatableContractID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable, @unchecked Sendable {
    ///*
    /// A smart contract instance that is authorized implicitly.
    /// <p>
    /// This key type SHALL require that the code in the active message frame
    /// belong to the contract with the given id.
    case contractID(Proto_ContractID)
    ///*
    /// An array of Ed25519 public key bytes.
    case ed25519(Data)
    ///*
    /// This option is not currently supported.<br/>
    /// An array of RSA-3072 public key bytes.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    case rsa3072(Data)
    ///*
    /// This option is not currently supported.<br/>
    /// An array of ECDSA, using the p-384 curve, public key bytes.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    case ecdsa384(Data)
    ///*
    /// A threshold, M, combined with a list of N keys, any M of which are
    /// sufficient to form a valid signature.
    case thresholdKey(Proto_ThresholdKey)
    ///*
    /// A list of keys. This may be treated like a "N-of-N" threshold key,
    /// as a component of another key, or in some other manner as documented.
    case keyList(Proto_KeyList)
    ///*
    /// A set of compressed ECDSA(secp256k1) public key bytes.<br/>
    /// This is an EVM compatibility format.
    case ecdsaSecp256K1(Data)
    ///*
    /// A smart contract that, if the recipient of the active message frame,
    /// SHALL be imputed authorization.<br/>
    /// Setting this key type is a more permissive version of setting a
    /// contractID key.
    /// <p>
    /// This key form SHALL NOT strictly require that the code being executed
    /// in the frame belong to the given contract. The code in frame MAY be
    /// running another contract via a `delegatecall`.
    case delegatableContractID(Proto_ContractID)

  }

  public init() {}
}

///*
/// A threshold value and a list of public keys that, together, form a threshold
/// signature requirement. Any subset of the keys in the list may satisfy the
/// signature requirements of this type of key, provided the number of keys meets
/// or exceeds the threshold. For example, if a particular key has a threshold of
/// three(3) and eight(8) keys in the list, then any three(3) signatures, from
/// the list of eight(8), is sufficient to authorize that key.
///
/// For threshold purposes, all signatures from a single `primitive` key are
/// considered a single signature, so that signature(s) from a single key SHALL
/// NOT _directly_ meet a threshold greater than one(1).
///
/// #### Note
/// > It is possible to construct a complex key structure that _would_ enable a
/// > single primitive key to successfully meet a threshold requirement. All
/// > threshold keys SHOULD be carefully audited to ensure no one `primitive`
/// > key, or smart contract, has disproportionate capability.
public struct Proto_ThresholdKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A transaction MUST have valid signatures from at least this number of
  /// separate keys, from the `keys` list to be authorized by this key.
  public var threshold: UInt32 = 0

  ///*
  /// A list of the keys that MAY satisfy signature requirements of this key.
  public var keys: Proto_KeyList {
    get {return _keys ?? Proto_KeyList()}
    set {_keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  public var hasKeys: Bool {return self._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  public mutating func clearKeys() {self._keys = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keys: Proto_KeyList? = nil
}

///*
/// A list of keys.<br/>
/// A `KeyList` requires all keys (N-of-N) to sign, unless otherwise
/// specified in official documentation. A KeyList may contain repeated keys,
/// but all such repeated keys are considered a single key when determining
/// signature authorization.
///
/// ### Additional Notes
/// 1. An empty key list is the "standard" mechanism to represent an
///    unassigned key. For example, if the `admin_key` of a token is set
///    to the empty key list, then that token has no admin key, and
///    functionality that requires an admin key to sign the
///    transaction is disabled.
public struct Proto_KeyList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A list of keys. All values in this list SHALL be non-null.
  /// <p>
  public var keys: [Proto_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// This message is deprecated and MUST NOT be used to communicate with
/// network nodes. It is retained here only for historical reasons.
///
/// Client software MUST NOT include this message in any request. <br/>
/// Compliant nodes SHALL NOT accept any request containing this message.
///
/// Please use the `SignaturePair` and `SignatureMap` messages instead of
/// this message.
///
/// NOTE: This message was marked as deprecated in the .proto file.
public struct Proto_Signature: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signature: Proto_Signature.OneOf_Signature? = nil

  ///*
  /// Smart contract virtual signature (always length zero).
  public var contract: Data {
    get {
      if case .contract(let v)? = signature {return v}
      return Data()
    }
    set {signature = .contract(newValue)}
  }

  ///*
  /// Ed25519 signature bytes.
  public var ed25519: Data {
    get {
      if case .ed25519(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ed25519(newValue)}
  }

  ///*
  /// RSA-3072 signature bytes.
  public var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = signature {return v}
      return Data()
    }
    set {signature = .rsa3072(newValue)}
  }

  ///*
  /// ECDSA p-384 signature bytes.
  public var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ecdsa384(newValue)}
  }

  ///*
  /// A list of signatures for a single N-of-M threshold Key. This must be
  /// a list of exactly M signatures, at least N of which are non-null.
  public var thresholdSignature: Proto_ThresholdSignature {
    get {
      if case .thresholdSignature(let v)? = signature {return v}
      return Proto_ThresholdSignature()
    }
    set {signature = .thresholdSignature(newValue)}
  }

  ///*
  /// A list of M signatures, each corresponding to a Key in a KeyList
  /// of the same length.
  public var signatureList: Proto_SignatureList {
    get {
      if case .signatureList(let v)? = signature {return v}
      return Proto_SignatureList()
    }
    set {signature = .signatureList(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Signature: Equatable, @unchecked Sendable {
    ///*
    /// Smart contract virtual signature (always length zero).
    case contract(Data)
    ///*
    /// Ed25519 signature bytes.
    case ed25519(Data)
    ///*
    /// RSA-3072 signature bytes.
    case rsa3072(Data)
    ///*
    /// ECDSA p-384 signature bytes.
    case ecdsa384(Data)
    ///*
    /// A list of signatures for a single N-of-M threshold Key. This must be
    /// a list of exactly M signatures, at least N of which are non-null.
    case thresholdSignature(Proto_ThresholdSignature)
    ///*
    /// A list of M signatures, each corresponding to a Key in a KeyList
    /// of the same length.
    case signatureList(Proto_SignatureList)

  }

  public init() {}
}

///*
/// This message is deprecated and MUST NOT be used to communicate with network
/// nodes. It is retained here only for historical reasons.
///
/// Client software MUST NOT include this message in any request. <br/>
/// Compliant nodes SHALL NOT accept any request containing this message.
///
/// Please use the `SignaturePair` and `SignatureMap` messages, in combination
/// with `ThresholdKey` keys, instead of this message.
///
/// NOTE: This message was marked as deprecated in the .proto file.
public struct Proto_ThresholdSignature: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// For an N-of-M threshold key, this is a list of M signatures, at least N
  /// of which must be non-null.
  public var sigs: Proto_SignatureList {
    get {return _sigs ?? Proto_SignatureList()}
    set {_sigs = newValue}
  }
  /// Returns true if `sigs` has been explicitly set.
  public var hasSigs: Bool {return self._sigs != nil}
  /// Clears the value of `sigs`. Subsequent reads from it will return its default value.
  public mutating func clearSigs() {self._sigs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sigs: Proto_SignatureList? = nil
}

///*
/// This message is deprecated and MUST NOT be used to communicate with network
/// nodes. It is retained here only for historical reasons.
///
/// Client software MUST NOT include this message in any request. <br/>
/// Compliant nodes SHALL NOT accept any request containing this message.
///
/// Please use the `SignaturePair` and `SignatureMap` messages instead of
/// this message.
///
/// NOTE: This message was marked as deprecated in the .proto file.
public struct Proto_SignatureList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Each signature corresponds to a Key in the KeyList.
  public var sigs: [Proto_Signature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A public key and signature pair.<br/>
/// Only Ed25519 and ECDSA(secp256k1) keys and signatures are currently supported
/// as cryptographic (non-implied) signatures.
public struct Proto_SignaturePair: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Prefix bytes of the public key.
  /// <p>
  /// The client may use any number of bytes from zero to the whole length of
  /// the public key for pubKeyPrefix. If zero bytes are used, then it MUST be
  /// true that only one cryptographic key is required to sign the associated
  /// transaction.<br/>
  /// If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic
  /// key is required to sign the transaction, the request SHALL resolve to
  /// `INVALID_SIGNATURE`.
  /// <blockquote>Important Note<blockquote>
  /// In the special case that a signature is provided to authorize a
  /// precompiled contract, the `pubKeyPrefix` MUST contain the _entire public
  /// key_.<br/>
  /// That is, if the key is an Ed25519 key, the `pubKeyPrefix` MUST be
  /// 32 bytes long and contain the full public key bytes.<br/>
  /// If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be
  /// 33 bytes long and contain the full _compressed_ form of the public key.
  /// </blockquote></blockquote>
  /// <p>
  /// <dl><dt>Purpose</dt>
  /// <dd>The `pubKeyPrefix` exists to save cost. A signed transaction with
  /// shorter prefixes will have fewer bytes, and so will have a lower
  /// transaction fee.
  /// The prefixes, however, MUST be long enough to distinguish between all
  /// of the public keys that might be signing the transaction. Therefore,
  /// software signing a transaction SHOULD evaluate which keys might possibly
  /// be required to sign a transaction, and ensure that the shortest prefix
  /// that is sufficient to unambiguously identify the correct key is used.
  /// </dd></dl>
  public var pubKeyPrefix: Data = Data()

  public var signature: Proto_SignaturePair.OneOf_Signature? = nil

  ///*
  /// A smart contract virtual signature.
  /// <p>
  /// This value MUST be length zero, if set.
  public var contract: Data {
    get {
      if case .contract(let v)? = signature {return v}
      return Data()
    }
    set {signature = .contract(newValue)}
  }

  ///*
  /// An Ed25519 signature.
  public var ed25519: Data {
    get {
      if case .ed25519(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ed25519(newValue)}
  }

  ///*
  /// This option is not supported.<br/>
  /// A RSA-3072 signature.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var rsa3072: Data {
    get {
      if case .rsa3072(let v)? = signature {return v}
      return Data()
    }
    set {signature = .rsa3072(newValue)}
  }

  ///*
  /// This option is not supported.<br/>
  /// ECDSA p-384 signature.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var ecdsa384: Data {
    get {
      if case .ecdsa384(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ecdsa384(newValue)}
  }

  ///*
  /// An ECDSA(secp256k1) signature.
  public var ecdsaSecp256K1: Data {
    get {
      if case .ecdsaSecp256K1(let v)? = signature {return v}
      return Data()
    }
    set {signature = .ecdsaSecp256K1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Signature: Equatable, @unchecked Sendable {
    ///*
    /// A smart contract virtual signature.
    /// <p>
    /// This value MUST be length zero, if set.
    case contract(Data)
    ///*
    /// An Ed25519 signature.
    case ed25519(Data)
    ///*
    /// This option is not supported.<br/>
    /// A RSA-3072 signature.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    case rsa3072(Data)
    ///*
    /// This option is not supported.<br/>
    /// ECDSA p-384 signature.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    case ecdsa384(Data)
    ///*
    /// An ECDSA(secp256k1) signature.
    case ecdsaSecp256K1(Data)

  }

  public init() {}
}

///*
/// A set of signatures corresponding to every unique public key that
/// signed a given transaction.
///
/// If any public key matches more than one prefix in the signature map,
/// the transaction containing that map SHALL fail immediately with the
/// response code `KEY_PREFIX_MISMATCH`.
public struct Proto_SignatureMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A list of signature pairs for a specific transaction.<br/>
  /// Each signature pair represents a single cryptographic (`primitive`)
  /// public key identified by a "prefix" value and the cryptographic
  /// signature produced for that key.
  public var sigPair: [Proto_SignaturePair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A set of values the nodes use in determining transaction and query fees, and
/// constants involved in fee calculations.
///
/// Nodes SHALL multiply the amount of "resources" allocated to a transaction or
/// query by the corresponding price to calculate the appropriate fee. Units are
/// one-thousandth of a `tinyCent`. The "resource" allocations SHALL be estimated
/// based on transaction characteristics and current network state, and MAY be
/// further adjusted based on network load and congestion.
///
/// This SHALL be used, in different contexts, for the cost _factors_ used to
/// calculate charged amounts, for the resource accumulation, and for actual
/// amounts to be charged.<br/>
/// Amounts recorded here MUST be converted to tinybar according to the
/// current active `ExchangeRate` for the network.
public struct Proto_FeeComponents: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Base: "minimum total fee".
  /// <p>
  /// The calculated fee MUST be greater than this value.
  public var min: Int64 = 0

  ///*
  /// Base: "maximum total fee".
  /// <p>
  /// The calculated fee MUST be less than this value.
  public var max: Int64 = 0

  ///*
  /// Base: "constant fee".<br/>
  /// A baseline constant contribution to total fee.
  public var constant: Int64 = 0

  ///*
  /// Bandwidth: "bytes per transaction".<br/>
  /// The fee for bandwidth consumed by a transaction, measured in bytes
  public var bpt: Int64 = 0

  ///*
  /// Signatures: "validations per transaction".<br/>
  /// The fee for signature verifications required by a transaction
  public var vpt: Int64 = 0

  ///*
  /// Memory: "RAM byte-hours".<br/>
  /// The fee for RAM required to process a transaction,
  /// measured in byte-hours
  public var rbh: Int64 = 0

  ///*
  /// Disk: "storage byte-hours".<br/>
  /// The fee for storage required by a transaction, measured in byte-hours
  public var sbh: Int64 = 0

  ///*
  /// Compute: Ethereum term for a derivative EVM compute resource.<br/>
  /// The fee of computation for a smart contract transaction. The value of
  /// gas is set by a conversion rate, and is regularly updated to reflect
  /// reasonable and customary costs.
  public var gas: Int64 = 0

  ///*
  /// Ad valorem: "transferred value".<br/>
  /// The fee for HBAR transferred by a transaction.
  public var tv: Int64 = 0

  ///*
  /// Response memory: "bytes per response".<br/>
  /// The fee for data retrieved from memory to deliver a response,
  /// measured in bytes
  public var bpr: Int64 = 0

  ///*
  /// Response disk: "storage bytes per response".<br/>
  /// The fee for data retrieved from disk to deliver a response,
  /// measured in bytes
  public var sbpr: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The fee schedule for a specific transaction or query based on the fee data.
public struct Proto_TransactionFeeSchedule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// An enumeration for a particular transaction or query.<br/>
  /// The functionality type determines the base cost parameters.
  public var hederaFunctionality: Proto_HederaFunctionality = .none

  ///*
  /// Use `fees` instead of this field.<br/>
  /// Resource price coefficients.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var feeData: Proto_FeeData {
    get {return _feeData ?? Proto_FeeData()}
    set {_feeData = newValue}
  }
  /// Returns true if `feeData` has been explicitly set.
  public var hasFeeData: Bool {return self._feeData != nil}
  /// Clears the value of `feeData`. Subsequent reads from it will return its default value.
  public mutating func clearFeeData() {self._feeData = nil}

  ///*
  /// The resource price coefficients for transaction type and any applicable
  /// subtypes.<br/>
  /// The multiple entries enable support for subtype price definitions.
  public var fees: [Proto_FeeData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feeData: Proto_FeeData? = nil
}

///*
/// A total fee, in component amounts charged for a transaction.
///
/// Total fees are composed of three sets of components.
/// - Node data, components that compensate the specific node that submitted
///   the transaction.
/// - Network data, components that compensate the Hedera network for gossiping
///   the transaction and determining the consensus timestamp.
/// - Service data, components that compensate the Hedera network for the ongoing
///   maintenance and operation of the network, as well as ongoing development
///   of network services.
///
/// Fee components are recorded in thousandths of a tiny cent, and the network
/// exchange rate converts these to tinybar amounts, which are what the network
/// charges for transactions and what the network reports in the record stream.
public struct Proto_FeeData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Fee components to be paid to the submitting node.
  public var nodedata: Proto_FeeComponents {
    get {return _storage._nodedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._nodedata = newValue}
  }
  /// Returns true if `nodedata` has been explicitly set.
  public var hasNodedata: Bool {return _storage._nodedata != nil}
  /// Clears the value of `nodedata`. Subsequent reads from it will return its default value.
  public mutating func clearNodedata() {_uniqueStorage()._nodedata = nil}

  ///*
  /// Fee components to be paid to the network for bringing a
  /// transaction to consensus.
  public var networkdata: Proto_FeeComponents {
    get {return _storage._networkdata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._networkdata = newValue}
  }
  /// Returns true if `networkdata` has been explicitly set.
  public var hasNetworkdata: Bool {return _storage._networkdata != nil}
  /// Clears the value of `networkdata`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkdata() {_uniqueStorage()._networkdata = nil}

  ///*
  /// Fee components to be paid to the network for providing the immediate and
  /// ongoing services associated with executing the transaction, maintaining
  /// the network, and developing the network software.
  public var servicedata: Proto_FeeComponents {
    get {return _storage._servicedata ?? Proto_FeeComponents()}
    set {_uniqueStorage()._servicedata = newValue}
  }
  /// Returns true if `servicedata` has been explicitly set.
  public var hasServicedata: Bool {return _storage._servicedata != nil}
  /// Clears the value of `servicedata`. Subsequent reads from it will return its default value.
  public mutating func clearServicedata() {_uniqueStorage()._servicedata = nil}

  ///*
  /// A sub-type distinguishing between different types of `FeeData` that may
  /// apply to the same base transaction type (associated with
  /// an `HederaFunctionality`).
  public var subType: Proto_SubType {
    get {return _storage._subType}
    set {_uniqueStorage()._subType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A set of fee schedules covering all transaction types and query types, along
/// with a specific time at which this fee schedule will expire.
///
/// Nodes SHALL use the most recent unexpired fee schedule to determine the fees
/// for all transactions based on various resource components imputed to each
/// transaction.
public struct Proto_FeeSchedule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Sets of fee coefficients for various transaction or query types.
  public var transactionFeeSchedule: [Proto_TransactionFeeSchedule] = []

  ///*
  /// A time, in seconds since the `epoch`, when this fee schedule
  /// will expire.
  /// <p>
  /// For this purpose, `epoch` SHALL be the UNIX epoch
  /// with 0 at `1970-01-01T00:00:00.000Z`.
  public var expiryTime: Proto_TimestampSeconds {
    get {return _expiryTime ?? Proto_TimestampSeconds()}
    set {_expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  public var hasExpiryTime: Bool {return self._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpiryTime() {self._expiryTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiryTime: Proto_TimestampSeconds? = nil
}

///*
/// The "current" fee schedule and the "next" fee schedule.
///
/// The current fee schedule is the schedule that SHALL apply to the current
/// transaction.<br/>
/// The next fee schedule is the schedule that SHALL apply after the current
/// schedule expires.<br/>
/// We store both to avoid a condition where transactions are processed very
/// near the time when a fee schedule expires and it might be indeterminate
/// which fees to apply. With both current and next fee schedule the network
/// can deterministically apply the correct fee schedule based on consensus
/// timestamp for each transaction.
public struct Proto_CurrentAndNextFeeSchedule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A current, unexpired, fee schedule.
  public var currentFeeSchedule: Proto_FeeSchedule {
    get {return _currentFeeSchedule ?? Proto_FeeSchedule()}
    set {_currentFeeSchedule = newValue}
  }
  /// Returns true if `currentFeeSchedule` has been explicitly set.
  public var hasCurrentFeeSchedule: Bool {return self._currentFeeSchedule != nil}
  /// Clears the value of `currentFeeSchedule`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentFeeSchedule() {self._currentFeeSchedule = nil}

  ///*
  /// A future fee schedule to use when the current schedule expires.
  public var nextFeeSchedule: Proto_FeeSchedule {
    get {return _nextFeeSchedule ?? Proto_FeeSchedule()}
    set {_nextFeeSchedule = newValue}
  }
  /// Returns true if `nextFeeSchedule` has been explicitly set.
  public var hasNextFeeSchedule: Bool {return self._nextFeeSchedule != nil}
  /// Clears the value of `nextFeeSchedule`. Subsequent reads from it will return its default value.
  public mutating func clearNextFeeSchedule() {self._nextFeeSchedule = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentFeeSchedule: Proto_FeeSchedule? = nil
  fileprivate var _nextFeeSchedule: Proto_FeeSchedule? = nil
}

///*
/// A network node endpoint.<br/>
/// Each network node in the global address book publishes one or more endpoints
/// which enable the nodes to communicate both with other nodes, for gossip, and
/// with clients to receive transaction requests.
///
/// This message supports IPv4 with address and TCP port,
/// and MAY include a FQDN instead of an IP address.<br/>
/// IPv6 is not currently supported.
///
/// When the `domain_name` field is set, the `ipAddressV4` field
/// MUST NOT be set.<br/>
/// When the `ipAddressV4` field is set, the `domain_name` field
/// MUST NOT be set.
public struct Proto_ServiceEndpoint: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A 32-bit IPv4 address.<br/>
  /// This is the address of the endpoint, encoded in pure "big-endian"
  /// (i.e. left to right) order (e.g. `127.0.0.1` has hex bytes in the
  /// order `7F`, `00`, `00`, `01`).
  public var ipAddressV4: Data = Data()

  ///*
  /// A TCP port to use.
  /// <p>
  /// This value MUST be between 0 and 65535, inclusive.
  public var port: Int32 = 0

  ///*
  /// A node domain name.
  /// <p>
  /// This MUST be the fully qualified domain name of the node.<br/>
  /// This value MUST NOT exceed 253 characters.<br/>
  /// When the `domain_name` field is set, the `ipAddressV4`
  /// field MUST NOT be set.<br/>
  /// When the `ipAddressV4` field is set, the `domain_name`
  /// field MUST NOT be set.
  public var domainName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The data about a node, including its service endpoints and the Hedera account
/// to be paid for services provided by the node (that is, queries answered and
/// transactions submitted).
///
/// All active fields are populated in the `0.0.102` address book file.<br/>
/// Only fields documented with "`0.0.101` field" are populated in the 0.0.101
/// address book file.
///
/// This message MAY be superseded by messages in state/addressbook/node.proto
/// and node_get_info.proto.
public struct Proto_NodeAddress: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// ServiceEndpoint is now used to retrieve a node's list of IP
  /// addresses and ports.<br/>
  /// The IP address of the Node, as a string, encoded in UTF-8.<br/>
  /// This value SHALL NOT be populated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var ipAddress: Data = Data()

  ///*
  /// ServiceEndpoint is now used to retrieve a node's list of IP
  /// addresses and ports.<br/>
  /// The port number of the grpc server for the node.<br/>
  /// This value SHALL NOT be populated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var portno: Int32 = 0

  ///*
  /// Description provides short text functionality.<br/>
  /// A short description of the node.
  /// <p>
  /// This field SHALL NOT be populated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var memo: Data = Data()

  ///*
  /// A hexadecimal String encoding of an X509 public key.
  /// <p>
  /// This X509 RSA _public_ key SHALL be used to verify record stream files
  /// (e.g., record stream files).<br/>
  /// This field SHALL be a string of hexadecimal characters, encoded UTF-8,
  /// which, translated to binary, form the public key DER encoding.
  public var rsaPubKey: String = String()

  ///*
  /// A numeric identifier for the node.
  /// <p>
  /// This value SHALL NOT be sequential.
  /// <p>
  /// A `0.0.101` field
  public var nodeID: Int64 = 0

  ///*
  /// An account to be paid the "node" portion of transaction fees.<br/>
  /// The "node" fees are paid to the node that submitted the transaction.
  /// <p>
  /// A `0.0.101` field
  public var nodeAccountID: Proto_AccountID {
    get {return _nodeAccountID ?? Proto_AccountID()}
    set {_nodeAccountID = newValue}
  }
  /// Returns true if `nodeAccountID` has been explicitly set.
  public var hasNodeAccountID: Bool {return self._nodeAccountID != nil}
  /// Clears the value of `nodeAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearNodeAccountID() {self._nodeAccountID = nil}

  ///*
  /// A hash of the node's TLS certificate.
  /// <p>
  /// This field SHALL be a string of hexadecimal characters, encoded UTF-8,
  /// which, translated to binary, form a SHA-384 hash of the node's TLS
  /// certificate in PEM format.
  /// This TLS certificate MUST be encoded UTF-8 and normalized according to
  /// the NFKD form prior to computing the hash value.<br/>
  /// The value of this field SHALL be used to verify the node TLS
  /// certificate when presented during protocol negotiation.
  /// <p>
  /// A `0.0.101` field
  public var nodeCertHash: Data = Data()

  ///*
  /// A node's service IP addresses and TCP ports.<br/>
  /// Nodes require multiple endpoints to ensure that inter-node communication
  /// (e.g. gossip) is properly separated from client communication to
  /// API endpoints.
  /// <p>
  /// A `0.0.101` field
  public var serviceEndpoint: [Proto_ServiceEndpoint] = []

  ///*
  /// A short description of the node.
  /// <p>
  /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
  /// (default 100) bytes when encoded as UTF-8.
  public var description_p: String = String()

  ///*
  /// This is replaced by per-account stake tracking and dynamic
  /// calculation.<br/>
  /// The amount of tinybar staked to the node.<br/>
  /// This value SHOULD NOT be populated, and SHALL be ignored.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var stake: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeAccountID: Proto_AccountID? = nil
}

///*
/// A list of nodes and their metadata that contains details of the nodes
/// running the network.
///
/// Used to parse the contents of system files `0.0.101` and `0.0.102`.
public struct Proto_NodeAddressBook: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Published data for all nodes in the network
  public var nodeAddress: [Proto_NodeAddress] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A software version according to "[semantic versioning](https://semver.org/)"
/// or "date versioning".
///
/// Hedera currently modifies the "typical" semantic versioning somewhat, the
/// `major` version is always `0`, and each release increments the `minor`
/// version. The `patch` and `pre` components are used in the typical manner.
/// The `build` component is not generally used.
public struct Proto_SemanticVersion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A major version.<br/>
  /// Hedera does not increment this value and retains a `0` value to
  /// indicate that API may change for any release.
  /// <p>
  /// This value SHALL increment for an incompatible API change.<br/>
  public var major: Int32 = 0

  ///*
  /// A minor version.<br/>
  /// Hedera increments this value with each release.<br/>
  /// There may be incompatible API changes in any Hedera Services release.
  /// <p>
  /// This value SHALL increment for backwards-compatible new
  /// functionality.
  public var minor: Int32 = 0

  ///*
  /// A patch version.
  /// <p>
  /// This value SHALL increment for backwards-compatible bug fixes.
  public var patch: Int32 = 0

  ///*
  /// A pre-release version.
  /// <p>
  /// This MAY be denoted by appending a hyphen and a series of dot separated
  /// identifiers per [Semver Specification](https://semver.org/#spec-item-9);
  /// given a string `0.14.0-alpha.1+21AF26D3`, this field would contain
  /// 'alpha.1'
  public var pre: String = String()

  ///*
  /// A build version.
  /// <p>
  /// Build version MAY be denoted by appending a plus sign and a series of
  /// dot separated identifiers immediately following the patch or pre-release
  /// version per [Semver Specification](https://semver.org/#spec-item-10); so
  /// given a string `0.14.0-alpha.1+21AF26D3`, this field
  /// would contain '21AF26D3'
  public var build: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A single runtime configuration setting.
///
/// Typically a name-value pair, this may also contain a small amount of
/// associated data.
public struct Proto_Setting: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A name for this setting property.
  public var name: String = String()

  ///*
  /// A value for this setting property.
  public var value: String = String()

  ///*
  /// A small quantity of data associated with this setting.
  /// <p>
  /// This SHOULD be less than 100 bytes.<br/>
  /// If the value is a string, it MUST be encoded UTF-8.
  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// Setting values representing a source of runtime configuration information.
public struct Proto_ServicesConfigurationList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A List of `Setting` values, typically read from application properties.
  public var nameValue: [Proto_Setting] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// An Hedera Token Service token relationship. A token relationship describes
/// the connection between an Account and a Token type, including the current
/// account balance in that token.
///
/// A `TokenRelationship` SHALL contain, for the designated token and enclosing
/// account, The account's current balance, whether the account has KYC granted,
/// whether the assets are frozen and whether the association was automatic.<br/>
/// A `TokenRelationship` MAY also contain the `symbol` and `decimals` values
/// copied from the token.<br/>
/// `TokenRelationship` entries SHALL be valid only within the context of a
/// `GetAccountDetails` query response, or other enclosing message, which
/// specifies the account side of the relationship.
public struct Proto_TokenRelationship: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A token identifier.
  /// <p>
  /// This MUST match an existing token that is not deleted.
  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  ///*
  /// A token symbol.
  /// <p>
  /// This MUST match an existing token that is not deleted.<br/>
  /// This MUST match the value for the token identified in `tokenId`.
  public var symbol: String = String()

  ///*
  /// An account balance for this token.
  /// <p>
  /// For fungible/common tokens this SHALL be the balance that the
  /// account holds of that token. The value is provided as an integer amount
  /// of the smallest unit of the token (i.e. 10<sup>`-decimals`</sup> whole
  /// tokens).<br/>
  /// For non-fungible/unique tokens this SHALL be the whole number of
  /// unique tokens held by the account for this token type.
  public var balance: UInt64 = 0

  ///*
  /// A KYC status for the account with respect to this token.
  /// <p>
  /// This may be `KycNotApplicable`, `Granted` or `Revoked` and, if KYC is
  /// not supported for this token (e.g. the `kyc_key` of the token is not
  /// set), this SHALL be `KycNotApplicable`.
  public var kycStatus: Proto_TokenKycStatus = .kycNotApplicable

  ///*
  /// A Freeze status for the account with respect to this token.
  /// <p>
  /// This value SHALL be one of `FreezeNotApplicable`, `Frozen`
  /// or `Unfrozen`.<br/>
  /// If the token cannot freeze account assets (e.g. the `freeze_key` of the
  /// token is not set), this SHALL be `FreezeNotApplicable`.
  public var freezeStatus: Proto_TokenFreezeStatus = .freezeNotApplicable

  ///*
  /// A maximum "precision" for this token.
  /// <p>
  /// This value MUST match the `decimals` field of the token identified in
  /// the `tokenId` field.<br/>
  /// A single whole token SHALL be divided into at most
  /// 10<sup>`decimals`</sup> sub-units.
  public var decimals: UInt32 = 0

  ///*
  /// An automatic association flag.
  /// <p>
  /// This SHALL be set if the relationship was created implicitly
  /// (automatically).<br/>
  /// This SHALL be unset if the relationship was created explicitly
  /// (manually) via a `TokenAssociate` transaction.
  public var automaticAssociation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
}

///*
/// A number of _transferable units_ of a specified token.
///
/// The transferable unit of a token is its smallest denomination, as given by
/// the token's `decimals` property. Each minted token contains
/// 10<sup>`decimals`</sup> transferable units. For example, we could think of
/// the cent as the transferable unit of the US dollar (`decimals=2`); and the
/// tinybar as the transferable unit of HBAR (`decimals=8`).
///
/// Transferable units are not directly comparable across different tokens.
public struct Proto_TokenBalance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A token identifier.
  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  ///*
  /// A number of transferable units of the identified token.
  /// <p>
  /// For fungible/common tokens this SHALL be the balance, in units of
  /// 10<sup>`-decimals`</sup> whole tokens.<br/>
  /// For non-fungible/unique tokens, this SHALL be the number of
  /// individual unique tokens in this balance.
  public var balance: UInt64 = 0

  ///*
  /// A number of "decimals" precision.
  /// <p>
  /// This MUST match the `decimals` value for the token identified by the
  /// `tokenId` field.
  public var decimals: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
}

///*
/// A set of token balance values.
///
/// Each entry describes the balance the enclosing account holds for a specific
/// token. The balance is an amount for a fungible/common token or a count for
/// a non-fungible/unique token.
public struct Proto_TokenBalances: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A list of token balance values.<br/>
  /// Each entry represents a single account balance for a single token.
  public var tokenBalances: [Proto_TokenBalance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// An association between a token and an account.
///
/// An account must be associated with a token before that account can transact
/// in (send or receive) that token.
public struct Proto_TokenAssociation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A token identifier for the associated token.
  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  ///*
  /// An account identifier for the associated account.
  public var accountID: Proto_AccountID {
    get {return _accountID ?? Proto_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
  fileprivate var _accountID: Proto_AccountID? = nil
}

///*
/// Staking information for an account or a contract.
///
/// This is used for responses returned from `CryptoGetInfo` or
/// `ContractGetInfo` queries.
public struct Proto_StakingInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A flag indicating that the holder of this account has chosen to decline
  /// staking rewards.
  public var declineReward: Bool = false

  ///*
  /// A `Timestamp` of the start time for the latest active staking period.
  /// <p>
  /// This MUST be a period during which either the staking settings for this
  /// account or contract changed or the account or contract received staking
  /// rewards, whichever is later. Examples of a change in staking settings
  /// include starting staking or changing the staked_node_id.<br/>
  /// If this account or contract is not currently staked to a node, then this
  /// field SHALL NOT be set.
  public var stakePeriodStart: Proto_Timestamp {
    get {return _stakePeriodStart ?? Proto_Timestamp()}
    set {_stakePeriodStart = newValue}
  }
  /// Returns true if `stakePeriodStart` has been explicitly set.
  public var hasStakePeriodStart: Bool {return self._stakePeriodStart != nil}
  /// Clears the value of `stakePeriodStart`. Subsequent reads from it will return its default value.
  public mutating func clearStakePeriodStart() {self._stakePeriodStart = nil}

  ///*
  /// An amount, in tinybar, to be received in the next reward payout.<br/>
  /// Rewards are not paid out immediately; for efficiency reasons rewards are
  /// only paid out as part of another transaction involving that account.
  public var pendingReward: Int64 = 0

  ///*
  /// A proxy-staked balance.<br/>
  /// The total HBAR balance of all accounts that delegate staking to this
  /// account or contract.
  public var stakedToMe: Int64 = 0

  public var stakedID: Proto_StakingInfo.OneOf_StakedID? = nil

  ///*
  /// A delegated stake.
  /// <p>
  /// This account delegates to the indicated account for staking purposes.
  public var stakedAccountID: Proto_AccountID {
    get {
      if case .stakedAccountID(let v)? = stakedID {return v}
      return Proto_AccountID()
    }
    set {stakedID = .stakedAccountID(newValue)}
  }

  ///*
  /// A direct stake.
  /// <p>
  /// This accounts stakes its balance to the designated node.
  public var stakedNodeID: Int64 {
    get {
      if case .stakedNodeID(let v)? = stakedID {return v}
      return 0
    }
    set {stakedID = .stakedNodeID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StakedID: Equatable, Sendable {
    ///*
    /// A delegated stake.
    /// <p>
    /// This account delegates to the indicated account for staking purposes.
    case stakedAccountID(Proto_AccountID)
    ///*
    /// A direct stake.
    /// <p>
    /// This accounts stakes its balance to the designated node.
    case stakedNodeID(Int64)

  }

  public init() {}

  fileprivate var _stakePeriodStart: Proto_Timestamp? = nil
}

///*
/// A unique, composite, identifier for a pending airdrop.
///
/// Each pending airdrop SHALL be uniquely identified by
/// a `PendingAirdropId`.<br/>
/// A `PendingAirdropId` SHALL be recorded when created and MUST be provided in
/// any transaction that would modify that pending airdrop
/// (such as a `claimAirdrop` or `cancelAirdrop`).
public struct Proto_PendingAirdropId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A sending account.
  /// <p>
  /// This is the account that initiated, and SHALL fund,
  /// this pending airdrop.<br/>
  /// This field is REQUIRED.
  public var senderID: Proto_AccountID {
    get {return _senderID ?? Proto_AccountID()}
    set {_senderID = newValue}
  }
  /// Returns true if `senderID` has been explicitly set.
  public var hasSenderID: Bool {return self._senderID != nil}
  /// Clears the value of `senderID`. Subsequent reads from it will return its default value.
  public mutating func clearSenderID() {self._senderID = nil}

  ///*
  /// A receiving account.
  /// <p>
  /// This is the ID of the account that SHALL receive the airdrop.<br/>
  /// This field is REQUIRED.
  public var receiverID: Proto_AccountID {
    get {return _receiverID ?? Proto_AccountID()}
    set {_receiverID = newValue}
  }
  /// Returns true if `receiverID` has been explicitly set.
  public var hasReceiverID: Bool {return self._receiverID != nil}
  /// Clears the value of `receiverID`. Subsequent reads from it will return its default value.
  public mutating func clearReceiverID() {self._receiverID = nil}

  public var tokenReference: Proto_PendingAirdropId.OneOf_TokenReference? = nil

  ///*
  /// A token identifier.<br/>
  /// This is the type of token for a fungible/common token airdrop.
  /// <p>
  /// This field is REQUIRED for a fungible/common token and MUST NOT
  /// be used for a non-fungible/unique token.
  public var fungibleTokenType: Proto_TokenID {
    get {
      if case .fungibleTokenType(let v)? = tokenReference {return v}
      return Proto_TokenID()
    }
    set {tokenReference = .fungibleTokenType(newValue)}
  }

  ///*
  /// The id of a single NFT<br/>
  /// This is the type of token for a non-fungible/unique token airdrop
  /// and consists of a Token ID and serial number.
  /// <p>
  /// This field is REQUIRED for a non-fungible/unique token and
  /// MUST NOT be used for a fungible/common token.
  public var nonFungibleToken: Proto_NftID {
    get {
      if case .nonFungibleToken(let v)? = tokenReference {return v}
      return Proto_NftID()
    }
    set {tokenReference = .nonFungibleToken(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_TokenReference: Equatable, Sendable {
    ///*
    /// A token identifier.<br/>
    /// This is the type of token for a fungible/common token airdrop.
    /// <p>
    /// This field is REQUIRED for a fungible/common token and MUST NOT
    /// be used for a non-fungible/unique token.
    case fungibleTokenType(Proto_TokenID)
    ///*
    /// The id of a single NFT<br/>
    /// This is the type of token for a non-fungible/unique token airdrop
    /// and consists of a Token ID and serial number.
    /// <p>
    /// This field is REQUIRED for a non-fungible/unique token and
    /// MUST NOT be used for a fungible/common token.
    case nonFungibleToken(Proto_NftID)

  }

  public init() {}

  fileprivate var _senderID: Proto_AccountID? = nil
  fileprivate var _receiverID: Proto_AccountID? = nil
}

///*
/// A single pending airdrop value.
///
/// This message SHALL record the airdrop amount for a
/// fungible/common token.<br/>
/// This message SHOULD be null for a non-fungible/unique token.<br/>
/// If a non-null `PendingAirdropValue` is set for a non-fungible/unique
/// token, the amount field MUST be `0`.
///
/// It is RECOMMENDED that implementations store pending airdrop information
/// as a key-value map from `PendingAirdropId` to `PendingAirdropValue`, with
/// a `null` value used for non-fungible pending airdrops.
public struct Proto_PendingAirdropValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// An amount to transfer for fungible/common tokens.<br/>
  /// This is expressed in the smallest available units for that token
  /// (i.e. 10<sup>-`decimals`</sup> whole tokens).
  /// <p>
  /// This amount SHALL be transferred from the sender to the receiver,
  /// if claimed.<br/>
  /// If the token is a fungible/common token, this value MUST be strictly
  /// greater than `0`.<br/>
  /// If the token is a non-fungible/unique token, this message SHOULD NOT
  /// be set, and if set, this field MUST be `0`.
  public var amount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_BlockHashAlgorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHA2_384"),
  ]
}

extension Proto_TokenType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FUNGIBLE_COMMON"),
    1: .same(proto: "NON_FUNGIBLE_UNIQUE"),
  ]
}

extension Proto_SubType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "TOKEN_FUNGIBLE_COMMON"),
    2: .same(proto: "TOKEN_NON_FUNGIBLE_UNIQUE"),
    3: .same(proto: "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES"),
    4: .same(proto: "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES"),
    5: .same(proto: "SCHEDULE_CREATE_CONTRACT_CALL"),
    6: .same(proto: "TOPIC_CREATE_WITH_CUSTOM_FEES"),
    7: .same(proto: "SUBMIT_MESSAGE_WITH_CUSTOM_FEES"),
  ]
}

extension Proto_TokenSupplyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFINITE"),
    1: .same(proto: "FINITE"),
  ]
}

extension Proto_TokenKeyValidation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FULL_VALIDATION"),
    1: .same(proto: "NO_VALIDATION"),
  ]
}

extension Proto_TokenFreezeStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FreezeNotApplicable"),
    1: .same(proto: "Frozen"),
    2: .same(proto: "Unfrozen"),
  ]
}

extension Proto_TokenKycStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KycNotApplicable"),
    1: .same(proto: "Granted"),
    2: .same(proto: "Revoked"),
  ]
}

extension Proto_TokenPauseStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PauseNotApplicable"),
    1: .same(proto: "Paused"),
    2: .same(proto: "Unpaused"),
  ]
}

extension Proto_HederaFunctionality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "CryptoTransfer"),
    2: .same(proto: "CryptoUpdate"),
    3: .same(proto: "CryptoDelete"),
    4: .same(proto: "CryptoAddLiveHash"),
    5: .same(proto: "CryptoDeleteLiveHash"),
    6: .same(proto: "ContractCall"),
    7: .same(proto: "ContractCreate"),
    8: .same(proto: "ContractUpdate"),
    9: .same(proto: "FileCreate"),
    10: .same(proto: "FileAppend"),
    11: .same(proto: "FileUpdate"),
    12: .same(proto: "FileDelete"),
    13: .same(proto: "CryptoGetAccountBalance"),
    14: .same(proto: "CryptoGetAccountRecords"),
    15: .same(proto: "CryptoGetInfo"),
    16: .same(proto: "ContractCallLocal"),
    17: .same(proto: "ContractGetInfo"),
    18: .same(proto: "ContractGetBytecode"),
    19: .same(proto: "GetBySolidityID"),
    20: .same(proto: "GetByKey"),
    21: .same(proto: "CryptoGetLiveHash"),
    22: .same(proto: "CryptoGetStakers"),
    23: .same(proto: "FileGetContents"),
    24: .same(proto: "FileGetInfo"),
    25: .same(proto: "TransactionGetRecord"),
    26: .same(proto: "ContractGetRecords"),
    27: .same(proto: "CryptoCreate"),
    28: .same(proto: "SystemDelete"),
    29: .same(proto: "SystemUndelete"),
    30: .same(proto: "ContractDelete"),
    31: .same(proto: "Freeze"),
    32: .same(proto: "CreateTransactionRecord"),
    33: .same(proto: "CryptoAccountAutoRenew"),
    34: .same(proto: "ContractAutoRenew"),
    35: .same(proto: "GetVersionInfo"),
    36: .same(proto: "TransactionGetReceipt"),
    50: .same(proto: "ConsensusCreateTopic"),
    51: .same(proto: "ConsensusUpdateTopic"),
    52: .same(proto: "ConsensusDeleteTopic"),
    53: .same(proto: "ConsensusGetTopicInfo"),
    54: .same(proto: "ConsensusSubmitMessage"),
    55: .same(proto: "UncheckedSubmit"),
    56: .same(proto: "TokenCreate"),
    58: .same(proto: "TokenGetInfo"),
    59: .same(proto: "TokenFreezeAccount"),
    60: .same(proto: "TokenUnfreezeAccount"),
    61: .same(proto: "TokenGrantKycToAccount"),
    62: .same(proto: "TokenRevokeKycFromAccount"),
    63: .same(proto: "TokenDelete"),
    64: .same(proto: "TokenUpdate"),
    65: .same(proto: "TokenMint"),
    66: .same(proto: "TokenBurn"),
    67: .same(proto: "TokenAccountWipe"),
    68: .same(proto: "TokenAssociateToAccount"),
    69: .same(proto: "TokenDissociateFromAccount"),
    70: .same(proto: "ScheduleCreate"),
    71: .same(proto: "ScheduleDelete"),
    72: .same(proto: "ScheduleSign"),
    73: .same(proto: "ScheduleGetInfo"),
    74: .same(proto: "TokenGetAccountNftInfos"),
    75: .same(proto: "TokenGetNftInfo"),
    76: .same(proto: "TokenGetNftInfos"),
    77: .same(proto: "TokenFeeScheduleUpdate"),
    78: .same(proto: "NetworkGetExecutionTime"),
    79: .same(proto: "TokenPause"),
    80: .same(proto: "TokenUnpause"),
    81: .same(proto: "CryptoApproveAllowance"),
    82: .same(proto: "CryptoDeleteAllowance"),
    83: .same(proto: "GetAccountDetails"),
    84: .same(proto: "EthereumTransaction"),
    85: .same(proto: "NodeStakeUpdate"),
    86: .same(proto: "UtilPrng"),
    87: .same(proto: "TransactionGetFastRecord"),
    88: .same(proto: "TokenUpdateNfts"),
    89: .same(proto: "NodeCreate"),
    90: .same(proto: "NodeUpdate"),
    91: .same(proto: "NodeDelete"),
    92: .same(proto: "TokenReject"),
    93: .same(proto: "TokenAirdrop"),
    94: .same(proto: "TokenCancelAirdrop"),
    95: .same(proto: "TokenClaimAirdrop"),
    100: .same(proto: "StateSignatureTransaction"),
    101: .same(proto: "HintsKeyPublication"),
    102: .same(proto: "HintsPreprocessingVote"),
    103: .same(proto: "HintsPartialSignature"),
    104: .same(proto: "HistoryAssemblySignature"),
    105: .same(proto: "HistoryProofKeyPublication"),
    106: .same(proto: "HistoryProofVote"),
    107: .same(proto: "CrsPublication"),
    108: .same(proto: "AtomicBatch"),
    109: .same(proto: "LambdaSStore"),
    110: .same(proto: "HookDispatch"),
  ]
}

extension Proto_ShardID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShardID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ShardID, rhs: Proto_ShardID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RealmID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RealmID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_RealmID, rhs: Proto_RealmID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "tokenNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.tokenNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.tokenNum != 0 {
      try visitor.visitSingularInt64Field(value: self.tokenNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenID, rhs: Proto_TokenID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.tokenNum != rhs.tokenNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "accountNum"),
    4: .same(proto: "alias"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.account != nil {try decoder.handleConflictingOneOf()}
          self.account = .accountNum(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.account != nil {try decoder.handleConflictingOneOf()}
          self.account = .alias(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    switch self.account {
    case .accountNum?: try {
      guard case .accountNum(let v)? = self.account else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .alias?: try {
      guard case .alias(let v)? = self.account else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AccountID, rhs: Proto_AccountID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NftID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NftID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_ID"),
    2: .standard(proto: "serial_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.serialNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.serialNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.serialNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NftID, rhs: Proto_NftID) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs.serialNumber != rhs.serialNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FileID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "fileNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fileNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.fileNum != 0 {
      try visitor.visitSingularInt64Field(value: self.fileNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FileID, rhs: Proto_FileID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.fileNum != rhs.fileNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ContractID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContractID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "contractNum"),
    4: .standard(proto: "evm_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.contract != nil {try decoder.handleConflictingOneOf()}
          self.contract = .contractNum(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.contract != nil {try decoder.handleConflictingOneOf()}
          self.contract = .evmAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    switch self.contract {
    case .contractNum?: try {
      guard case .contractNum(let v)? = self.contract else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .evmAddress?: try {
      guard case .evmAddress(let v)? = self.contract else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ContractID, rhs: Proto_ContractID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TopicID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "topicNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.topicNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.topicNum != 0 {
      try visitor.visitSingularInt64Field(value: self.topicNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TopicID, rhs: Proto_TopicID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.topicNum != rhs.topicNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ScheduleID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScheduleID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shardNum"),
    2: .same(proto: "realmNum"),
    3: .same(proto: "scheduleNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.shardNum) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.realmNum) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.scheduleNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardNum != 0 {
      try visitor.visitSingularInt64Field(value: self.shardNum, fieldNumber: 1)
    }
    if self.realmNum != 0 {
      try visitor.visitSingularInt64Field(value: self.realmNum, fieldNumber: 2)
    }
    if self.scheduleNum != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduleNum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ScheduleID, rhs: Proto_ScheduleID) -> Bool {
    if lhs.shardNum != rhs.shardNum {return false}
    if lhs.realmNum != rhs.realmNum {return false}
    if lhs.scheduleNum != rhs.scheduleNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionValidStart"),
    2: .same(proto: "accountID"),
    3: .same(proto: "scheduled"),
    4: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transactionValidStart) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.scheduled) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transactionValidStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.scheduled != false {
      try visitor.visitSingularBoolField(value: self.scheduled, fieldNumber: 3)
    }
    if self.nonce != 0 {
      try visitor.visitSingularInt32Field(value: self.nonce, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionID, rhs: Proto_TransactionID) -> Bool {
    if lhs._transactionValidStart != rhs._transactionValidStart {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs.scheduled != rhs.scheduled {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_HookId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HookId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .standard(proto: "hook_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entityID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.hookID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entityID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.hookID != 0 {
      try visitor.visitSingularInt64Field(value: self.hookID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_HookId, rhs: Proto_HookId) -> Bool {
    if lhs._entityID != rhs._entityID {return false}
    if lhs.hookID != rhs.hookID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_HookEntityId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HookEntityId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "contract_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_AccountID?
        var hadOneofValue = false
        if let current = self.entityID {
          hadOneofValue = true
          if case .accountID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entityID = .accountID(v)
        }
      }()
      case 2: try {
        var v: Proto_ContractID?
        var hadOneofValue = false
        if let current = self.entityID {
          hadOneofValue = true
          if case .contractID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entityID = .contractID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.entityID {
    case .accountID?: try {
      guard case .accountID(let v)? = self.entityID else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .contractID?: try {
      guard case .contractID(let v)? = self.entityID else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_HookEntityId, rhs: Proto_HookEntityId) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_HookCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HookCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_hook_id"),
    2: .standard(proto: "hook_id"),
    3: .standard(proto: "evm_hook_call"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_HookId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .fullHookID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .fullHookID(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .hookID(v)
        }
      }()
      case 3: try {
        var v: Proto_EvmHookCall?
        var hadOneofValue = false
        if let current = self.callSpec {
          hadOneofValue = true
          if case .evmHookCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callSpec = .evmHookCall(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .fullHookID?: try {
      guard case .fullHookID(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .hookID?: try {
      guard case .hookID(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if case .evmHookCall(let v)? = self.callSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_HookCall, rhs: Proto_HookCall) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.callSpec != rhs.callSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EvmHookCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvmHookCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "gas_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.gasLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.gasLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasLimit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_EvmHookCall, rhs: Proto_EvmHookCall) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.gasLimit != rhs.gasLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccountAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountAmount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountID"),
    2: .same(proto: "amount"),
    3: .standard(proto: "is_approval"),
    4: .standard(proto: "pre_tx_allowance_hook"),
    5: .standard(proto: "pre_post_tx_allowance_hook"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 2: try { try decoder.decodeSingularSInt64Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isApproval) }()
      case 4: try {
        var v: Proto_HookCall?
        var hadOneofValue = false
        if let current = self.hookCall {
          hadOneofValue = true
          if case .preTxAllowanceHook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hookCall = .preTxAllowanceHook(v)
        }
      }()
      case 5: try {
        var v: Proto_HookCall?
        var hadOneofValue = false
        if let current = self.hookCall {
          hadOneofValue = true
          if case .prePostTxAllowanceHook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hookCall = .prePostTxAllowanceHook(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularSInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.isApproval != false {
      try visitor.visitSingularBoolField(value: self.isApproval, fieldNumber: 3)
    }
    switch self.hookCall {
    case .preTxAllowanceHook?: try {
      guard case .preTxAllowanceHook(let v)? = self.hookCall else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .prePostTxAllowanceHook?: try {
      guard case .prePostTxAllowanceHook(let v)? = self.hookCall else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_AccountAmount, rhs: Proto_AccountAmount) -> Bool {
    if lhs._accountID != rhs._accountID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.isApproval != rhs.isApproval {return false}
    if lhs.hookCall != rhs.hookCall {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransferList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountAmounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accountAmounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountAmounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountAmounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransferList, rhs: Proto_TransferList) -> Bool {
    if lhs.accountAmounts != rhs.accountAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NftTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NftTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderAccountID"),
    2: .same(proto: "receiverAccountID"),
    3: .same(proto: "serialNumber"),
    4: .standard(proto: "is_approval"),
    5: .standard(proto: "pre_tx_sender_allowance_hook"),
    6: .standard(proto: "pre_post_tx_sender_allowance_hook"),
    7: .standard(proto: "pre_tx_receiver_allowance_hook"),
    8: .standard(proto: "pre_post_tx_receiver_allowance_hook"),
  ]

  fileprivate class _StorageClass {
    var _senderAccountID: Proto_AccountID? = nil
    var _receiverAccountID: Proto_AccountID? = nil
    var _serialNumber: Int64 = 0
    var _isApproval: Bool = false
    var _senderAllowanceHookCall: Proto_NftTransfer.OneOf_SenderAllowanceHookCall?
    var _receiverAllowanceHookCall: Proto_NftTransfer.OneOf_ReceiverAllowanceHookCall?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _senderAccountID = source._senderAccountID
      _receiverAccountID = source._receiverAccountID
      _serialNumber = source._serialNumber
      _isApproval = source._isApproval
      _senderAllowanceHookCall = source._senderAllowanceHookCall
      _receiverAllowanceHookCall = source._receiverAllowanceHookCall
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._senderAccountID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._receiverAccountID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._serialNumber) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._isApproval) }()
        case 5: try {
          var v: Proto_HookCall?
          var hadOneofValue = false
          if let current = _storage._senderAllowanceHookCall {
            hadOneofValue = true
            if case .preTxSenderAllowanceHook(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._senderAllowanceHookCall = .preTxSenderAllowanceHook(v)
          }
        }()
        case 6: try {
          var v: Proto_HookCall?
          var hadOneofValue = false
          if let current = _storage._senderAllowanceHookCall {
            hadOneofValue = true
            if case .prePostTxSenderAllowanceHook(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._senderAllowanceHookCall = .prePostTxSenderAllowanceHook(v)
          }
        }()
        case 7: try {
          var v: Proto_HookCall?
          var hadOneofValue = false
          if let current = _storage._receiverAllowanceHookCall {
            hadOneofValue = true
            if case .preTxReceiverAllowanceHook(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._receiverAllowanceHookCall = .preTxReceiverAllowanceHook(v)
          }
        }()
        case 8: try {
          var v: Proto_HookCall?
          var hadOneofValue = false
          if let current = _storage._receiverAllowanceHookCall {
            hadOneofValue = true
            if case .prePostTxReceiverAllowanceHook(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._receiverAllowanceHookCall = .prePostTxReceiverAllowanceHook(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._senderAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._receiverAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._serialNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._serialNumber, fieldNumber: 3)
      }
      if _storage._isApproval != false {
        try visitor.visitSingularBoolField(value: _storage._isApproval, fieldNumber: 4)
      }
      switch _storage._senderAllowanceHookCall {
      case .preTxSenderAllowanceHook?: try {
        guard case .preTxSenderAllowanceHook(let v)? = _storage._senderAllowanceHookCall else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .prePostTxSenderAllowanceHook?: try {
        guard case .prePostTxSenderAllowanceHook(let v)? = _storage._senderAllowanceHookCall else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
      switch _storage._receiverAllowanceHookCall {
      case .preTxReceiverAllowanceHook?: try {
        guard case .preTxReceiverAllowanceHook(let v)? = _storage._receiverAllowanceHookCall else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .prePostTxReceiverAllowanceHook?: try {
        guard case .prePostTxReceiverAllowanceHook(let v)? = _storage._receiverAllowanceHookCall else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NftTransfer, rhs: Proto_NftTransfer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._senderAccountID != rhs_storage._senderAccountID {return false}
        if _storage._receiverAccountID != rhs_storage._receiverAccountID {return false}
        if _storage._serialNumber != rhs_storage._serialNumber {return false}
        if _storage._isApproval != rhs_storage._isApproval {return false}
        if _storage._senderAllowanceHookCall != rhs_storage._senderAllowanceHookCall {return false}
        if _storage._receiverAllowanceHookCall != rhs_storage._receiverAllowanceHookCall {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenTransferList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenTransferList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "transfers"),
    3: .same(proto: "nftTransfers"),
    4: .standard(proto: "expected_decimals"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transfers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nftTransfers) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expectedDecimals) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transfers, fieldNumber: 2)
    }
    if !self.nftTransfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nftTransfers, fieldNumber: 3)
    }
    try { if let v = self._expectedDecimals {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenTransferList, rhs: Proto_TokenTransferList) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.transfers != rhs.transfers {return false}
    if lhs.nftTransfers != rhs.nftTransfers {return false}
    if lhs._expectedDecimals != rhs._expectedDecimals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Fraction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Fraction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numerator"),
    2: .same(proto: "denominator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.numerator) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.denominator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numerator != 0 {
      try visitor.visitSingularInt64Field(value: self.numerator, fieldNumber: 1)
    }
    if self.denominator != 0 {
      try visitor.visitSingularInt64Field(value: self.denominator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Fraction, rhs: Proto_Fraction) -> Bool {
    if lhs.numerator != rhs.numerator {return false}
    if lhs.denominator != rhs.denominator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractID"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdKey"),
    6: .same(proto: "keyList"),
    7: .standard(proto: "ECDSA_secp256k1"),
    8: .standard(proto: "delegatable_contract_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_ContractID?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .contractID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .contractID(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .ed25519(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .rsa3072(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .ecdsa384(v)
        }
      }()
      case 5: try {
        var v: Proto_ThresholdKey?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .thresholdKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .thresholdKey(v)
        }
      }()
      case 6: try {
        var v: Proto_KeyList?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .keyList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .keyList(v)
        }
      }()
      case 7: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .ecdsaSecp256K1(v)
        }
      }()
      case 8: try {
        var v: Proto_ContractID?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .delegatableContractID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .delegatableContractID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.key {
    case .contractID?: try {
      guard case .contractID(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ed25519?: try {
      guard case .ed25519(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .rsa3072?: try {
      guard case .rsa3072(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .ecdsa384?: try {
      guard case .ecdsa384(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .thresholdKey?: try {
      guard case .thresholdKey(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .keyList?: try {
      guard case .keyList(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .ecdsaSecp256K1?: try {
      guard case .ecdsaSecp256K1(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }()
    case .delegatableContractID?: try {
      guard case .delegatableContractID(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Key, rhs: Proto_Key) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.threshold) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.threshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.threshold, fieldNumber: 1)
    }
    try { if let v = self._keys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ThresholdKey, rhs: Proto_ThresholdKey) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs._keys != rhs._keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_KeyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_KeyList, rhs: Proto_KeyList) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Signature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contract"),
    2: .same(proto: "ed25519"),
    3: .standard(proto: "RSA_3072"),
    4: .standard(proto: "ECDSA_384"),
    5: .same(proto: "thresholdSignature"),
    6: .same(proto: "signatureList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .contract(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ed25519(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .rsa3072(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ecdsa384(v)
        }
      }()
      case 5: try {
        var v: Proto_ThresholdSignature?
        var hadOneofValue = false
        if let current = self.signature {
          hadOneofValue = true
          if case .thresholdSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signature = .thresholdSignature(v)
        }
      }()
      case 6: try {
        var v: Proto_SignatureList?
        var hadOneofValue = false
        if let current = self.signature {
          hadOneofValue = true
          if case .signatureList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signature = .signatureList(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.signature {
    case .contract?: try {
      guard case .contract(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .ed25519?: try {
      guard case .ed25519(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .rsa3072?: try {
      guard case .rsa3072(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .ecdsa384?: try {
      guard case .ecdsa384(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .thresholdSignature?: try {
      guard case .thresholdSignature(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .signatureList?: try {
      guard case .signatureList(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Signature, rhs: Proto_Signature) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ThresholdSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sigs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sigs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ThresholdSignature, rhs: Proto_ThresholdSignature) -> Bool {
    if lhs._sigs != rhs._sigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignatureList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignatureList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sigs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sigs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sigs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignatureList, rhs: Proto_SignatureList) -> Bool {
    if lhs.sigs != rhs.sigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignaturePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignaturePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubKeyPrefix"),
    2: .same(proto: "contract"),
    3: .same(proto: "ed25519"),
    4: .standard(proto: "RSA_3072"),
    5: .standard(proto: "ECDSA_384"),
    6: .standard(proto: "ECDSA_secp256k1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pubKeyPrefix) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .contract(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ed25519(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .rsa3072(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ecdsa384(v)
        }
      }()
      case 6: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signature != nil {try decoder.handleConflictingOneOf()}
          self.signature = .ecdsaSecp256K1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pubKeyPrefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKeyPrefix, fieldNumber: 1)
    }
    switch self.signature {
    case .contract?: try {
      guard case .contract(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .ed25519?: try {
      guard case .ed25519(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .rsa3072?: try {
      guard case .rsa3072(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .ecdsa384?: try {
      guard case .ecdsa384(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case .ecdsaSecp256K1?: try {
      guard case .ecdsaSecp256K1(let v)? = self.signature else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignaturePair, rhs: Proto_SignaturePair) -> Bool {
    if lhs.pubKeyPrefix != rhs.pubKeyPrefix {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SignatureMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignatureMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sigPair"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sigPair) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sigPair.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sigPair, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SignatureMap, rhs: Proto_SignatureMap) -> Bool {
    if lhs.sigPair != rhs.sigPair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeComponents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeeComponents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
    3: .same(proto: "constant"),
    4: .same(proto: "bpt"),
    5: .same(proto: "vpt"),
    6: .same(proto: "rbh"),
    7: .same(proto: "sbh"),
    8: .same(proto: "gas"),
    9: .same(proto: "tv"),
    10: .same(proto: "bpr"),
    11: .same(proto: "sbpr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.min) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.max) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.constant) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.bpt) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.vpt) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.rbh) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.sbh) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.gas) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.tv) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.bpr) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.sbpr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularInt64Field(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularInt64Field(value: self.max, fieldNumber: 2)
    }
    if self.constant != 0 {
      try visitor.visitSingularInt64Field(value: self.constant, fieldNumber: 3)
    }
    if self.bpt != 0 {
      try visitor.visitSingularInt64Field(value: self.bpt, fieldNumber: 4)
    }
    if self.vpt != 0 {
      try visitor.visitSingularInt64Field(value: self.vpt, fieldNumber: 5)
    }
    if self.rbh != 0 {
      try visitor.visitSingularInt64Field(value: self.rbh, fieldNumber: 6)
    }
    if self.sbh != 0 {
      try visitor.visitSingularInt64Field(value: self.sbh, fieldNumber: 7)
    }
    if self.gas != 0 {
      try visitor.visitSingularInt64Field(value: self.gas, fieldNumber: 8)
    }
    if self.tv != 0 {
      try visitor.visitSingularInt64Field(value: self.tv, fieldNumber: 9)
    }
    if self.bpr != 0 {
      try visitor.visitSingularInt64Field(value: self.bpr, fieldNumber: 10)
    }
    if self.sbpr != 0 {
      try visitor.visitSingularInt64Field(value: self.sbpr, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FeeComponents, rhs: Proto_FeeComponents) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.constant != rhs.constant {return false}
    if lhs.bpt != rhs.bpt {return false}
    if lhs.vpt != rhs.vpt {return false}
    if lhs.rbh != rhs.rbh {return false}
    if lhs.sbh != rhs.sbh {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.tv != rhs.tv {return false}
    if lhs.bpr != rhs.bpr {return false}
    if lhs.sbpr != rhs.sbpr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionFeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionFeeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hederaFunctionality"),
    2: .same(proto: "feeData"),
    3: .same(proto: "fees"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hederaFunctionality) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._feeData) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fees) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.hederaFunctionality != .none {
      try visitor.visitSingularEnumField(value: self.hederaFunctionality, fieldNumber: 1)
    }
    try { if let v = self._feeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.fees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fees, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionFeeSchedule, rhs: Proto_TransactionFeeSchedule) -> Bool {
    if lhs.hederaFunctionality != rhs.hederaFunctionality {return false}
    if lhs._feeData != rhs._feeData {return false}
    if lhs.fees != rhs.fees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeeData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodedata"),
    2: .same(proto: "networkdata"),
    3: .same(proto: "servicedata"),
    4: .same(proto: "subType"),
  ]

  fileprivate class _StorageClass {
    var _nodedata: Proto_FeeComponents? = nil
    var _networkdata: Proto_FeeComponents? = nil
    var _servicedata: Proto_FeeComponents? = nil
    var _subType: Proto_SubType = .default

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _nodedata = source._nodedata
      _networkdata = source._networkdata
      _servicedata = source._servicedata
      _subType = source._subType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._nodedata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._networkdata) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._servicedata) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._subType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._nodedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._networkdata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._servicedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._subType != .default {
        try visitor.visitSingularEnumField(value: _storage._subType, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FeeData, rhs: Proto_FeeData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nodedata != rhs_storage._nodedata {return false}
        if _storage._networkdata != rhs_storage._networkdata {return false}
        if _storage._servicedata != rhs_storage._servicedata {return false}
        if _storage._subType != rhs_storage._subType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionFeeSchedule"),
    2: .same(proto: "expiryTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactionFeeSchedule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expiryTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transactionFeeSchedule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactionFeeSchedule, fieldNumber: 1)
    }
    try { if let v = self._expiryTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_FeeSchedule, rhs: Proto_FeeSchedule) -> Bool {
    if lhs.transactionFeeSchedule != rhs.transactionFeeSchedule {return false}
    if lhs._expiryTime != rhs._expiryTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CurrentAndNextFeeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrentAndNextFeeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currentFeeSchedule"),
    2: .same(proto: "nextFeeSchedule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentFeeSchedule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nextFeeSchedule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentFeeSchedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nextFeeSchedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_CurrentAndNextFeeSchedule, rhs: Proto_CurrentAndNextFeeSchedule) -> Bool {
    if lhs._currentFeeSchedule != rhs._currentFeeSchedule {return false}
    if lhs._nextFeeSchedule != rhs._nextFeeSchedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ServiceEndpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceEndpoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ipAddressV4"),
    2: .same(proto: "port"),
    3: .standard(proto: "domain_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ipAddressV4) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.domainName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ipAddressV4.isEmpty {
      try visitor.visitSingularBytesField(value: self.ipAddressV4, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 2)
    }
    if !self.domainName.isEmpty {
      try visitor.visitSingularStringField(value: self.domainName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ServiceEndpoint, rhs: Proto_ServiceEndpoint) -> Bool {
    if lhs.ipAddressV4 != rhs.ipAddressV4 {return false}
    if lhs.port != rhs.port {return false}
    if lhs.domainName != rhs.domainName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ipAddress"),
    2: .same(proto: "portno"),
    3: .same(proto: "memo"),
    4: .standard(proto: "RSA_PubKey"),
    5: .same(proto: "nodeId"),
    6: .same(proto: "nodeAccountId"),
    7: .same(proto: "nodeCertHash"),
    8: .same(proto: "serviceEndpoint"),
    9: .same(proto: "description"),
    10: .same(proto: "stake"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ipAddress) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.portno) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.memo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rsaPubKey) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.nodeID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._nodeAccountID) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nodeCertHash) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.serviceEndpoint) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.stake) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ipAddress, fieldNumber: 1)
    }
    if self.portno != 0 {
      try visitor.visitSingularInt32Field(value: self.portno, fieldNumber: 2)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularBytesField(value: self.memo, fieldNumber: 3)
    }
    if !self.rsaPubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.rsaPubKey, fieldNumber: 4)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.nodeID, fieldNumber: 5)
    }
    try { if let v = self._nodeAccountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nodeCertHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeCertHash, fieldNumber: 7)
    }
    if !self.serviceEndpoint.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceEndpoint, fieldNumber: 8)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 9)
    }
    if self.stake != 0 {
      try visitor.visitSingularInt64Field(value: self.stake, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeAddress, rhs: Proto_NodeAddress) -> Bool {
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.portno != rhs.portno {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.rsaPubKey != rhs.rsaPubKey {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs._nodeAccountID != rhs._nodeAccountID {return false}
    if lhs.nodeCertHash != rhs.nodeCertHash {return false}
    if lhs.serviceEndpoint != rhs.serviceEndpoint {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.stake != rhs.stake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeAddressBook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeAddressBook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodeAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeAddress.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeAddressBook, rhs: Proto_NodeAddressBook) -> Bool {
    if lhs.nodeAddress != rhs.nodeAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SemanticVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SemanticVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "major"),
    2: .same(proto: "minor"),
    3: .same(proto: "patch"),
    4: .same(proto: "pre"),
    5: .same(proto: "build"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.major) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minor) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.patch) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pre) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.build) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.major != 0 {
      try visitor.visitSingularInt32Field(value: self.major, fieldNumber: 1)
    }
    if self.minor != 0 {
      try visitor.visitSingularInt32Field(value: self.minor, fieldNumber: 2)
    }
    if self.patch != 0 {
      try visitor.visitSingularInt32Field(value: self.patch, fieldNumber: 3)
    }
    if !self.pre.isEmpty {
      try visitor.visitSingularStringField(value: self.pre, fieldNumber: 4)
    }
    if !self.build.isEmpty {
      try visitor.visitSingularStringField(value: self.build, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_SemanticVersion, rhs: Proto_SemanticVersion) -> Bool {
    if lhs.major != rhs.major {return false}
    if lhs.minor != rhs.minor {return false}
    if lhs.patch != rhs.patch {return false}
    if lhs.pre != rhs.pre {return false}
    if lhs.build != rhs.build {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Setting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Setting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_Setting, rhs: Proto_Setting) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ServicesConfigurationList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServicesConfigurationList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nameValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nameValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nameValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nameValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ServicesConfigurationList, rhs: Proto_ServicesConfigurationList) -> Bool {
    if lhs.nameValue != rhs.nameValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenRelationship: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenRelationship"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenId"),
    2: .same(proto: "symbol"),
    3: .same(proto: "balance"),
    4: .same(proto: "kycStatus"),
    5: .same(proto: "freezeStatus"),
    6: .same(proto: "decimals"),
    7: .standard(proto: "automatic_association"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.balance) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.kycStatus) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.freezeStatus) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.automaticAssociation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if self.balance != 0 {
      try visitor.visitSingularUInt64Field(value: self.balance, fieldNumber: 3)
    }
    if self.kycStatus != .kycNotApplicable {
      try visitor.visitSingularEnumField(value: self.kycStatus, fieldNumber: 4)
    }
    if self.freezeStatus != .freezeNotApplicable {
      try visitor.visitSingularEnumField(value: self.freezeStatus, fieldNumber: 5)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 6)
    }
    if self.automaticAssociation != false {
      try visitor.visitSingularBoolField(value: self.automaticAssociation, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenRelationship, rhs: Proto_TokenRelationship) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.kycStatus != rhs.kycStatus {return false}
    if lhs.freezeStatus != rhs.freezeStatus {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.automaticAssociation != rhs.automaticAssociation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenBalance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenId"),
    2: .same(proto: "balance"),
    3: .same(proto: "decimals"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.balance) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.decimals) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.balance != 0 {
      try visitor.visitSingularUInt64Field(value: self.balance, fieldNumber: 2)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimals, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenBalance, rhs: Proto_TokenBalance) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenBalances: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenBalances"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenBalances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokenBalances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenBalances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenBalances, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenBalances, rhs: Proto_TokenBalances) -> Bool {
    if lhs.tokenBalances != rhs.tokenBalances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TokenAssociation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenAssociation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TokenAssociation, rhs: Proto_TokenAssociation) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_StakingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakingInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "decline_reward"),
    2: .standard(proto: "stake_period_start"),
    3: .standard(proto: "pending_reward"),
    4: .standard(proto: "staked_to_me"),
    5: .standard(proto: "staked_account_id"),
    6: .standard(proto: "staked_node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.declineReward) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stakePeriodStart) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pendingReward) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.stakedToMe) }()
      case 5: try {
        var v: Proto_AccountID?
        var hadOneofValue = false
        if let current = self.stakedID {
          hadOneofValue = true
          if case .stakedAccountID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stakedID = .stakedAccountID(v)
        }
      }()
      case 6: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.stakedID != nil {try decoder.handleConflictingOneOf()}
          self.stakedID = .stakedNodeID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.declineReward != false {
      try visitor.visitSingularBoolField(value: self.declineReward, fieldNumber: 1)
    }
    try { if let v = self._stakePeriodStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pendingReward != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingReward, fieldNumber: 3)
    }
    if self.stakedToMe != 0 {
      try visitor.visitSingularInt64Field(value: self.stakedToMe, fieldNumber: 4)
    }
    switch self.stakedID {
    case .stakedAccountID?: try {
      guard case .stakedAccountID(let v)? = self.stakedID else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .stakedNodeID?: try {
      guard case .stakedNodeID(let v)? = self.stakedID else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_StakingInfo, rhs: Proto_StakingInfo) -> Bool {
    if lhs.declineReward != rhs.declineReward {return false}
    if lhs._stakePeriodStart != rhs._stakePeriodStart {return false}
    if lhs.pendingReward != rhs.pendingReward {return false}
    if lhs.stakedToMe != rhs.stakedToMe {return false}
    if lhs.stakedID != rhs.stakedID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PendingAirdropId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PendingAirdropId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sender_id"),
    2: .standard(proto: "receiver_id"),
    3: .standard(proto: "fungible_token_type"),
    4: .standard(proto: "non_fungible_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._senderID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._receiverID) }()
      case 3: try {
        var v: Proto_TokenID?
        var hadOneofValue = false
        if let current = self.tokenReference {
          hadOneofValue = true
          if case .fungibleTokenType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenReference = .fungibleTokenType(v)
        }
      }()
      case 4: try {
        var v: Proto_NftID?
        var hadOneofValue = false
        if let current = self.tokenReference {
          hadOneofValue = true
          if case .nonFungibleToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenReference = .nonFungibleToken(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._senderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._receiverID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.tokenReference {
    case .fungibleTokenType?: try {
      guard case .fungibleTokenType(let v)? = self.tokenReference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .nonFungibleToken?: try {
      guard case .nonFungibleToken(let v)? = self.tokenReference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PendingAirdropId, rhs: Proto_PendingAirdropId) -> Bool {
    if lhs._senderID != rhs._senderID {return false}
    if lhs._receiverID != rhs._receiverID {return false}
    if lhs.tokenReference != rhs.tokenReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PendingAirdropValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PendingAirdropValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_PendingAirdropValue, rhs: Proto_PendingAirdropValue) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
