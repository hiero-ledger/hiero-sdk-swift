// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/schedule_create.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Schedule Create
/// Message to create a schedule, which is an instruction to execute some other
/// transaction (the scheduled transaction) at a future time, either when
/// enough signatures are gathered (short term) or when the schedule expires
/// (long term). In all cases the scheduled transaction is not executed if
/// signature requirements are not met before the schedule expires.
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Create a new Schedule.
///
/// #### Requirements
/// This transaction SHALL create a new _schedule_ entity in network state.<br/>
/// The schedule created SHALL contain the `scheduledTransactionBody` to be
/// executed.<br/>
/// If successful the receipt SHALL contain a `scheduleID` with the full
/// identifier of the schedule created.<br/>
/// When a schedule _executes_ successfully, the receipt SHALL include a
/// `scheduledTransactionID` with the `TransactionID` of the transaction that
/// executed.<br/>
/// When a scheduled transaction is executed the network SHALL charge the
/// regular _service_ fee for the transaction to the `payerAccountID` for
/// that schedule, but SHALL NOT charge node or network fees.<br/>
/// If the `payerAccountID` field is not set, the effective `payerAccountID`
/// SHALL be the `payer` for this create transaction.<br/>
/// If an `adminKey` is not specified, or is an empty `KeyList`, the schedule
/// created SHALL be immutable.<br/>
/// An immutable schedule MAY be signed, and MAY execute, but SHALL NOT be
/// deleted.<br/>
/// If two schedules have the same values for all fields except `payerAccountID`
/// then those two schedules SHALL be deemed "identical".<br/>
/// If a `scheduleCreate` requests a new schedule that is identical to an
/// existing schedule, the transaction SHALL fail and SHALL return a status
/// code of `IDENTICAL_SCHEDULE_ALREADY_CREATED` in the receipt.<br/>
/// The receipt for a duplicate schedule SHALL include the `ScheduleID` of the
/// existing schedule and the `TransactionID` of the earlier `scheduleCreate`
/// so that the earlier schedule may be queried and/or referred to in a
/// subsequent `scheduleSign`.
///
/// #### Signature Requirements
/// A `scheduleSign` transaction SHALL be used to add additional signatures
/// to an existing schedule.<br/>
/// Each signature SHALL "activate" the corresponding cryptographic("primitive")
/// key for that schedule.<br/>
/// Signature requirements SHALL be met when the set of active keys includes
/// all keys required by the scheduled transaction.<br/>
/// A scheduled transaction for a "long term" schedule SHALL NOT execute if
/// the signature requirements for that transaction are not met when the
/// network consensus time reaches the schedule `expiration_time`.<br/>
/// A "short term" schedule SHALL execute immediately once signature
/// requirements are met. This MAY be immediately when created.
///
/// #### Long Term Schedules
/// A "short term" schedule SHALL have the flag `wait_for_expiry` _unset_.<br/>
/// A "long term" schedule SHALL have the flag  `wait_for_expiry` _set_.<br/>
/// A "long term" schedule SHALL NOT be accepted if the network configuration
/// `scheduling.longTermEnabled` is not enabled.<br/>
/// A "long term" schedule SHALL execute when the current consensus time
/// matches or exceeds the `expiration_time` for that schedule, if the
/// signature requirements for the scheduled transaction
/// are met at that instant.<br/>
/// A "long term" schedule SHALL NOT execute before the current consensus time
/// matches or exceeds the `expiration_time` for that schedule.<br/>
/// A "long term" schedule SHALL expire, and be removed from state, after the
/// network consensus time exceeds the schedule `expiration_time`.<br/>
/// A short term schedule SHALL expire, and be removed from state,
/// after the network consensus time exceeds the current network
/// configuration for `ledger.scheduleTxExpiryTimeSecs`.
///
/// > Note
/// >> Long term schedules are not (as of release 0.56.0) enabled. Any schedule
/// >> created currently MUST NOT set the `wait_for_expiry` flag.<br/>
/// >> When long term schedules are not enabled, schedules SHALL NOT be
/// >> executed at expiration, and MUST meet signature requirements strictly
/// >> before expiration to be executed.
///
/// ### Block Stream Effects
/// If the scheduled transaction is executed immediately, the transaction
/// record SHALL include a `scheduleRef` with the schedule identifier of the
/// schedule created.
public struct Proto_ScheduleCreateTransactionBody: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A scheduled transaction.
  /// <p>
  /// This value is REQUIRED.<br/>
  /// This transaction body MUST be one of the types enabled in the
  /// network configuration value `scheduling.whitelist`.
  public var scheduledTransactionBody: Proto_SchedulableTransactionBody {
    get {return _scheduledTransactionBody ?? Proto_SchedulableTransactionBody()}
    set {_scheduledTransactionBody = newValue}
  }
  /// Returns true if `scheduledTransactionBody` has been explicitly set.
  public var hasScheduledTransactionBody: Bool {return self._scheduledTransactionBody != nil}
  /// Clears the value of `scheduledTransactionBody`. Subsequent reads from it will return its default value.
  public mutating func clearScheduledTransactionBody() {self._scheduledTransactionBody = nil}

  ///*
  /// A short description of the schedule.
  /// <p>
  /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
  /// (default 100) bytes when encoded as UTF-8.
  public var memo: String = String()

  ///*
  /// A `Key` required to delete this schedule.
  /// <p>
  /// If this is not set, or is an empty `KeyList`, this schedule SHALL be
  /// immutable and SHALL NOT be deleted.
  public var adminKey: Proto_Key {
    get {return _adminKey ?? Proto_Key()}
    set {_adminKey = newValue}
  }
  /// Returns true if `adminKey` has been explicitly set.
  public var hasAdminKey: Bool {return self._adminKey != nil}
  /// Clears the value of `adminKey`. Subsequent reads from it will return its default value.
  public mutating func clearAdminKey() {self._adminKey = nil}

  ///*
  /// An account identifier of a `payer` for the scheduled transaction.
  /// <p>
  /// This value MAY be unset. If unset, the `payer` for this `scheduleCreate`
  /// transaction SHALL be the `payer` for the scheduled transaction.<br/>
  /// If this is set, the identified account SHALL be charged the fees
  /// required for the scheduled transaction when it is executed.<br/>
  /// If the actual `payer` for the _scheduled_ transaction lacks
  /// sufficient HBAR balance to pay service fees for the scheduled
  /// transaction _when it executes_, the scheduled transaction
  /// SHALL fail with `INSUFFICIENT_PAYER_BALANCE`.<br/>
  public var payerAccountID: Proto_AccountID {
    get {return _payerAccountID ?? Proto_AccountID()}
    set {_payerAccountID = newValue}
  }
  /// Returns true if `payerAccountID` has been explicitly set.
  public var hasPayerAccountID: Bool {return self._payerAccountID != nil}
  /// Clears the value of `payerAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearPayerAccountID() {self._payerAccountID = nil}

  ///*
  /// An expiration time.
  /// <p>
  /// If not set, the expiration SHALL default to the current consensus time
  /// advanced by either the network configuration value
  /// `scheduling.maxExpirationFutureSeconds`, if `wait_for_expiry` is set and
  /// "long term" schedules are enabled, or the network configuration value
  /// `ledger.scheduleTxExpiryTimeSecs` otherwise.
  public var expirationTime: Proto_Timestamp {
    get {return _expirationTime ?? Proto_Timestamp()}
    set {_expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  public var hasExpirationTime: Bool {return self._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationTime() {self._expirationTime = nil}

  ///*
  /// A flag to delay execution until expiration.
  /// <p>
  /// If this flag is set the scheduled transaction SHALL NOT be evaluated for
  /// execution before the network consensus time matches or exceeds the
  /// `expiration_time`.<br/>
  /// If this flag is not set, the scheduled transaction SHALL be executed
  /// immediately when all required signatures are received, whether in this
  /// `scheduleCreate` transaction or a later `scheduleSign` transaction.<br/>
  /// This value SHALL NOT be used and MUST NOT be set when the network
  /// configuration value `scheduling.longTermEnabled` is not enabled.
  public var waitForExpiry: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _scheduledTransactionBody: Proto_SchedulableTransactionBody? = nil
  fileprivate var _adminKey: Proto_Key? = nil
  fileprivate var _payerAccountID: Proto_AccountID? = nil
  fileprivate var _expirationTime: Proto_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ScheduleCreateTransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScheduleCreateTransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scheduledTransactionBody"),
    2: .same(proto: "memo"),
    3: .same(proto: "adminKey"),
    4: .same(proto: "payerAccountID"),
    5: .standard(proto: "expiration_time"),
    13: .standard(proto: "wait_for_expiry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scheduledTransactionBody) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.memo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._adminKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._payerAccountID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expirationTime) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.waitForExpiry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scheduledTransactionBody {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 2)
    }
    try { if let v = self._adminKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._payerAccountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.waitForExpiry != false {
      try visitor.visitSingularBoolField(value: self.waitForExpiry, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ScheduleCreateTransactionBody, rhs: Proto_ScheduleCreateTransactionBody) -> Bool {
    if lhs._scheduledTransactionBody != rhs._scheduledTransactionBody {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs._adminKey != rhs._adminKey {return false}
    if lhs._payerAccountID != rhs._payerAccountID {return false}
    if lhs._expirationTime != rhs._expirationTime {return false}
    if lhs.waitForExpiry != rhs.waitForExpiry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
