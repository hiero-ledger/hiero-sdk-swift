// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/node_stake_update.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Node Stake Updates
/// A system-initiated (i.e. internal) transaction to update stake information
/// for nodes at the end of a staking period.
///
/// Note that staking rewards are not paid immediately. The rewards are
/// calculated, and the amount to be paid is reserved in the reward account,
/// at the end of each staking period. The actual recipient accounts are then
/// paid rewards when that account participates in any transaction that
/// changes staking information or the account balance. This reduces the
/// resources for calculating the staking rewards, quite dramatically,
/// and provides an incentive for account owners to engage with the network,
/// in at least a minor fashion, occasionally (typically annually).<br/>
/// The unexpected change in balances, however, can be surprising to the
/// account holder.
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A system initiated transaction to update staking information.
///
/// This transaction SHALL be issued at the end of each staking period to update
/// node stakes and reward limits.<br/>
/// This transaction SHALL be a child of the first transaction to reach
/// consensus following the end of the previous staking period.<br/>
/// This transaction MUST NOT be sent by a client and SHALL be rejected if
/// received by any node.<br/>
/// This transaction SHALL be present in the record stream or block stream.
///
/// ### Block Stream Effects
/// None
public struct Proto_NodeStakeUpdateTransactionBody: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A timestamp indicating the end of the staking period.
  /// <p>
  /// This value SHALL be one nanosecond prior to midnight prior to the
  /// consensus time of the parent transaction.
  public var endOfStakingPeriod: Proto_Timestamp {
    get {return _storage._endOfStakingPeriod ?? Proto_Timestamp()}
    set {_uniqueStorage()._endOfStakingPeriod = newValue}
  }
  /// Returns true if `endOfStakingPeriod` has been explicitly set.
  public var hasEndOfStakingPeriod: Bool {return _storage._endOfStakingPeriod != nil}
  /// Clears the value of `endOfStakingPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearEndOfStakingPeriod() {_uniqueStorage()._endOfStakingPeriod = nil}

  ///*
  /// A list of `NodeStake` entries for each node at the beginning of the new
  /// staking period.
  /// <p>
  /// This list SHALL have one entry for each node participating in network
  /// consensus.
  public var nodeStake: [Proto_NodeStake] {
    get {return _storage._nodeStake}
    set {_uniqueStorage()._nodeStake = newValue}
  }

  ///*
  /// A maximum reward rate for this staking period.
  /// <p>
  /// This SHALL be a ratio of tinybar to HBAR.<br/>
  /// An account SHALL NOT receive a reward greater than the product of this
  /// ratio and the total number of HBAR staked by that account.
  public var maxStakingRewardRatePerHbar: Int64 {
    get {return _storage._maxStakingRewardRatePerHbar}
    set {_uniqueStorage()._maxStakingRewardRatePerHbar = newValue}
  }

  ///*
  /// A fraction of network and service fees paid to
  /// the "node" reward account.<br/>
  /// The node staking rewards are paid from the designated reward account
  /// `0.0.801`, which receives a fraction of network and service fees for
  /// each transaction. This field is the value of that fraction for the
  /// last staking period.
  public var nodeRewardFeeFraction: Proto_Fraction {
    get {return _storage._nodeRewardFeeFraction ?? Proto_Fraction()}
    set {_uniqueStorage()._nodeRewardFeeFraction = newValue}
  }
  /// Returns true if `nodeRewardFeeFraction` has been explicitly set.
  public var hasNodeRewardFeeFraction: Bool {return _storage._nodeRewardFeeFraction != nil}
  /// Clears the value of `nodeRewardFeeFraction`. Subsequent reads from it will return its default value.
  public mutating func clearNodeRewardFeeFraction() {_uniqueStorage()._nodeRewardFeeFraction = nil}

  ///*
  /// A limit to the number of staking periods held for inactive accounts.<br/>
  /// This is the maximum number of trailing staking periods for which an
  /// account can collect staking rewards.<br/>
  /// #### Example
  /// If this value is 365 with a calendar day period, then each account must
  /// collect rewards at least once per calendar year to receive the full
  /// amount of staking rewards earned.
  /// <p>
  /// Staking rewards SHALL be stored in network state for no more than
  /// `staking_periods_stored` staking periods.<br/>
  /// Each account MUST participate in at least one transaction that affects
  /// its balance, staking, or staking metadata within this time limit
  /// to receive all available staking rewards.
  public var stakingPeriodsStored: Int64 {
    get {return _storage._stakingPeriodsStored}
    set {_uniqueStorage()._stakingPeriodsStored = newValue}
  }

  ///*
  /// A number of minutes representing a staking period.<br/>
  /// <blockquote>Note<blockquote>
  /// For the special case of `1440` minutes, periods are treated as
  /// calendar days aligned to midnight UTC, rather than repeating `1440`
  /// minute periods left-aligned at the epoch.</blockquote></blockquote>
  public var stakingPeriod: Int64 {
    get {return _storage._stakingPeriod}
    set {_uniqueStorage()._stakingPeriod = newValue}
  }

  ///*
  /// A fraction of network and service fees paid to
  /// the "general" reward account.<br/>
  /// The general staking rewards are paid from the designated reward account
  /// `0.0.800`, which receives a fraction of network and service fees for
  /// each transaction. This field is the value of that fraction for the
  /// last staking period.
  public var stakingRewardFeeFraction: Proto_Fraction {
    get {return _storage._stakingRewardFeeFraction ?? Proto_Fraction()}
    set {_uniqueStorage()._stakingRewardFeeFraction = newValue}
  }
  /// Returns true if `stakingRewardFeeFraction` has been explicitly set.
  public var hasStakingRewardFeeFraction: Bool {return _storage._stakingRewardFeeFraction != nil}
  /// Clears the value of `stakingRewardFeeFraction`. Subsequent reads from it will return its default value.
  public mutating func clearStakingRewardFeeFraction() {_uniqueStorage()._stakingRewardFeeFraction = nil}

  ///*
  /// A minimum balance required to pay general staking rewards.
  /// <p>
  /// If the balance of the staking reward account `0.0.800` is below this
  /// threshold, staking rewards SHALL NOT be paid in full.
  public var stakingStartThreshold: Int64 {
    get {return _storage._stakingStartThreshold}
    set {_uniqueStorage()._stakingStartThreshold = newValue}
  }

  ///*
  /// HIP-786 replaced this field with `max_total_reward`.<br/>
  /// This was a maximum total number of tinybars to be distributed as staking
  /// rewards in the staking period that just ended.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var stakingRewardRate: Int64 {
    get {return _storage._stakingRewardRate}
    set {_uniqueStorage()._stakingRewardRate = newValue}
  }

  ///*
  /// An amount reserved in the staking reward account.<br/>
  /// This is an amount "reserved" in the balance of account `0.0.800` that
  /// is already owed for pending rewards that were previously earned but
  /// have not yet been collected.<br/>
  /// This value is further detailed in HIP-786.
  public var reservedStakingRewards: Int64 {
    get {return _storage._reservedStakingRewards}
    set {_uniqueStorage()._reservedStakingRewards = newValue}
  }

  ///*
  /// An available, unreserved, amount in the staking reward account.<br/>
  /// This is the balance of the staking reward account `0.0.800` at the close
  /// of the staking period that just ended, after reduction for all "reserved"
  /// funds necessary to pay previously earned rewards.<br/>
  /// This value is further detailed in HIP-786.
  /// <p>
  /// This value SHALL be used to calculate the reward ratio according to
  /// the formula detailed in HIP-782.
  public var unreservedStakingRewardBalance: Int64 {
    get {return _storage._unreservedStakingRewardBalance}
    set {_uniqueStorage()._unreservedStakingRewardBalance = newValue}
  }

  ///*
  /// A minimum balance required for maximum staking rewards.<br/>
  /// This value is further detailed in HIP-786.
  /// The formula to calculate staking rewards is detailed in HIP-782.
  /// <p>
  /// The value of `unreserved_staking_reward_balance` MUST match or exceed the
  /// value of this field to support the maximum staking reward ratio.<br/>
  public var rewardBalanceThreshold: Int64 {
    get {return _storage._rewardBalanceThreshold}
    set {_uniqueStorage()._rewardBalanceThreshold = newValue}
  }

  ///*
  /// A maximum network-wide stake that can earn full rewards.<br/>
  /// If the network-wide stake, in tinybar, exceeds this value, then staking
  /// rewards must be reduced to maintain "smooth" reward adjustments as
  /// defined in HIP-782.<br/>
  /// This value is further detailed in HIP-786.
  /// <p>
  /// If the total network-wide stake exceeds this value, the effective
  /// staking reward ratio MUST be reduced to maintain solvency of the
  /// staking reward account.
  public var maxStakeRewarded: Int64 {
    get {return _storage._maxStakeRewarded}
    set {_uniqueStorage()._maxStakeRewarded = newValue}
  }

  ///*
  /// A limit amount that could be paid as staking rewards.<br/>
  /// In the limit case, the network could pay at most this amount, in tinybar
  /// as staking rewards for the staking period that just ended, if all other
  /// conditions were met to perfection.<br/>
  /// <p>
  /// This value SHALL reflect the result of a maximum reward calculation that
  /// takes into account the balance thresholds and maximum stake thresholds
  /// as defined in HIP-782 and HIP-786.<br/>
  /// This value is a convenience. The actual defined calculation SHALL be
  /// authoritative in the unlikely event this value differs.
  public var maxTotalReward: Int64 {
    get {return _storage._maxTotalReward}
    set {_uniqueStorage()._maxTotalReward = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Staking information for one node at the end of a staking period.
///
/// This SHALL be one entry in a list reported at the end of each
/// full staking period.
public struct Proto_NodeStake: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// A limit to the amount of stake considered for consensus weight.
  /// <p>
  /// The amount of stake (whether accepting rewards or not) assigned to a
  /// node that exceeds this limit SHALL NOT be considered for
  /// consensus weight calculation.<br/>
  /// If stake to _reward_ for a node exceeds this threshold, then all
  /// accounts staking to that node SHALL receive a lower reward rate in
  /// proportion to the excess stake.
  public var maxStake: Int64 = 0

  ///*
  /// A minimum amount of HBAR staked to a node to receive rewards.
  /// <p>
  /// If the amount of stake (whether accepting rewards or not) assigned to
  /// a node at the start of a staking period is less than this threshold,
  /// then no rewards SHALL be paid to that node or to any accounts
  /// staking to that node.
  public var minStake: Int64 = 0

  ///*
  /// A node identifier.<br/>
  /// This value uniquely identifies this node within the
  /// network address book.
  public var nodeID: Int64 = 0

  ///*
  /// The rate of rewards, in tinybar per HBAR, for the staking reward
  /// period that just ended.
  public var rewardRate: Int64 = 0

  ///*
  /// A consensus weight assigned to this node for the next staking period.
  public var stake: Int64 = 0

  ///*
  /// The total amount staked to this node, while declining rewards.
  /// <p>
  /// This SHALL be the total staked amount, in tinybar, that is staked to
  /// this node with the value of the `decline_reward` set.<br/>
  /// This value MUST be calculated at the beginning of the staking period.
  public var stakeNotRewarded: Int64 = 0

  ///*
  /// The total amount staked to this node, while accepting rewards.
  /// <p>
  /// This SHALL be the total staked amount, in tinybar, that is staked to
  /// this node with the value of the `decline_reward` not set.<br/>
  /// This value MUST be calculated at the beginning of the staking period.
  public var stakeRewarded: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_NodeStakeUpdateTransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeStakeUpdateTransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "end_of_staking_period"),
    2: .standard(proto: "node_stake"),
    3: .standard(proto: "max_staking_reward_rate_per_hbar"),
    4: .standard(proto: "node_reward_fee_fraction"),
    5: .standard(proto: "staking_periods_stored"),
    6: .standard(proto: "staking_period"),
    7: .standard(proto: "staking_reward_fee_fraction"),
    8: .standard(proto: "staking_start_threshold"),
    9: .standard(proto: "staking_reward_rate"),
    10: .standard(proto: "reserved_staking_rewards"),
    11: .standard(proto: "unreserved_staking_reward_balance"),
    12: .standard(proto: "reward_balance_threshold"),
    13: .standard(proto: "max_stake_rewarded"),
    14: .standard(proto: "max_total_reward"),
  ]

  fileprivate class _StorageClass {
    var _endOfStakingPeriod: Proto_Timestamp? = nil
    var _nodeStake: [Proto_NodeStake] = []
    var _maxStakingRewardRatePerHbar: Int64 = 0
    var _nodeRewardFeeFraction: Proto_Fraction? = nil
    var _stakingPeriodsStored: Int64 = 0
    var _stakingPeriod: Int64 = 0
    var _stakingRewardFeeFraction: Proto_Fraction? = nil
    var _stakingStartThreshold: Int64 = 0
    var _stakingRewardRate: Int64 = 0
    var _reservedStakingRewards: Int64 = 0
    var _unreservedStakingRewardBalance: Int64 = 0
    var _rewardBalanceThreshold: Int64 = 0
    var _maxStakeRewarded: Int64 = 0
    var _maxTotalReward: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _endOfStakingPeriod = source._endOfStakingPeriod
      _nodeStake = source._nodeStake
      _maxStakingRewardRatePerHbar = source._maxStakingRewardRatePerHbar
      _nodeRewardFeeFraction = source._nodeRewardFeeFraction
      _stakingPeriodsStored = source._stakingPeriodsStored
      _stakingPeriod = source._stakingPeriod
      _stakingRewardFeeFraction = source._stakingRewardFeeFraction
      _stakingStartThreshold = source._stakingStartThreshold
      _stakingRewardRate = source._stakingRewardRate
      _reservedStakingRewards = source._reservedStakingRewards
      _unreservedStakingRewardBalance = source._unreservedStakingRewardBalance
      _rewardBalanceThreshold = source._rewardBalanceThreshold
      _maxStakeRewarded = source._maxStakeRewarded
      _maxTotalReward = source._maxTotalReward
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._endOfStakingPeriod) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._nodeStake) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._maxStakingRewardRatePerHbar) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._nodeRewardFeeFraction) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._stakingPeriodsStored) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._stakingPeriod) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._stakingRewardFeeFraction) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._stakingStartThreshold) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._stakingRewardRate) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._reservedStakingRewards) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._unreservedStakingRewardBalance) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._rewardBalanceThreshold) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._maxStakeRewarded) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._maxTotalReward) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._endOfStakingPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._nodeStake.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._nodeStake, fieldNumber: 2)
      }
      if _storage._maxStakingRewardRatePerHbar != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxStakingRewardRatePerHbar, fieldNumber: 3)
      }
      try { if let v = _storage._nodeRewardFeeFraction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._stakingPeriodsStored != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stakingPeriodsStored, fieldNumber: 5)
      }
      if _storage._stakingPeriod != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stakingPeriod, fieldNumber: 6)
      }
      try { if let v = _storage._stakingRewardFeeFraction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._stakingStartThreshold != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stakingStartThreshold, fieldNumber: 8)
      }
      if _storage._stakingRewardRate != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stakingRewardRate, fieldNumber: 9)
      }
      if _storage._reservedStakingRewards != 0 {
        try visitor.visitSingularInt64Field(value: _storage._reservedStakingRewards, fieldNumber: 10)
      }
      if _storage._unreservedStakingRewardBalance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unreservedStakingRewardBalance, fieldNumber: 11)
      }
      if _storage._rewardBalanceThreshold != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rewardBalanceThreshold, fieldNumber: 12)
      }
      if _storage._maxStakeRewarded != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxStakeRewarded, fieldNumber: 13)
      }
      if _storage._maxTotalReward != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxTotalReward, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeStakeUpdateTransactionBody, rhs: Proto_NodeStakeUpdateTransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._endOfStakingPeriod != rhs_storage._endOfStakingPeriod {return false}
        if _storage._nodeStake != rhs_storage._nodeStake {return false}
        if _storage._maxStakingRewardRatePerHbar != rhs_storage._maxStakingRewardRatePerHbar {return false}
        if _storage._nodeRewardFeeFraction != rhs_storage._nodeRewardFeeFraction {return false}
        if _storage._stakingPeriodsStored != rhs_storage._stakingPeriodsStored {return false}
        if _storage._stakingPeriod != rhs_storage._stakingPeriod {return false}
        if _storage._stakingRewardFeeFraction != rhs_storage._stakingRewardFeeFraction {return false}
        if _storage._stakingStartThreshold != rhs_storage._stakingStartThreshold {return false}
        if _storage._stakingRewardRate != rhs_storage._stakingRewardRate {return false}
        if _storage._reservedStakingRewards != rhs_storage._reservedStakingRewards {return false}
        if _storage._unreservedStakingRewardBalance != rhs_storage._unreservedStakingRewardBalance {return false}
        if _storage._rewardBalanceThreshold != rhs_storage._rewardBalanceThreshold {return false}
        if _storage._maxStakeRewarded != rhs_storage._maxStakeRewarded {return false}
        if _storage._maxTotalReward != rhs_storage._maxTotalReward {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeStake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeStake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_stake"),
    2: .standard(proto: "min_stake"),
    3: .standard(proto: "node_id"),
    4: .standard(proto: "reward_rate"),
    5: .same(proto: "stake"),
    6: .standard(proto: "stake_not_rewarded"),
    7: .standard(proto: "stake_rewarded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxStake) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.minStake) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.nodeID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.rewardRate) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.stake) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.stakeNotRewarded) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.stakeRewarded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxStake != 0 {
      try visitor.visitSingularInt64Field(value: self.maxStake, fieldNumber: 1)
    }
    if self.minStake != 0 {
      try visitor.visitSingularInt64Field(value: self.minStake, fieldNumber: 2)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularInt64Field(value: self.nodeID, fieldNumber: 3)
    }
    if self.rewardRate != 0 {
      try visitor.visitSingularInt64Field(value: self.rewardRate, fieldNumber: 4)
    }
    if self.stake != 0 {
      try visitor.visitSingularInt64Field(value: self.stake, fieldNumber: 5)
    }
    if self.stakeNotRewarded != 0 {
      try visitor.visitSingularInt64Field(value: self.stakeNotRewarded, fieldNumber: 6)
    }
    if self.stakeRewarded != 0 {
      try visitor.visitSingularInt64Field(value: self.stakeRewarded, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_NodeStake, rhs: Proto_NodeStake) -> Bool {
    if lhs.maxStake != rhs.maxStake {return false}
    if lhs.minStake != rhs.minStake {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.rewardRate != rhs.rewardRate {return false}
    if lhs.stake != rhs.stake {return false}
    if lhs.stakeNotRewarded != rhs.stakeNotRewarded {return false}
    if lhs.stakeRewarded != rhs.stakeRewarded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
