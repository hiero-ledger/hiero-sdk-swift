// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/consensus_update_topic.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Update Topic
/// Update a topic for the Hedera Consensus Service (HCS).
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Update the fields of an existing HCS topic.
///
/// The topicID field is REQUIRED. All other fields are OPTIONAL.<br/>
/// Fields set on this transaction SHALL be updated.<br/>
/// Fields _not_ set on this transaction SHALL NOT be updated.
///
/// ### Block Stream Effects
/// None
public struct Proto_ConsensusUpdateTopicTransactionBody: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The topic ID specifying the topic to update.
  /// <p>
  /// A topic with this ID MUST exist and MUST NOT be deleted.<br/>
  /// This value is REQUIRED.
  public var topicID: Proto_TopicID {
    get {return _storage._topicID ?? Proto_TopicID()}
    set {_uniqueStorage()._topicID = newValue}
  }
  /// Returns true if `topicID` has been explicitly set.
  public var hasTopicID: Bool {return _storage._topicID != nil}
  /// Clears the value of `topicID`. Subsequent reads from it will return its default value.
  public mutating func clearTopicID() {_uniqueStorage()._topicID = nil}

  ///*
  /// An updated memo to be associated with this topic.
  /// <p>
  /// If this value is set, the current `adminKey` for the topic MUST sign
  /// this transaction.<br/>
  /// This value, if set, SHALL be encoded UTF-8 and SHALL NOT exceed
  /// 100 bytes when so encoded.
  public var memo: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._memo ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  public var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  public mutating func clearMemo() {_uniqueStorage()._memo = nil}

  ///*
  /// An updated expiration time for this topic, in seconds since the epoch.
  /// <p>
  /// For this purpose, `epoch` SHALL be the UNIX epoch
  /// with 0 at `1970-01-01T00:00:00.000Z`.<br/>
  /// The expirationTime MUST NOT be greater than the sum of
  /// `MAX_AUTORENEW_PERIOD` and the actual consensus timestamp of
  /// this transaction.<br/>
  /// If `adminKey` is <b>unset</b> for the _topic_, this transaction MUST NOT
  /// modify any other field.
  public var expirationTime: Proto_Timestamp {
    get {return _storage._expirationTime ?? Proto_Timestamp()}
    set {_uniqueStorage()._expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  public var hasExpirationTime: Bool {return _storage._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

  ///*
  /// Updated access control for modification of the topic.
  /// <p>
  /// If this field is set, that key and the previously set key MUST both
  /// sign this transaction.<br/>
  /// If this value is an empty `KeyList`, the prior key MUST sign this
  /// transaction, and the topic SHALL be immutable after this transaction
  /// completes, except for expiration and renewal.
  public var adminKey: Proto_Key {
    get {return _storage._adminKey ?? Proto_Key()}
    set {_uniqueStorage()._adminKey = newValue}
  }
  /// Returns true if `adminKey` has been explicitly set.
  public var hasAdminKey: Bool {return _storage._adminKey != nil}
  /// Clears the value of `adminKey`. Subsequent reads from it will return its default value.
  public mutating func clearAdminKey() {_uniqueStorage()._adminKey = nil}

  ///*
  /// Updated access control for message submission to the topic.
  /// <p>
  /// If this value is set, the current `adminKey` for the topic MUST sign
  /// this transaction.<br/>
  /// If this value is set to an empty `KeyList`, the `submitKey` for the
  /// topic will be unset after this transaction completes. When the
  /// `submitKey` is unset, any account may submit a message on the topic,
  /// without restriction.
  public var submitKey: Proto_Key {
    get {return _storage._submitKey ?? Proto_Key()}
    set {_uniqueStorage()._submitKey = newValue}
  }
  /// Returns true if `submitKey` has been explicitly set.
  public var hasSubmitKey: Bool {return _storage._submitKey != nil}
  /// Clears the value of `submitKey`. Subsequent reads from it will return its default value.
  public mutating func clearSubmitKey() {_uniqueStorage()._submitKey = nil}

  ///
  /// An updated value for the number of seconds by which the topic expiration
  /// will be automatically extended upon expiration, if it has a valid
  /// auto-renew account.
  /// <p>
  /// If this value is set, the current `adminKey` for the topic MUST sign
  /// this transaction.<br/>
  /// This value, if set, MUST be greater than the
  /// configured MIN_AUTORENEW_PERIOD.<br/>
  /// This value, if set, MUST be less than the
  /// configured MAX_AUTORENEW_PERIOD.
  public var autoRenewPeriod: Proto_Duration {
    get {return _storage._autoRenewPeriod ?? Proto_Duration()}
    set {_uniqueStorage()._autoRenewPeriod = newValue}
  }
  /// Returns true if `autoRenewPeriod` has been explicitly set.
  public var hasAutoRenewPeriod: Bool {return _storage._autoRenewPeriod != nil}
  /// Clears the value of `autoRenewPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewPeriod() {_uniqueStorage()._autoRenewPeriod = nil}

  ///*
  /// An updated ID for the account to be charged renewal fees at the topic's
  /// `expirationTime` to extend the lifetime of the topic.
  /// <p>
  /// If this value is set and not the "sentinel account", the referenced
  /// account MUST sign this transaction.<br/>
  /// If this value is set, the current `adminKey` for the topic MUST sign
  /// this transaction.<br/>
  /// If this value is set to the "sentinel account", which is `0.0.0`, the
  /// `autoRenewAccount` SHALL be removed from the topic.
  public var autoRenewAccount: Proto_AccountID {
    get {return _storage._autoRenewAccount ?? Proto_AccountID()}
    set {_uniqueStorage()._autoRenewAccount = newValue}
  }
  /// Returns true if `autoRenewAccount` has been explicitly set.
  public var hasAutoRenewAccount: Bool {return _storage._autoRenewAccount != nil}
  /// Clears the value of `autoRenewAccount`. Subsequent reads from it will return its default value.
  public mutating func clearAutoRenewAccount() {_uniqueStorage()._autoRenewAccount = nil}

  ///*
  /// Access control for update/delete of custom fees.
  /// <p>
  /// If set, subsequent consensus_update_topic transactions signed with this
  /// key MAY update or delete the custom fees for this topic.<br/>
  /// If this field is set, the admin key MUST sign this transaction.<br/>
  /// If this field is set, the previous value SHALL be replaced.<br/>
  /// If set to a 'Key' containing an empty 'KeyList', the previous value
  /// SHALL be cleared.<br/>
  /// If not set, the current key SHALL NOT change.<br/>
  /// If unset in state, this field MUST NOT be set in this transaction.<br/>
  /// If not set when the topic is created, this field CANNOT be set via
  /// update.<br/>
  public var feeScheduleKey: Proto_Key {
    get {return _storage._feeScheduleKey ?? Proto_Key()}
    set {_uniqueStorage()._feeScheduleKey = newValue}
  }
  /// Returns true if `feeScheduleKey` has been explicitly set.
  public var hasFeeScheduleKey: Bool {return _storage._feeScheduleKey != nil}
  /// Clears the value of `feeScheduleKey`. Subsequent reads from it will return its default value.
  public mutating func clearFeeScheduleKey() {_uniqueStorage()._feeScheduleKey = nil}

  ///*
  /// A set of keys<br/>
  /// Keys in this list are permitted to submit messages to this topic without
  /// paying custom fees associated with this topic.
  /// <p>
  /// If a submit transaction is signed by _any_ key included in this set,
  /// custom fees SHALL NOT be charged for that transaction.<br/>
  /// If this field is not set, the current set of keys SHALL NOT change.<br/>
  /// If this field is set, but contains an empty list, any existing fee-exempt
  /// keys SHALL be removed.<br/>
  /// A `fee_exempt_key_list` MUST NOT contain more than
  /// `MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST` keys.<br/>
  /// A `fee_exempt_key_list` MUST NOT contain any duplicate keys.<br/>
  /// A `fee_exempt_key_list` MAY contain keys for accounts that are inactive,
  /// deleted, or non-existent.
  public var feeExemptKeyList: Proto_FeeExemptKeyList {
    get {return _storage._feeExemptKeyList ?? Proto_FeeExemptKeyList()}
    set {_uniqueStorage()._feeExemptKeyList = newValue}
  }
  /// Returns true if `feeExemptKeyList` has been explicitly set.
  public var hasFeeExemptKeyList: Bool {return _storage._feeExemptKeyList != nil}
  /// Clears the value of `feeExemptKeyList`. Subsequent reads from it will return its default value.
  public mutating func clearFeeExemptKeyList() {_uniqueStorage()._feeExemptKeyList = nil}

  ///*
  /// A set of custom fee definitions.<br/>
  /// These are fees to be assessed for each submit to this topic.
  /// <p>
  /// Each fee defined in this set SHALL be evaluated for
  /// each message submitted to this topic, and the resultant
  /// total assessed fees SHALL be charged.<br/>
  /// Custom fees defined here SHALL be assessed in addition to the base
  /// network and node fees.<br/>
  /// If this field is not set, the current set of custom fees
  /// SHALL NOT change.<br/>
  /// If this field is set, but contains an empty list, all current custom fees
  /// SHALL be removed.
  /// custom_fees list SHALL NOT contain more than
  /// `MAX_CUSTOM_FEE_ENTRIES_FOR_TOPICS` entries.
  public var customFees: Proto_FixedCustomFeeList {
    get {return _storage._customFees ?? Proto_FixedCustomFeeList()}
    set {_uniqueStorage()._customFees = newValue}
  }
  /// Returns true if `customFees` has been explicitly set.
  public var hasCustomFees: Bool {return _storage._customFees != nil}
  /// Clears the value of `customFees`. Subsequent reads from it will return its default value.
  public mutating func clearCustomFees() {_uniqueStorage()._customFees = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_ConsensusUpdateTopicTransactionBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsensusUpdateTopicTransactionBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicID"),
    2: .same(proto: "memo"),
    4: .same(proto: "expirationTime"),
    6: .same(proto: "adminKey"),
    7: .same(proto: "submitKey"),
    8: .same(proto: "autoRenewPeriod"),
    9: .same(proto: "autoRenewAccount"),
    10: .standard(proto: "fee_schedule_key"),
    11: .standard(proto: "fee_exempt_key_list"),
    12: .standard(proto: "custom_fees"),
  ]

  fileprivate class _StorageClass {
    var _topicID: Proto_TopicID? = nil
    var _memo: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _expirationTime: Proto_Timestamp? = nil
    var _adminKey: Proto_Key? = nil
    var _submitKey: Proto_Key? = nil
    var _autoRenewPeriod: Proto_Duration? = nil
    var _autoRenewAccount: Proto_AccountID? = nil
    var _feeScheduleKey: Proto_Key? = nil
    var _feeExemptKeyList: Proto_FeeExemptKeyList? = nil
    var _customFees: Proto_FixedCustomFeeList? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _topicID = source._topicID
      _memo = source._memo
      _expirationTime = source._expirationTime
      _adminKey = source._adminKey
      _submitKey = source._submitKey
      _autoRenewPeriod = source._autoRenewPeriod
      _autoRenewAccount = source._autoRenewAccount
      _feeScheduleKey = source._feeScheduleKey
      _feeExemptKeyList = source._feeExemptKeyList
      _customFees = source._customFees
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._topicID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._expirationTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._adminKey) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._submitKey) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewPeriod) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewAccount) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._feeScheduleKey) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._feeExemptKeyList) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._customFees) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._topicID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._adminKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._submitKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._autoRenewPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._autoRenewAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._feeScheduleKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._feeExemptKeyList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._customFees {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_ConsensusUpdateTopicTransactionBody, rhs: Proto_ConsensusUpdateTopicTransactionBody) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._topicID != rhs_storage._topicID {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._adminKey != rhs_storage._adminKey {return false}
        if _storage._submitKey != rhs_storage._submitKey {return false}
        if _storage._autoRenewPeriod != rhs_storage._autoRenewPeriod {return false}
        if _storage._autoRenewAccount != rhs_storage._autoRenewAccount {return false}
        if _storage._feeScheduleKey != rhs_storage._feeScheduleKey {return false}
        if _storage._feeExemptKeyList != rhs_storage._feeExemptKeyList {return false}
        if _storage._customFees != rhs_storage._customFees {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
