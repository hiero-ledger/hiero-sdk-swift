// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/transaction_get_record.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Get Transaction Record
/// Messages for a query to obtain a transaction record. This particular
/// query is used by `getTxRecordByTxID` in the "Crypto" service API.
///
/// > Note
/// >> Much more detailed information for transaction records is available
/// >> from a mirror node, and the mirror node retains transaction records
/// >> long term, rather than for a short "cache" duration. Clients may
/// >> prefer the mirror node graph API to query transaction records, rather
/// >> than this query.
///
/// > Implementation Note
/// >> This query is _defined_ for "Crypto" service, but is _implemented_ by
/// >> the "Network Admin" service.
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Request for a `TransactionGetRecord` (a.k.a. `getTxRecordByTxID`) query.
/// <p>
/// A transaction record SHALL be available after the network reaches
/// consensus and completes execution for a transaction.<br/>
/// A transaction record SHALL NOT be available after the end of the network
/// configured "record cache duration".
///
/// <dl>
///   <dt>What is the "first" transaction?</dt>
///   <dd>The "first" transaction SHALL be the the transaction with
///       the earliest consensus time and a status that is neither
///       `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
///       If no transaction is found meeting this status criteria, the
///       "first" transaction SHALL be the transaction with the earliest
///       consensus time.</dd>
///  <dt>What is a "child" transaction?</dt>
///  <dd>A "child" transaction is any transaction created in the process of
///      completing another transaction. These are most common with a smart
///      contract call, where a call to a contract may initiate one or more
///      additional transactions to complete a complex process.</dd>
/// </dl>
public struct Proto_TransactionGetRecordQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Standard information sent with every query operation.<br/>
  /// This includes the signed payment and what kind of response is requested
  /// (cost, state proof, both, or neither).
  public var header: Proto_QueryHeader {
    get {return _header ?? Proto_QueryHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  ///*
  /// A transaction identifier.
  /// <p>
  /// This MUST contain the full identifier, as submitted, for the
  /// transaction to query.
  public var transactionID: Proto_TransactionID {
    get {return _transactionID ?? Proto_TransactionID()}
    set {_transactionID = newValue}
  }
  /// Returns true if `transactionID` has been explicitly set.
  public var hasTransactionID: Bool {return self._transactionID != nil}
  /// Clears the value of `transactionID`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionID() {self._transactionID = nil}

  ///*
  /// A flag to request duplicates.
  /// <p>
  /// If set, every transaction record within the record cache duration that
  /// matches the requested transaction identifier SHALL be returned.<br/>
  /// If not set, duplicate transactions SHALL NOT be returned.<br/>
  /// If not set, only the record for the first matching transaction to
  /// reach consensus SHALL be returned.
  public var includeDuplicates: Bool = false

  ///*
  /// A flag to request "child" records.
  /// <p>
  /// If set, the response SHALL include records for each child transaction
  /// executed as part of the requested parent transaction.<br/>
  /// If not set, the response SHALL NOT include any records for child
  /// transactions.
  public var includeChildRecords: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Proto_QueryHeader? = nil
  fileprivate var _transactionID: Proto_TransactionID? = nil
}

///*
/// Response message for a `getTxRecordByTxID` query.
///
/// The `transactionRecord` field SHALL return the record for the "first"
/// transaction that matches the transaction identifier requested.<br/>
/// If records for duplicate transactions are requested, those duplicate
/// records SHALL be present in the `duplicateTransactionReceipts` list.<br/>
/// If records for child transactions are requested, those child records SHALL
/// be present in the `child_transaction_records` list.<br/>
/// A state proof MAY be provided for this response; provided the record is
/// still available from the consensus nodes.
///
/// <dl>
///   <dt>What is the "first" transaction?</dt>
///   <dd>The "first" transaction receipt SHALL be the receipt for the
///       first transaction with status that is neither
///       `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
///       If no transaction is found meeting the status criteria, the
///       "first" transaction SHALL be the first transaction by
///       consensus time.</dd>
///  <dt>What is a "child" transaction?</dt>
///  <dd>A "child" transaction is any transaction created in the process of
///      completing another transaction. These are most common with a smart
///      contract call, where a call to a contract may initiate one or more
///      additional transactions to complete a complex process.</dd>
/// </dl>
public struct Proto_TransactionGetRecordResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The standard response information for queries.<br/>
  /// This includes the values requested in the `QueryHeader`
  /// (cost, state proof, both, or neither).
  public var header: Proto_ResponseHeader {
    get {return _header ?? Proto_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  ///*
  /// A transaction record.
  /// <p>
  /// This SHALL be the record for the "first" transaction that matches
  /// the transaction identifier requested.<br/>
  /// If the identified transaction has not reached consensus, this
  /// record SHALL have a `status` of `UNKNOWN`.<br/>
  /// If the identified transaction reached consensus prior to the
  /// current configured record cache duration, this record SHALL
  /// have a `status` of `UNKNOWN`.
  public var transactionRecord: Proto_TransactionRecord {
    get {return _transactionRecord ?? Proto_TransactionRecord()}
    set {_transactionRecord = newValue}
  }
  /// Returns true if `transactionRecord` has been explicitly set.
  public var hasTransactionRecord: Bool {return self._transactionRecord != nil}
  /// Clears the value of `transactionRecord`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionRecord() {self._transactionRecord = nil}

  ///*
  /// A list of duplicate transaction records.
  /// <p>
  /// If the request set the `includeDuplicates` flat, this list SHALL
  /// include the records for each duplicate transaction associated to the
  /// requested transaction identifier.
  /// If the request did not set the `includeDuplicates` flag, this list
  /// SHALL be empty.<br/>
  /// If the `transactionRecord` status is `UNKNOWN`, this list
  /// SHALL be empty.<br/>
  /// This list SHALL be in order by consensus timestamp.
  public var duplicateTransactionRecords: [Proto_TransactionRecord] = []

  ///*
  /// A list of records for all child transactions spawned by the requested
  /// transaction.
  /// <p>
  /// If the request set the `include_child_records` flag, this list SHALL
  /// include records for each child transaction executed as part of the
  /// requested parent transaction.<br/>
  /// If the request did not set the `include_child_records` flag, this
  /// list SHALL be empty. <br/>
  /// If the parent transaction did not initiate any child transactions
  /// this list SHALL be empty.<br/>
  /// If the `transactionRecord` status is `UNKNOWN`, this list
  /// SHALL be empty.<br/>
  /// This list SHALL be in order by consensus timestamp.
  public var childTransactionRecords: [Proto_TransactionRecord] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Proto_ResponseHeader? = nil
  fileprivate var _transactionRecord: Proto_TransactionRecord? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_TransactionGetRecordQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionGetRecordQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "transactionID"),
    3: .same(proto: "includeDuplicates"),
    4: .standard(proto: "include_child_records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transactionID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeDuplicates) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeChildRecords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._transactionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.includeDuplicates != false {
      try visitor.visitSingularBoolField(value: self.includeDuplicates, fieldNumber: 3)
    }
    if self.includeChildRecords != false {
      try visitor.visitSingularBoolField(value: self.includeChildRecords, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionGetRecordQuery, rhs: Proto_TransactionGetRecordQuery) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._transactionID != rhs._transactionID {return false}
    if lhs.includeDuplicates != rhs.includeDuplicates {return false}
    if lhs.includeChildRecords != rhs.includeChildRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionGetRecordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionGetRecordResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    3: .same(proto: "transactionRecord"),
    4: .same(proto: "duplicateTransactionRecords"),
    5: .standard(proto: "child_transaction_records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transactionRecord) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.duplicateTransactionRecords) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.childTransactionRecords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._transactionRecord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.duplicateTransactionRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.duplicateTransactionRecords, fieldNumber: 4)
    }
    if !self.childTransactionRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childTransactionRecords, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionGetRecordResponse, rhs: Proto_TransactionGetRecordResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._transactionRecord != rhs._transactionRecord {return false}
    if lhs.duplicateTransactionRecords != rhs.duplicateTransactionRecords {return false}
    if lhs.childTransactionRecords != rhs.childTransactionRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
