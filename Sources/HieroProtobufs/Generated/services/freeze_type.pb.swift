// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/freeze_type.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Freeze Type
/// An enumeration to select the type of a network freeze.
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// An enumeration of possible network freeze types.
///
/// Each enumerated value SHALL be associated to a single network freeze
/// scenario. Each freeze scenario defines the specific parameters
/// REQUIRED for that freeze.
public enum Proto_FreezeType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// An invalid freeze type.
  /// <p>
  /// The first value in a protobuf enum is a default value. This default
  /// is RECOMMENDED to be an invalid value to aid in detecting unset fields.
  case unknownFreezeType // = 0

  ///*
  /// Freeze the network, and take no further action.
  /// <p>
  /// The `start_time` field is REQUIRED, MUST be strictly later than the
  /// consensus time when this transaction is handled, and SHOULD be between
  /// `300` and `3600` seconds after the transaction identifier
  /// `transactionValidStart` field.<br/>
  /// The fields `update_file` and `file_hash` SHALL be ignored.<br/>
  /// A `FREEZE_ONLY` transaction SHALL NOT perform any network
  /// changes or upgrades.<br/>
  /// After this freeze is processed manual intervention is REQUIRED
  /// to restart the network.
  case freezeOnly // = 1

  ///*
  /// This freeze type does not freeze the network, but begins
  /// "preparation" to upgrade the network.
  /// <p>
  /// The fields `update_file` and `file_hash` are REQUIRED
  /// and MUST be valid.<br/>
  /// The `start_time` field SHALL be ignored.<br/>
  /// A `PREPARE_UPGRADE` transaction SHALL NOT freeze the network or
  /// interfere with general transaction processing.<br/>
  /// If this freeze type is initiated after a `TELEMETRY_UPGRADE`, the
  /// prepared telemetry upgrade SHALL be reset and all telemetry upgrade
  /// artifacts in the filesystem SHALL be deleted.<br/>
  /// At some point after this freeze type completes (dependent on the size
  /// of the upgrade file), the network SHALL be prepared to complete
  /// a software upgrade of all nodes.
  case prepareUpgrade // = 2

  ///*
  /// Freeze the network to perform a software upgrade.
  /// <p>
  /// The `start_time` field is REQUIRED, MUST be strictly later than the
  /// consensus time when this transaction is handled, and SHOULD be between
  /// `300` and `3600` seconds after the transaction identifier
  /// `transactionValidStart` field.<br/>
  /// A software upgrade file MUST be prepared prior to this transaction.<br/>
  /// After this transaction completes, the network SHALL initiate an
  /// upgrade and restart of all nodes at the start time specified.
  case freezeUpgrade // = 3

  ///*
  /// Abort a pending network freeze operation.
  /// <p>
  /// All fields SHALL be ignored for this freeze type.<br/>
  /// This freeze type MAY be submitted after a `FREEZE_ONLY`,
  /// `FREEZE_UPGRADE`, or `TELEMETRY_UPGRADE` is initiated.<br/>
  /// This freeze type MUST be submitted and reach consensus
  /// before the `start_time` designated for the current pending
  /// freeze to be effective.<br/>
  /// After this freeze type is processed, the upgrade file hash
  /// and pending freeze start time stored in the network SHALL
  /// be reset to default (empty) values.
  case freezeAbort // = 4

  ///*
  /// Prepare an upgrade of auxiliary services and containers
  /// providing telemetry/metrics.
  /// <p>
  /// The `start_time` field is REQUIRED, MUST be strictly later than the
  /// consensus time when this transaction is handled, and SHOULD be between
  /// `300` and `3600` seconds after the transaction identifier
  /// `transactionValidStart` field.<br/>
  /// The `update_file` field is REQUIRED and MUST be valid.<br/>
  /// A `TELEMETRY_UPGRADE` transaction SHALL NOT freeze the network or
  /// interfere with general transaction processing.<br/>
  /// This freeze type MUST NOT be initiated between a `PREPARE_UPGRADE`
  /// and `FREEZE_UPGRADE`. If this freeze type is initiated after a
  /// `PREPARE_UPGRADE`, the prepared upgrade SHALL be reset and all software
  /// upgrade artifacts in the filesystem SHALL be deleted.<br/>
  /// At some point after this freeze type completes (dependent on the
  /// size of the upgrade file), the network SHALL automatically upgrade
  /// the telemetry/metrics services and containers as directed in
  /// the specified telemetry upgrade file.
  /// <blockquote> The condition that `start_time` is REQUIRED is an
  /// historical anomaly and SHOULD change in a future release.</blockquote>
  case telemetryUpgrade // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownFreezeType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownFreezeType
    case 1: self = .freezeOnly
    case 2: self = .prepareUpgrade
    case 3: self = .freezeUpgrade
    case 4: self = .freezeAbort
    case 5: self = .telemetryUpgrade
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownFreezeType: return 0
    case .freezeOnly: return 1
    case .prepareUpgrade: return 2
    case .freezeUpgrade: return 3
    case .freezeAbort: return 4
    case .telemetryUpgrade: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Proto_FreezeType] = [
    .unknownFreezeType,
    .freezeOnly,
    .prepareUpgrade,
    .freezeUpgrade,
    .freezeAbort,
    .telemetryUpgrade,
  ]

}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Proto_FreezeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_FREEZE_TYPE"),
    1: .same(proto: "FREEZE_ONLY"),
    2: .same(proto: "PREPARE_UPGRADE"),
    3: .same(proto: "FREEZE_UPGRADE"),
    4: .same(proto: "FREEZE_ABORT"),
    5: .same(proto: "TELEMETRY_UPGRADE"),
  ]
}
