// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transaction_get_receipt.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Get Transaction Receipt
/// This query is central to client interactions. A client must query
/// the network for the "receipt" after a transaction is submitted to know
/// whether the transaction succeeded and the consensus result.
///
/// > Implementation Note
/// >> This query is _defined_ for "Crypto" service, but is _implemented_ by
/// >> the "Network Admin" service.
///
/// > Note
/// >> The mechanism for transaction receipts and results is subject to
/// >> considerable change in the near future. Clients heavily dependent
/// >> on direct network queries for transaction receipts may consider
/// >> changes needed to query a mirror node for transaction receipts
/// >> and results instead.
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// A query to retrieve a transaction receipt.
/// This query retrieves the post-consensus (final) result of a transaction.
/// A transaction receipt may not be available if queried too early
/// (less than 5-10 seconds), or too late (more than 3 minutes). If a receipt
/// is available, it contains basic transaction results. A query to a mirror
/// node (or other archival system) is required to obtain full detail for a
/// transaction, or any result after the basic receipt time period.
///
/// This query is "free". The payment field in the header MUST be empty.<br/>
/// If a receipt is not available, the response SHALL be `UNKNOWN`.<br/>
/// A transaction receipt SHALL be available after the network reaches
/// consensus for a transaction.<br/>
/// A transaction receipt SHALL NOT be available after the end of the network
/// configured "receipt period", typically three(3) minutes.
///
/// <dl>
///   <dt>What is the "first" transaction?</dt>
///   <dd>The "first" transaction SHALL be the the transaction with
///       the earliest consensus time and a status that is neither
///       `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
///       If no transaction is found meeting this status criteria, the
///       "first" transaction SHALL be the transaction with the earliest
///       consensus time.</dd>
///  <dt>What is a "child" transaction?</dt>
///  <dd>A "child" transaction is any transaction created in the process of
///      completing another transaction. These are most common with a smart
///      contract call, where a call to a contract may initiate one or more
///      additional transactions to complete a complex process.</dd>
/// </dl>
public struct Proto_TransactionGetReceiptQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Standard information sent with every query operation.<br/>
  /// This includes the signed payment and what kind of response is requested
  /// (cost, state proof, both, or neither).
  public var header: Proto_QueryHeader {
    get {return _header ?? Proto_QueryHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  ///*
  /// A transaction identifier.
  /// <p>
  /// This MUST contain the full identifier, as submitted, for the
  /// transaction to query.
  public var transactionID: Proto_TransactionID {
    get {return _transactionID ?? Proto_TransactionID()}
    set {_transactionID = newValue}
  }
  /// Returns true if `transactionID` has been explicitly set.
  public var hasTransactionID: Bool {return self._transactionID != nil}
  /// Clears the value of `transactionID`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionID() {self._transactionID = nil}

  ///*
  /// A flag to request duplicates.
  /// <p>
  /// If set, every transaction receipt within the receipt period that
  /// matches the requested transaction identifier SHALL be returned.<br/>
  /// If not set, duplicate transactions SHALL NOT be returned.<br/>
  /// If not set, only the receipt for the first matching transaction to
  /// reach consensus SHALL be returned.
  public var includeDuplicates: Bool = false

  ///*
  /// A flag to request "child" receipts.
  /// <p>
  /// If set, the response SHALL include receipts for each child transaction
  /// executed as part of the requested parent transaction.<br/>
  /// If not set, the response SHALL NOT include any receipts for child
  /// transactions.
  public var includeChildReceipts: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Proto_QueryHeader? = nil
  fileprivate var _transactionID: Proto_TransactionID? = nil
}

///*
/// Response message for a `getTransactionReceipts` query.
///
/// The `receipt` field SHALL return the receipt for the "first" transaction
/// that matches the transaction identifier requested.<br/>
/// If receipts for duplicate transactions are requested, those duplicate
/// receipts SHALL be present in the `duplicateTransactionReceipts` list.<br/>
/// If receipts for child transactions are requested, those child receipts
/// SHALL be present in the `child_transaction_receipts` list.<br/>
/// A state proof SHALL NOT be provided for this response; transaction receipts
/// are not retained in network state.
///
/// <dl>
///   <dt>What is the "first" transaction?</dt>
///   <dd>The "first" transaction receipt SHALL be the receipt for the
///       first transaction with status that is neither
///       `INVALID_NODE_ACCOUNT` nor `INVALID_PAYER_SIGNATURE`.<br/>
///       If no transaction is found meeting the status criteria, the
///       "first" transaction SHALL be the first transaction by
///       consensus time.</dd>
///  <dt>What is a "child" transaction?</dt>
///  <dd>A "child" transaction is any transaction created in the process of
///      completing another transaction. These are most common with a smart
///      contract call, where a call to a contract may initiate one or more
///      additional transactions to complete a complex process.</dd>
/// </dl>
public struct Proto_TransactionGetReceiptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The standard response information for queries.<br/>
  /// This includes the values requested in the `QueryHeader`
  /// (cost, state proof, both, or neither).
  public var header: Proto_ResponseHeader {
    get {return _header ?? Proto_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  ///*
  /// A transaction receipt.
  /// <p>
  /// This SHALL be the receipt for the "first" transaction that matches
  /// the transaction identifier requested.<br/>
  /// If the identified transaction has not reached consensus, this receipt
  /// SHALL have a `status` of `UNKNOWN`.<br/>
  /// If the identified transaction reached consensus prior to the current
  /// configured receipt period (typically the last 180 seconds), this receipt
  /// SHALL have a `status` of `UNKNOWN`.
  public var receipt: Proto_TransactionReceipt {
    get {return _receipt ?? Proto_TransactionReceipt()}
    set {_receipt = newValue}
  }
  /// Returns true if `receipt` has been explicitly set.
  public var hasReceipt: Bool {return self._receipt != nil}
  /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
  public mutating func clearReceipt() {self._receipt = nil}

  ///*
  /// A list of duplicate transaction receipts.
  /// <p>
  /// If the request set the `includeDuplicates` flat, this list SHALL
  /// include the receipts for each duplicate transaction associated to the
  /// requested transaction identifier.
  /// If the request did not set the `includeDuplicates` flag, this list
  /// SHALL be empty.<br/>
  /// If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
  /// This list SHALL be in order by consensus timestamp.
  public var duplicateTransactionReceipts: [Proto_TransactionReceipt] = []

  ///*
  /// A list of receipts for all child transactions spawned by the requested
  /// transaction.
  /// <p>
  /// If the request set the `include_child_receipts` flag, this list SHALL
  /// include receipts for each child transaction executed as part of the
  /// requested parent transaction.<br/>
  /// If the request did not set the `include_child_receipts` flag, this
  /// list SHALL be empty. <br/>
  /// If the parent transaction did not initiate any child transactions
  /// this list SHALL be empty.<br/>
  /// If the `receipt` status is `UNKNOWN`, this list SHALL be empty.<br/>
  /// This list SHALL be in order by consensus timestamp.
  public var childTransactionReceipts: [Proto_TransactionReceipt] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Proto_ResponseHeader? = nil
  fileprivate var _receipt: Proto_TransactionReceipt? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_TransactionGetReceiptQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionGetReceiptQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "transactionID"),
    3: .same(proto: "includeDuplicates"),
    4: .standard(proto: "include_child_receipts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transactionID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeDuplicates) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeChildReceipts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._transactionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.includeDuplicates != false {
      try visitor.visitSingularBoolField(value: self.includeDuplicates, fieldNumber: 3)
    }
    if self.includeChildReceipts != false {
      try visitor.visitSingularBoolField(value: self.includeChildReceipts, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionGetReceiptQuery, rhs: Proto_TransactionGetReceiptQuery) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._transactionID != rhs._transactionID {return false}
    if lhs.includeDuplicates != rhs.includeDuplicates {return false}
    if lhs.includeChildReceipts != rhs.includeChildReceipts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TransactionGetReceiptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionGetReceiptResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "receipt"),
    4: .same(proto: "duplicateTransactionReceipts"),
    5: .standard(proto: "child_transaction_receipts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._receipt) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.duplicateTransactionReceipts) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.childTransactionReceipts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._receipt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.duplicateTransactionReceipts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.duplicateTransactionReceipts, fieldNumber: 4)
    }
    if !self.childTransactionReceipts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childTransactionReceipts, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_TransactionGetReceiptResponse, rhs: Proto_TransactionGetReceiptResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._receipt != rhs._receipt {return false}
    if lhs.duplicateTransactionReceipts != rhs.duplicateTransactionReceipts {return false}
    if lhs.childTransactionReceipts != rhs.childTransactionReceipts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
