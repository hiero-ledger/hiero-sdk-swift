// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/state/history/history_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// The phase of a WRAPS proof construction.
public enum Com_Hedera_Hapi_Node_State_History_WrapsPhase: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// Nodes are publishing their proof keys and R1 messages.
  case r1 // = 0

  ///*
  /// Nodes are publishing their R2 messages.
  case r2 // = 1

  ///*
  /// Nodes are publishing their R3 messages.
  case r3 // = 2

  ///*
  /// Nodes are aggregating all messages to produce a final signature.
  case aggregate // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .r1
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .r1
    case 1: self = .r2
    case 2: self = .r3
    case 3: self = .aggregate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .r1: return 0
    case .r2: return 1
    case .r3: return 2
    case .aggregate: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Com_Hedera_Hapi_Node_State_History_WrapsPhase] = [
    .r1,
    .r2,
    .r3,
    .aggregate,
  ]

}

///*
/// A set of proof keys for a node; that is, the key the node is
/// currently using and the key it wants to use in assembling the
/// next address book in the ledger id's chain of trust.
public struct Com_Hedera_Hapi_Node_State_History_ProofKeySet: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The consensus time when the network adopted the active
  /// proof key in this set. An adoption time that is sufficiently
  /// tardy relative to the latest assembly start time may result
  /// in the node's key being omitted from the address book.
  public var adoptionTime: Proto_Timestamp {
    get {return _adoptionTime ?? Proto_Timestamp()}
    set {_adoptionTime = newValue}
  }
  /// Returns true if `adoptionTime` has been explicitly set.
  public var hasAdoptionTime: Bool {return self._adoptionTime != nil}
  /// Clears the value of `adoptionTime`. Subsequent reads from it will return its default value.
  public mutating func clearAdoptionTime() {self._adoptionTime = nil}

  ///*
  /// The proof key the node is using.
  public var key: Data = Data()

  ///*
  /// If set, the proof key the node wants to start using in the
  /// address book.
  public var nextKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _adoptionTime: Proto_Timestamp? = nil
}

///*
/// A record of the proof key a node had in a particular address
/// book. Necessary to keep at each point history so that nodes
/// can verify the correct key was used to sign in transitions
/// starting from the current address book; no matter how keys
/// have been rotated from the time the address book was created.
public struct Com_Hedera_Hapi_Node_State_History_ProofKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The node id.
  public var nodeID: UInt64 = 0

  ///*
  /// The key.
  public var key: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A piece of new history in the form of an address book hash and
/// associated metadata.
public struct Com_Hedera_Hapi_Node_State_History_History: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The address book hash of the new history.
  public var addressBookHash: Data = Data()

  ///*
  /// The metadata associated to the address book.
  public var metadata: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A proof that some address book history belongs to the ledger id's chain of trust.
public struct Com_Hedera_Hapi_Node_State_History_HistoryProof: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The proof keys for the target address book, needed to keep
  /// constructing proofs after adopting the target address book's
  /// roster at a handoff.
  public var targetProofKeys: [Com_Hedera_Hapi_Node_State_History_ProofKey] = []

  ///*
  /// The target history of the proof.
  public var targetHistory: Com_Hedera_Hapi_Node_State_History_History {
    get {return _targetHistory ?? Com_Hedera_Hapi_Node_State_History_History()}
    set {_targetHistory = newValue}
  }
  /// Returns true if `targetHistory` has been explicitly set.
  public var hasTargetHistory: Bool {return self._targetHistory != nil}
  /// Clears the value of `targetHistory`. Subsequent reads from it will return its default value.
  public mutating func clearTargetHistory() {self._targetHistory = nil}

  ///*
  /// The proof of chain of trust from the ledger id to the target
  /// history's metadata. May be switched from AggregatedNodeSignatures
  /// to a recursive proof when one becomes available.
  public var chainOfTrustProof: Com_Hedera_Hapi_Block_Stream_ChainOfTrustProof {
    get {return _chainOfTrustProof ?? Com_Hedera_Hapi_Block_Stream_ChainOfTrustProof()}
    set {_chainOfTrustProof = newValue}
  }
  /// Returns true if `chainOfTrustProof` has been explicitly set.
  public var hasChainOfTrustProof: Bool {return self._chainOfTrustProof != nil}
  /// Clears the value of `chainOfTrustProof`. Subsequent reads from it will return its default value.
  public mutating func clearChainOfTrustProof() {self._chainOfTrustProof = nil}

  ///*
  /// If set, the uncompressed proof of chain of trust from the ledger id to
  /// the target address book; the uncompressed version of the WRAPS proof is
  /// required to keep extending the chain of trust.
  public var uncompressedWrapsProof: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _targetHistory: Com_Hedera_Hapi_Node_State_History_History? = nil
  fileprivate var _chainOfTrustProof: Com_Hedera_Hapi_Block_Stream_ChainOfTrustProof? = nil
}

///*
/// Summary of the status of constructing a metadata proof, necessary to
/// ensure deterministic construction ending in a roster with sufficient
/// weight to enact its own constructions.
public struct Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The construction id.
  public var constructionID: UInt64 = 0

  ///*
  /// The hash of the roster whose weights are used to determine when
  /// certain thresholds are during construction.
  public var sourceRosterHash: Data = Data()

  ///*
  /// The hash of the roster whose weights are used to assess progress
  /// toward obtaining proof keys for parties that hold at least a
  /// strong minority of the stake in that roster.
  public var targetRosterHash: Data = Data()

  public var proofState: Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction.OneOf_ProofState? = nil

  ///*
  /// If the network is still gathering proof keys for this
  /// construction, the next time at which nodes should stop waiting
  /// for tardy proof keys and assemble the history to be proven as
  /// soon as it has the associated metadata and proof keys for nodes
  /// with >2/3 weight in the target roster.
  public var gracePeriodEndTime: Proto_Timestamp {
    get {
      if case .gracePeriodEndTime(let v)? = proofState {return v}
      return Proto_Timestamp()
    }
    set {proofState = .gracePeriodEndTime(newValue)}
  }

  ///*
  /// If the network has gathered enough proof keys to assemble the
  /// history for this construction, the cutoff time at which those
  /// keys must have been adopted to be included in the final history.
  public var assemblyStartTime: Proto_Timestamp {
    get {
      if case .assemblyStartTime(let v)? = proofState {return v}
      return Proto_Timestamp()
    }
    set {proofState = .assemblyStartTime(newValue)}
  }

  ///*
  /// When this construction is complete, the proof that the target
  /// roster's address book and associated metadata belong to the
  /// ledger id's chain of trust.
  public var targetProof: Com_Hedera_Hapi_Node_State_History_HistoryProof {
    get {
      if case .targetProof(let v)? = proofState {return v}
      return Com_Hedera_Hapi_Node_State_History_HistoryProof()
    }
    set {proofState = .targetProof(newValue)}
  }

  ///*
  /// If set, the reason the construction failed.
  public var failureReason: String {
    get {
      if case .failureReason(let v)? = proofState {return v}
      return String()
    }
    set {proofState = .failureReason(newValue)}
  }

  ///*
  /// If set, the state of the WRAPS signing protocol for this construction.
  public var wrapsSigningState: Com_Hedera_Hapi_Node_State_History_WrapsSigningState {
    get {
      if case .wrapsSigningState(let v)? = proofState {return v}
      return Com_Hedera_Hapi_Node_State_History_WrapsSigningState()
    }
    set {proofState = .wrapsSigningState(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ProofState: Equatable, Sendable {
    ///*
    /// If the network is still gathering proof keys for this
    /// construction, the next time at which nodes should stop waiting
    /// for tardy proof keys and assemble the history to be proven as
    /// soon as it has the associated metadata and proof keys for nodes
    /// with >2/3 weight in the target roster.
    case gracePeriodEndTime(Proto_Timestamp)
    ///*
    /// If the network has gathered enough proof keys to assemble the
    /// history for this construction, the cutoff time at which those
    /// keys must have been adopted to be included in the final history.
    case assemblyStartTime(Proto_Timestamp)
    ///*
    /// When this construction is complete, the proof that the target
    /// roster's address book and associated metadata belong to the
    /// ledger id's chain of trust.
    case targetProof(Com_Hedera_Hapi_Node_State_History_HistoryProof)
    ///*
    /// If set, the reason the construction failed.
    case failureReason(String)
    ///*
    /// If set, the state of the WRAPS signing protocol for this construction.
    case wrapsSigningState(Com_Hedera_Hapi_Node_State_History_WrapsSigningState)

  }

  public init() {}
}

///*
/// The state of an ongoing WRAPS signature protocol.
public struct Com_Hedera_Hapi_Node_State_History_WrapsSigningState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The phase of the WRAPS protocol.
  public var phase: Com_Hedera_Hapi_Node_State_History_WrapsPhase = .r1

  ///*
  /// If the network is still gathering WRAPS messages for the R2 or R3
  /// protocol phase, the next time at which nodes should stop waiting
  /// for tardy messages from R1 participants and start over.
  /// soon as it has WRAPS messages from nodes with >2/3 weight in the
  /// target roster.
  public var gracePeriodEndTime: Proto_Timestamp {
    get {return _gracePeriodEndTime ?? Proto_Timestamp()}
    set {_gracePeriodEndTime = newValue}
  }
  /// Returns true if `gracePeriodEndTime` has been explicitly set.
  public var hasGracePeriodEndTime: Bool {return self._gracePeriodEndTime != nil}
  /// Clears the value of `gracePeriodEndTime`. Subsequent reads from it will return its default value.
  public mutating func clearGracePeriodEndTime() {self._gracePeriodEndTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gracePeriodEndTime: Proto_Timestamp? = nil
}

///*
/// A construction-scoped node id.
public struct Com_Hedera_Hapi_Node_State_History_ConstructionNodeId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The unique id of a history proof construction.
  public var constructionID: UInt64 = 0

  ///*
  /// The unique id of a node.
  public var nodeID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A node's vote for a particular history proof; either by explicitly
/// giving the proof, or by identifying a node that already voted for it.
public struct Com_Hedera_Hapi_Node_State_History_HistoryProofVote: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vote: Com_Hedera_Hapi_Node_State_History_HistoryProofVote.OneOf_Vote? = nil

  ///*
  /// The history proof the submitting node is voting for.
  public var proof: Com_Hedera_Hapi_Node_State_History_HistoryProof {
    get {
      if case .proof(let v)? = vote {return v}
      return Com_Hedera_Hapi_Node_State_History_HistoryProof()
    }
    set {vote = .proof(newValue)}
  }

  ///*
  /// The id of another node that already voted for the exact proof
  /// the submitting node is voting for.
  public var congruentNodeID: UInt64 {
    get {
      if case .congruentNodeID(let v)? = vote {return v}
      return 0
    }
    set {vote = .congruentNodeID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Vote: Equatable, Sendable {
    ///*
    /// The history proof the submitting node is voting for.
    case proof(Com_Hedera_Hapi_Node_State_History_HistoryProof)
    ///*
    /// The id of another node that already voted for the exact proof
    /// the submitting node is voting for.
    case congruentNodeID(UInt64)

  }

  public init() {}
}

///*
/// A node's signature blessing some new history.
public struct Com_Hedera_Hapi_Node_State_History_HistorySignature: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The new history the node is signing.
  public var history: Com_Hedera_Hapi_Node_State_History_History {
    get {return _history ?? Com_Hedera_Hapi_Node_State_History_History()}
    set {_history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  public var hasHistory: Bool {return self._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  public mutating func clearHistory() {self._history = nil}

  ///*
  /// The node's signature on the canonical serialization of
  /// the new history.
  public var signature: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _history: Com_Hedera_Hapi_Node_State_History_History? = nil
}

///*
/// A signature on some new history recorded at a certain time.
public struct Com_Hedera_Hapi_Node_State_History_RecordedHistorySignature: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The time at which the signature was recorded.
  public var signingTime: Proto_Timestamp {
    get {return _signingTime ?? Proto_Timestamp()}
    set {_signingTime = newValue}
  }
  /// Returns true if `signingTime` has been explicitly set.
  public var hasSigningTime: Bool {return self._signingTime != nil}
  /// Clears the value of `signingTime`. Subsequent reads from it will return its default value.
  public mutating func clearSigningTime() {self._signingTime = nil}

  ///*
  /// The signature on some new history.
  public var historySignature: Com_Hedera_Hapi_Node_State_History_HistorySignature {
    get {return _historySignature ?? Com_Hedera_Hapi_Node_State_History_HistorySignature()}
    set {_historySignature = newValue}
  }
  /// Returns true if `historySignature` has been explicitly set.
  public var hasHistorySignature: Bool {return self._historySignature != nil}
  /// Clears the value of `historySignature`. Subsequent reads from it will return its default value.
  public mutating func clearHistorySignature() {self._historySignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _signingTime: Proto_Timestamp? = nil
  fileprivate var _historySignature: Com_Hedera_Hapi_Node_State_History_HistorySignature? = nil
}

///*
/// A message published by a node during a WRAPS proof construction.
public struct Com_Hedera_Hapi_Node_State_History_WrapsMessageDetails: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The time at which the message was published.
  public var publicationTime: Proto_Timestamp {
    get {return _publicationTime ?? Proto_Timestamp()}
    set {_publicationTime = newValue}
  }
  /// Returns true if `publicationTime` has been explicitly set.
  public var hasPublicationTime: Bool {return self._publicationTime != nil}
  /// Clears the value of `publicationTime`. Subsequent reads from it will return its default value.
  public mutating func clearPublicationTime() {self._publicationTime = nil}

  ///*
  /// The phase of the construction the message applies to.
  public var phase: Com_Hedera_Hapi_Node_State_History_WrapsPhase = .r1

  ///*
  /// The message itself.
  public var message: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _publicationTime: Proto_Timestamp? = nil
}

///*
/// A history of messages published during a WRAPS proof construction.
public struct Com_Hedera_Hapi_Node_State_History_WrapsMessageHistory: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The published messages.
  public var messages: [Com_Hedera_Hapi_Node_State_History_WrapsMessageDetails] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.hedera.hapi.node.state.history"

extension Com_Hedera_Hapi_Node_State_History_WrapsPhase: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "R1"),
    1: .same(proto: "R2"),
    2: .same(proto: "R3"),
    3: .same(proto: "AGGREGATE"),
  ]
}

extension Com_Hedera_Hapi_Node_State_History_ProofKeySet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProofKeySet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "adoption_time"),
    3: .same(proto: "key"),
    4: .standard(proto: "next_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._adoptionTime) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nextKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._adoptionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 3)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_ProofKeySet, rhs: Com_Hedera_Hapi_Node_State_History_ProofKeySet) -> Bool {
    if lhs._adoptionTime != rhs._adoptionTime {return false}
    if lhs.key != rhs.key {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_ProofKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProofKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.nodeID, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_ProofKey, rhs: Com_Hedera_Hapi_Node_State_History_ProofKey) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_History: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".History"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "address_book_hash"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.addressBookHash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addressBookHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.addressBookHash, fieldNumber: 1)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_History, rhs: Com_Hedera_Hapi_Node_State_History_History) -> Bool {
    if lhs.addressBookHash != rhs.addressBookHash {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_HistoryProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoryProof"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_proof_keys"),
    2: .standard(proto: "target_history"),
    3: .standard(proto: "chain_of_trust_proof"),
    4: .standard(proto: "uncompressed_wraps_proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.targetProofKeys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._targetHistory) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._chainOfTrustProof) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.uncompressedWrapsProof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetProofKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targetProofKeys, fieldNumber: 1)
    }
    try { if let v = self._targetHistory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._chainOfTrustProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.uncompressedWrapsProof.isEmpty {
      try visitor.visitSingularBytesField(value: self.uncompressedWrapsProof, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_HistoryProof, rhs: Com_Hedera_Hapi_Node_State_History_HistoryProof) -> Bool {
    if lhs.targetProofKeys != rhs.targetProofKeys {return false}
    if lhs._targetHistory != rhs._targetHistory {return false}
    if lhs._chainOfTrustProof != rhs._chainOfTrustProof {return false}
    if lhs.uncompressedWrapsProof != rhs.uncompressedWrapsProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoryProofConstruction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "construction_id"),
    2: .standard(proto: "source_roster_hash"),
    4: .standard(proto: "target_roster_hash"),
    5: .standard(proto: "grace_period_end_time"),
    6: .standard(proto: "assembly_start_time"),
    7: .standard(proto: "target_proof"),
    8: .standard(proto: "failure_reason"),
    9: .standard(proto: "wraps_signing_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.constructionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sourceRosterHash) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.targetRosterHash) }()
      case 5: try {
        var v: Proto_Timestamp?
        var hadOneofValue = false
        if let current = self.proofState {
          hadOneofValue = true
          if case .gracePeriodEndTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proofState = .gracePeriodEndTime(v)
        }
      }()
      case 6: try {
        var v: Proto_Timestamp?
        var hadOneofValue = false
        if let current = self.proofState {
          hadOneofValue = true
          if case .assemblyStartTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proofState = .assemblyStartTime(v)
        }
      }()
      case 7: try {
        var v: Com_Hedera_Hapi_Node_State_History_HistoryProof?
        var hadOneofValue = false
        if let current = self.proofState {
          hadOneofValue = true
          if case .targetProof(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proofState = .targetProof(v)
        }
      }()
      case 8: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.proofState != nil {try decoder.handleConflictingOneOf()}
          self.proofState = .failureReason(v)
        }
      }()
      case 9: try {
        var v: Com_Hedera_Hapi_Node_State_History_WrapsSigningState?
        var hadOneofValue = false
        if let current = self.proofState {
          hadOneofValue = true
          if case .wrapsSigningState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proofState = .wrapsSigningState(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.constructionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.constructionID, fieldNumber: 1)
    }
    if !self.sourceRosterHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.sourceRosterHash, fieldNumber: 2)
    }
    if !self.targetRosterHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.targetRosterHash, fieldNumber: 4)
    }
    switch self.proofState {
    case .gracePeriodEndTime?: try {
      guard case .gracePeriodEndTime(let v)? = self.proofState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .assemblyStartTime?: try {
      guard case .assemblyStartTime(let v)? = self.proofState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .targetProof?: try {
      guard case .targetProof(let v)? = self.proofState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .failureReason?: try {
      guard case .failureReason(let v)? = self.proofState else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }()
    case .wrapsSigningState?: try {
      guard case .wrapsSigningState(let v)? = self.proofState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction, rhs: Com_Hedera_Hapi_Node_State_History_HistoryProofConstruction) -> Bool {
    if lhs.constructionID != rhs.constructionID {return false}
    if lhs.sourceRosterHash != rhs.sourceRosterHash {return false}
    if lhs.targetRosterHash != rhs.targetRosterHash {return false}
    if lhs.proofState != rhs.proofState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_WrapsSigningState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WrapsSigningState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phase"),
    2: .standard(proto: "grace_period_end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.phase) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gracePeriodEndTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.phase != .r1 {
      try visitor.visitSingularEnumField(value: self.phase, fieldNumber: 1)
    }
    try { if let v = self._gracePeriodEndTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_WrapsSigningState, rhs: Com_Hedera_Hapi_Node_State_History_WrapsSigningState) -> Bool {
    if lhs.phase != rhs.phase {return false}
    if lhs._gracePeriodEndTime != rhs._gracePeriodEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_ConstructionNodeId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConstructionNodeId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "construction_id"),
    2: .standard(proto: "node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.constructionID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nodeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.constructionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.constructionID, fieldNumber: 1)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.nodeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_ConstructionNodeId, rhs: Com_Hedera_Hapi_Node_State_History_ConstructionNodeId) -> Bool {
    if lhs.constructionID != rhs.constructionID {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_HistoryProofVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoryProofVote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proof"),
    2: .standard(proto: "congruent_node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Hedera_Hapi_Node_State_History_HistoryProof?
        var hadOneofValue = false
        if let current = self.vote {
          hadOneofValue = true
          if case .proof(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vote = .proof(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.vote != nil {try decoder.handleConflictingOneOf()}
          self.vote = .congruentNodeID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.vote {
    case .proof?: try {
      guard case .proof(let v)? = self.vote else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .congruentNodeID?: try {
      guard case .congruentNodeID(let v)? = self.vote else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_HistoryProofVote, rhs: Com_Hedera_Hapi_Node_State_History_HistoryProofVote) -> Bool {
    if lhs.vote != rhs.vote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_HistorySignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistorySignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "history"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_HistorySignature, rhs: Com_Hedera_Hapi_Node_State_History_HistorySignature) -> Bool {
    if lhs._history != rhs._history {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_RecordedHistorySignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordedHistorySignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signing_time"),
    2: .standard(proto: "history_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signingTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._historySignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signingTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._historySignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_RecordedHistorySignature, rhs: Com_Hedera_Hapi_Node_State_History_RecordedHistorySignature) -> Bool {
    if lhs._signingTime != rhs._signingTime {return false}
    if lhs._historySignature != rhs._historySignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_WrapsMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WrapsMessageDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publication_time"),
    2: .same(proto: "phase"),
    3: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicationTime) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.phase) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.phase != .r1 {
      try visitor.visitSingularEnumField(value: self.phase, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_WrapsMessageDetails, rhs: Com_Hedera_Hapi_Node_State_History_WrapsMessageDetails) -> Bool {
    if lhs._publicationTime != rhs._publicationTime {return false}
    if lhs.phase != rhs.phase {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_History_WrapsMessageHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WrapsMessageHistory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_History_WrapsMessageHistory, rhs: Com_Hedera_Hapi_Node_State_History_WrapsMessageHistory) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
