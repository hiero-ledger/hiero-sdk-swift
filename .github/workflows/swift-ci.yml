name: Swift CI
on:
  pull_request:
  push: 
    branches: ['main']

defaults:
  run:
    shell: bash

permissions:
  contents: read

jobs:
  format:
    runs-on: macos-latest
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
        with:
          egress-policy: audit

      - name: Checkout Code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Install swift-format
        run: brew install swift-format

      - name: Format
        run: swift format lint --strict --configuration .swift-format.json --recursive --parallel Sources/ Tests/ Examples/ Package.swift

  build:
    strategy:
      matrix:
        swift: ["5.9", "5.10"]
        os: [macos-13, macos-14]

    runs-on: ${{ matrix.os }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
        with:
          egress-policy: audit

      - name: Setup Swift
        uses: swift-actions/setup-swift@3aed395c5397f62deb91d8fe7af1418a9ae4d16f # v2.1.0
        with:
          swift-version: ${{ matrix.swift }}

      - name: Checkout Code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Cache
        uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57 # v4.2.0
        with:
          path: sdk/swift/.build
          key: ${{ runner.os }}-${{ matrix.swift }}-spm-${{ github.job }}-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.swift }}-spm-

      - name: Build
        run: swift build

  test:
    strategy:
      matrix:
        swift: ["5.9", "5.10"]
        os: [macos-13, macos-14]

    needs: [build]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@0080882f6c36860b6ba35c610c98ce87d4e2f26f # v2.10.2
        with:
          egress-policy: audit

      - name: Setup Swift
        uses: swift-actions/setup-swift@3aed395c5397f62deb91d8fe7af1418a9ae4d16f # v2.1.0
        with:
          swift-version: ${{ matrix.swift }}

      - name: Checkout Code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Cache Code
        uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57 # v4.2.0
        with:
          path: sdk/swift/.build
          key: ${{ runner.os }}-${{ matrix.swift }}-spm-${{ github.job }}-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.swift }}-spm-

      - name: Cleanup Previous Runs
        shell: bash
        run: |
          rm -rf ~/.solo
          kind delete cluster --name solo-e2e || true

      - name: Install Solo
        shell: bash
        run: npm install -g @hashgraph/solo@${{ inputs.soloVersion }}

      - name: Deploy Solo Test Network
        shell: bash
        env:
          SOLO_CLUSTER_NAME: solo-e2e
          SOLO_NAMESPACE: solo
          SOLO_CLUSTER_SETUP_NAMESPACE: solo-cluster
          SOLO_DEPLOYMENT: solo-deployment
          HIERO_VERSION: ${{ inputs.hieroVersion }}
        run: |
          # Create a Kubernetes cluster using kind
          kind create cluster -n $SOLO_CLUSTER_NAME

          # Initialize the Solo CLI configuration
          solo init

          # Connect the Solo CLI to the kind cluster using a cluster reference name
          solo cluster-ref connect --cluster-ref kind-$SOLO_CLUSTER_NAME --context kind-$SOLO_CLUSTER_NAME

          # Create deployment
          solo deployment create -n $SOLO_NAMESPACE --deployment $SOLO_DEPLOYMENT

          # Add the kind cluster to the deployment with 1 consensus node
          solo deployment add-cluster --deployment $SOLO_DEPLOYMENT --cluster-ref kind-$SOLO_CLUSTER_NAME --num-consensus-nodes 1

          # Generate node keys
          solo node keys --gossip-keys --tls-keys -i node1 --deployment $SOLO_DEPLOYMENT

          # Setup the Solo cluster
          solo cluster-ref setup -s $SOLO_CLUSTER_NAME

          # Deploy network
          solo network deploy -i node1 --deployment $SOLO_DEPLOYMENT

          # Setup node
          solo node setup -i node1 --deployment $SOLO_DEPLOYMENT -t $HIERO_VERSION --quiet-mode

          # Start node
          solo node start -i node1 --deployment $SOLO_DEPLOYMENT

          # Debug: List services in the solo namespace
          echo "Listing services in namespace $SOLO_NAMESPACE:"
          kubectl get svc -n $SOLO_NAMESPACE

          # Port forward HAProxy (only if service exists)
          if kubectl get svc haproxy-node1-svc -n $SOLO_NAMESPACE >/dev/null 2>&1; then
            kubectl port-forward svc/haproxy-node1-svc -n $SOLO_NAMESPACE ${{ inputs.haproxyPort }}:50211 &
          else
            echo "HAProxy service haproxy-node1-svc not found, skipping port-forward"
          fi
          
          # Port forward gRPC proxy (only if service exists)
          if kubectl get svc envoy-proxy-node1-svc -n $SOLO_NAMESPACE >/dev/null 2>&1; then
            kubectl port-forward svc/envoy-proxy-node1-svc -n $SOLO_NAMESPACE ${{ inputs.grpcProxyPort }}:8080 &
          else
            echo "gRPC proxy service envoy-proxy-node1-svc not found, skipping port-forward"
          fi

      - name: Deploy MirrorNode
        if: ${{ inputs.installMirrorNode == 'true' }} # see https://github.com/actions/runner/issues/2238
        shell: bash
        env:
          SOLO_NAMESPACE: solo
          SOLO_DEPLOYMENT: solo-deployment
          MIRROR_NODE_VERSION: ${{ inputs.mirrorNodeVersion }}
        run: |
          solo mirror-node deploy --deployment $SOLO_DEPLOYMENT --mirror-node-version $MIRROR_NODE_VERSION --pinger
          # Debug: List services in the solo namespace
          echo "Listing services in namespace $SOLO_NAMESPACE:"
          kubectl get svc -n $SOLO_NAMESPACE
          # Port forward mirror node REST API (only if service exists)
          if kubectl get svc mirror-rest -n $SOLO_NAMESPACE >/dev/null 2>&1; then
            kubectl port-forward svc/mirror-rest -n $SOLO_NAMESPACE ${{ inputs.mirrorNodePortRest }}:80 &
          else
            echo "Mirror node service mirror-rest not found, skipping port-forward"
          fi
          # Port forward mirror node gRPC (only if service exists)
          if kubectl get svc mirror-grpc -n $SOLO_NAMESPACE >/dev/null 2>&1; then
            kubectl port-forward svc/mirror-grpc -n $SOLO_NAMESPACE ${{ inputs.mirrorNodePortGrpc }}:5600 &
          else
            echo "Mirror node service mirror-grpc not found, skipping port-forward"
          fi
          # Port forward mirror node web3 (only if service exists)
          if kubectl get svc mirror-web3 -n $SOLO_NAMESPACE >/dev/null 2>&1; then
            kubectl port-forward svc/mirror-web3 -n $SOLO_NAMESPACE ${{ inputs.mirrorNodePortWeb3Rest }}:80 &
          else
            echo "Mirror node service mirror-web3 not found, skipping port-forward"
          fi
          # Port forward Java REST API (only if service exists)
          if kubectl get svc mirror-restjava -n $SOLO_NAMESPACE >/dev/null 2>&1; then
            kubectl port-forward svc/mirror-restjava -n $SOLO_NAMESPACE ${{ inputs.javaRestApiPort }}:80 &
          else
            echo "Java REST API service mirror-restjava not found, skipping port-forward"
          fi

      - name: Test
        run: swift test
