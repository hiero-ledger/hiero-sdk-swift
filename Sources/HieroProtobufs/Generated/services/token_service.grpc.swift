//
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the protocol buffer compiler.
// Source: services/token_service.proto
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


///*
/// Transactions and queries for the Token Service
///
/// Usage: instantiate `Proto_TokenServiceClient`, then call methods of this protocol to make API calls.
public protocol Proto_TokenServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol? { get }

  func createToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func updateToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func mintToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func burnToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func deleteToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func wipeTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func freezeTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func unfreezeTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func grantKycToTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func revokeKycFromTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func associateTokens(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func dissociateTokens(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func updateTokenFeeSchedule(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func getTokenInfo(
    _ request: Proto_Query,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Query, Proto_Response>

  func getTokenNftInfo(
    _ request: Proto_Query,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Query, Proto_Response>

  func pauseToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func unpauseToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func updateNfts(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func rejectToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func airdropTokens(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func cancelAirdrop(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func claimAirdrop(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse>
}

extension Proto_TokenServiceClientProtocol {
  public var serviceName: String {
    return "proto.TokenService"
  }

  ///*
  /// Create a new token.
  ///
  /// - Parameters:
  ///   - request: Request to send to createToken.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func createToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.createToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateTokenInterceptors() ?? []
    )
  }

  ///*
  /// Update a token.
  ///
  /// - Parameters:
  ///   - request: Request to send to updateToken.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func updateToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.updateToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTokenInterceptors() ?? []
    )
  }

  ///*
  /// Mint one or more tokens to the treasury account.
  /// <p>
  /// This MAY specify a quantity of fungible/common tokens or
  /// a list of specific non-fungible/unique tokes, but
  /// MUST NOT specify both.
  ///
  /// - Parameters:
  ///   - request: Request to send to mintToken.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func mintToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.mintToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makemintTokenInterceptors() ?? []
    )
  }

  ///*
  /// Burn one or more tokens from the treasury account.
  /// <p>
  /// This MAY specify a quantity of fungible/common tokens or
  /// a list of specific non-fungible/unique tokes, but
  /// MUST NOT specify both.
  ///
  /// - Parameters:
  ///   - request: Request to send to burnToken.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func burnToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.burnToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeburnTokenInterceptors() ?? []
    )
  }

  ///*
  /// Delete a token.
  ///
  /// - Parameters:
  ///   - request: Request to send to deleteToken.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func deleteToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.deleteToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteTokenInterceptors() ?? []
    )
  }

  ///*
  /// Wipe one or more tokens from an identified Account.
  /// <p>
  /// This MAY specify a quantity of fungible/common tokens or
  /// a list of specific non-fungible/unique tokes, but
  /// MUST NOT specify both.
  ///
  /// - Parameters:
  ///   - request: Request to send to wipeTokenAccount.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func wipeTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.wipeTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makewipeTokenAccountInterceptors() ?? []
    )
  }

  ///*
  /// Freeze the transfer of tokens to or from an identified Account.
  ///
  /// - Parameters:
  ///   - request: Request to send to freezeTokenAccount.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func freezeTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.freezeTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makefreezeTokenAccountInterceptors() ?? []
    )
  }

  ///*
  /// Unfreeze the transfer of tokens to or from an identified Account.
  ///
  /// - Parameters:
  ///   - request: Request to send to unfreezeTokenAccount.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func unfreezeTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.unfreezeTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeunfreezeTokenAccountInterceptors() ?? []
    )
  }

  ///*
  /// Assert that KYC requirements are met for a specific account with
  /// respect to a specific token.
  ///
  /// - Parameters:
  ///   - request: Request to send to grantKycToTokenAccount.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func grantKycToTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.grantKycToTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegrantKycToTokenAccountInterceptors() ?? []
    )
  }

  ///*
  /// Assert that KYC requirements are _not_ met for a specific account with
  /// respect to a specific token.
  ///
  /// - Parameters:
  ///   - request: Request to send to revokeKycFromTokenAccount.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func revokeKycFromTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.revokeKycFromTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makerevokeKycFromTokenAccountInterceptors() ?? []
    )
  }

  ///*
  /// Associate one or more tokens to an account.
  ///
  /// - Parameters:
  ///   - request: Request to send to associateTokens.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func associateTokens(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.associateTokens.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeassociateTokensInterceptors() ?? []
    )
  }

  ///*
  /// Dissociate one or more tokens from an account.
  ///
  /// - Parameters:
  ///   - request: Request to send to dissociateTokens.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func dissociateTokens(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.dissociateTokens.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedissociateTokensInterceptors() ?? []
    )
  }

  ///*
  /// Update the custom fee schedule for a token.
  ///
  /// - Parameters:
  ///   - request: Request to send to updateTokenFeeSchedule.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func updateTokenFeeSchedule(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.updateTokenFeeSchedule.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTokenFeeScheduleInterceptors() ?? []
    )
  }

  ///*
  /// Retrieve the detail characteristics for a token.
  /// <p>
  /// This query SHALL return information for the token type as a whole.<br/>
  /// This query SHALL NOT return information for individual tokens.
  ///
  /// - Parameters:
  ///   - request: Request to send to getTokenInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getTokenInfo(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Query, Proto_Response> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.getTokenInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTokenInfoInterceptors() ?? []
    )
  }

  ///*
  /// Retrieve the metadata for a specific non-fungible/unique token.<br/>
  /// The NFT to query is identified by token identifier and serial number.
  /// <p>
  /// This query SHALL return token metadata and, if an allowance is defined,
  /// the designated "spender" account for the queried NFT.
  ///
  /// - Parameters:
  ///   - request: Request to send to getTokenNftInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getTokenNftInfo(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Query, Proto_Response> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.getTokenNftInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTokenNftInfoInterceptors() ?? []
    )
  }

  ///*
  /// Pause a token.
  ///
  /// - Parameters:
  ///   - request: Request to send to pauseToken.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func pauseToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.pauseToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makepauseTokenInterceptors() ?? []
    )
  }

  ///*
  /// Unpause (resume) a token.
  ///
  /// - Parameters:
  ///   - request: Request to send to unpauseToken.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func unpauseToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.unpauseToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeunpauseTokenInterceptors() ?? []
    )
  }

  ///*
  /// Update multiple non-fungible/unique tokens (NFTs) in a collection.<br/>
  /// The NFTs are identified by token identifier and one or more
  /// serial numbers.
  /// <p>
  /// This transaction SHALL update NFT metadata only.<br/>
  /// This transaction MUST be signed by the token `metadata_key`.
  ///
  /// - Parameters:
  ///   - request: Request to send to updateNfts.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func updateNfts(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.updateNfts.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateNftsInterceptors() ?? []
    )
  }

  ///*
  /// Reject one or more tokens.
  /// <p>
  /// This transaction SHALL transfer the full balance of one or more tokens
  /// from the requesting account to the treasury for each token.<br/>
  /// This transfer SHALL NOT charge any custom fee or royalty defined for
  /// the token(s) to be rejected.<br/>
  /// ### Effects on success
  /// <ul>
  ///   <li>If the rejected token is fungible/common, the requesting account
  ///       SHALL have a balance of 0 for the rejected token.<br/>
  ///       The treasury balance SHALL increase by the amount that the
  ///       requesting account decreased.</li>
  ///   <li>If the rejected token is non-fungible/unique the requesting
  ///       account SHALL NOT hold the specific serialized token that
  ///       is rejected.<br/>
  ///       The treasury account SHALL hold each specific serialized token
  ///       that was rejected.</li>
  /// </li>
  ///
  /// - Parameters:
  ///   - request: Request to send to rejectToken.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func rejectToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.rejectToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makerejectTokenInterceptors() ?? []
    )
  }

  ///*
  /// Airdrop one or more tokens to one or more accounts.
  /// <p>
  /// This transaction SHALL distribute tokens from the balance of one or
  /// more sending account(s) to the balance of one or more
  /// recipient accounts.<br/>
  /// Accounts SHALL receive the tokens in one of four ways.
  /// <ul>
  ///   <li>An account already associated to the token to be distributed
  ///       SHALL receive the airdropped tokens immediately to the
  ///       recipient account balance.</li>
  ///   <li>An account with available automatic association slots SHALL
  ///       be automatically associated to the token, and SHALL
  ///       immediately receive the airdropped tokens to the recipient
  ///       account balance.</li>
  ///   <li>An account with "receiver signature required" set SHALL have
  ///       a "Pending Airdrop" created and MUST claim that airdrop with
  ///       a `claimAirdrop` transaction.</li>
  ///   <li>An account with no available automatic association slots SHALL
  ///       have a "Pending Airdrop" created and MUST claim that airdrop
  ///       with a `claimAirdrop` transaction. </li>
  /// </ul>
  /// Any airdrop that completes immediately SHALL be irreversible.<br/>
  /// Any airdrop that results in a "Pending Airdrop" MAY be canceled via
  /// a `cancelAirdrop` transaction.<br/>
  /// All transfer fees (including custom fees and royalties), as well as
  /// the rent cost for the first auto-renewal period for any
  /// automatic-association slot occupied by the airdropped tokens,
  /// SHALL be charged to the account submitting this transaction.
  ///
  /// - Parameters:
  ///   - request: Request to send to airdropTokens.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func airdropTokens(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.airdropTokens.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeairdropTokensInterceptors() ?? []
    )
  }

  ///*
  /// Cancel one or more pending airdrops.
  /// <p>
  /// This transaction MUST be signed by _each_ account *sending* an
  /// airdrop to be canceled.
  ///
  /// - Parameters:
  ///   - request: Request to send to cancelAirdrop.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func cancelAirdrop(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.cancelAirdrop.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecancelAirdropInterceptors() ?? []
    )
  }

  ///*
  /// Claim one or more pending airdrops.
  /// <p>
  /// This transaction MUST be signed by _each_ account **receiving**
  /// an airdrop to be claimed.<br>
  /// If a "Sender" lacks sufficient balance to fulfill the airdrop at
  /// the time the claim is made, that claim SHALL fail.
  ///
  /// - Parameters:
  ///   - request: Request to send to claimAirdrop.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func claimAirdrop(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.claimAirdrop.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeclaimAirdropInterceptors() ?? []
    )
  }
}

@available(*, deprecated)
extension Proto_TokenServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Proto_TokenServiceNIOClient")
public final class Proto_TokenServiceClient: Proto_TokenServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol?
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  public var interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the proto.TokenService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

public struct Proto_TokenServiceNIOClient: Proto_TokenServiceClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the proto.TokenService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

///*
/// Transactions and queries for the Token Service
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Proto_TokenServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol? { get }

  func makeCreateTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeUpdateTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeMintTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeBurnTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeDeleteTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeWipeTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeFreezeTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeUnfreezeTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeGrantKycToTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeRevokeKycFromTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeAssociateTokensCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeDissociateTokensCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeUpdateTokenFeeScheduleCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeGetTokenInfoCall(
    _ request: Proto_Query,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response>

  func makeGetTokenNftInfoCall(
    _ request: Proto_Query,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response>

  func makePauseTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeUnpauseTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeUpdateNftsCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeRejectTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeAirdropTokensCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeCancelAirdropCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>

  func makeClaimAirdropCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Proto_TokenServiceAsyncClientProtocol {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Proto_TokenServiceClientMetadata.serviceDescriptor
  }

  public var interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  public func makeCreateTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.createToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateTokenInterceptors() ?? []
    )
  }

  public func makeUpdateTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.updateToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTokenInterceptors() ?? []
    )
  }

  public func makeMintTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.mintToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makemintTokenInterceptors() ?? []
    )
  }

  public func makeBurnTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.burnToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeburnTokenInterceptors() ?? []
    )
  }

  public func makeDeleteTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.deleteToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteTokenInterceptors() ?? []
    )
  }

  public func makeWipeTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.wipeTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makewipeTokenAccountInterceptors() ?? []
    )
  }

  public func makeFreezeTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.freezeTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makefreezeTokenAccountInterceptors() ?? []
    )
  }

  public func makeUnfreezeTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.unfreezeTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeunfreezeTokenAccountInterceptors() ?? []
    )
  }

  public func makeGrantKycToTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.grantKycToTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegrantKycToTokenAccountInterceptors() ?? []
    )
  }

  public func makeRevokeKycFromTokenAccountCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.revokeKycFromTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makerevokeKycFromTokenAccountInterceptors() ?? []
    )
  }

  public func makeAssociateTokensCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.associateTokens.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeassociateTokensInterceptors() ?? []
    )
  }

  public func makeDissociateTokensCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.dissociateTokens.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedissociateTokensInterceptors() ?? []
    )
  }

  public func makeUpdateTokenFeeScheduleCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.updateTokenFeeSchedule.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTokenFeeScheduleInterceptors() ?? []
    )
  }

  public func makeGetTokenInfoCall(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.getTokenInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTokenInfoInterceptors() ?? []
    )
  }

  public func makeGetTokenNftInfoCall(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Query, Proto_Response> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.getTokenNftInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTokenNftInfoInterceptors() ?? []
    )
  }

  public func makePauseTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.pauseToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makepauseTokenInterceptors() ?? []
    )
  }

  public func makeUnpauseTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.unpauseToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeunpauseTokenInterceptors() ?? []
    )
  }

  public func makeUpdateNftsCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.updateNfts.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateNftsInterceptors() ?? []
    )
  }

  public func makeRejectTokenCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.rejectToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makerejectTokenInterceptors() ?? []
    )
  }

  public func makeAirdropTokensCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.airdropTokens.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeairdropTokensInterceptors() ?? []
    )
  }

  public func makeCancelAirdropCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.cancelAirdrop.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecancelAirdropInterceptors() ?? []
    )
  }

  public func makeClaimAirdropCall(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Proto_Transaction, Proto_TransactionResponse> {
    return self.makeAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.claimAirdrop.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeclaimAirdropInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Proto_TokenServiceAsyncClientProtocol {
  public func createToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.createToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecreateTokenInterceptors() ?? []
    )
  }

  public func updateToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.updateToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTokenInterceptors() ?? []
    )
  }

  public func mintToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.mintToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makemintTokenInterceptors() ?? []
    )
  }

  public func burnToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.burnToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeburnTokenInterceptors() ?? []
    )
  }

  public func deleteToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.deleteToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedeleteTokenInterceptors() ?? []
    )
  }

  public func wipeTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.wipeTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makewipeTokenAccountInterceptors() ?? []
    )
  }

  public func freezeTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.freezeTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makefreezeTokenAccountInterceptors() ?? []
    )
  }

  public func unfreezeTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.unfreezeTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeunfreezeTokenAccountInterceptors() ?? []
    )
  }

  public func grantKycToTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.grantKycToTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegrantKycToTokenAccountInterceptors() ?? []
    )
  }

  public func revokeKycFromTokenAccount(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.revokeKycFromTokenAccount.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makerevokeKycFromTokenAccountInterceptors() ?? []
    )
  }

  public func associateTokens(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.associateTokens.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeassociateTokensInterceptors() ?? []
    )
  }

  public func dissociateTokens(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.dissociateTokens.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedissociateTokensInterceptors() ?? []
    )
  }

  public func updateTokenFeeSchedule(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.updateTokenFeeSchedule.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTokenFeeScheduleInterceptors() ?? []
    )
  }

  public func getTokenInfo(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_Response {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.getTokenInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTokenInfoInterceptors() ?? []
    )
  }

  public func getTokenNftInfo(
    _ request: Proto_Query,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_Response {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.getTokenNftInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makegetTokenNftInfoInterceptors() ?? []
    )
  }

  public func pauseToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.pauseToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makepauseTokenInterceptors() ?? []
    )
  }

  public func unpauseToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.unpauseToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeunpauseTokenInterceptors() ?? []
    )
  }

  public func updateNfts(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.updateNfts.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateNftsInterceptors() ?? []
    )
  }

  public func rejectToken(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.rejectToken.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makerejectTokenInterceptors() ?? []
    )
  }

  public func airdropTokens(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.airdropTokens.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeairdropTokensInterceptors() ?? []
    )
  }

  public func cancelAirdrop(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.cancelAirdrop.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makecancelAirdropInterceptors() ?? []
    )
  }

  public func claimAirdrop(
    _ request: Proto_Transaction,
    callOptions: CallOptions? = nil
  ) async throws -> Proto_TransactionResponse {
    return try await self.performAsyncUnaryCall(
      path: Proto_TokenServiceClientMetadata.Methods.claimAirdrop.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeclaimAirdropInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct Proto_TokenServiceAsyncClient: Proto_TokenServiceAsyncClientProtocol {
  public var channel: GRPCChannel
  public var defaultCallOptions: CallOptions
  public var interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol?

  public init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Proto_TokenServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

public protocol Proto_TokenServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'createToken'.
  func makecreateTokenInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'updateToken'.
  func makeupdateTokenInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'mintToken'.
  func makemintTokenInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'burnToken'.
  func makeburnTokenInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'deleteToken'.
  func makedeleteTokenInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'wipeTokenAccount'.
  func makewipeTokenAccountInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'freezeTokenAccount'.
  func makefreezeTokenAccountInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'unfreezeTokenAccount'.
  func makeunfreezeTokenAccountInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'grantKycToTokenAccount'.
  func makegrantKycToTokenAccountInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'revokeKycFromTokenAccount'.
  func makerevokeKycFromTokenAccountInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'associateTokens'.
  func makeassociateTokensInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'dissociateTokens'.
  func makedissociateTokensInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'updateTokenFeeSchedule'.
  func makeupdateTokenFeeScheduleInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'getTokenInfo'.
  func makegetTokenInfoInterceptors() -> [ClientInterceptor<Proto_Query, Proto_Response>]

  /// - Returns: Interceptors to use when invoking 'getTokenNftInfo'.
  func makegetTokenNftInfoInterceptors() -> [ClientInterceptor<Proto_Query, Proto_Response>]

  /// - Returns: Interceptors to use when invoking 'pauseToken'.
  func makepauseTokenInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'unpauseToken'.
  func makeunpauseTokenInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'updateNfts'.
  func makeupdateNftsInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'rejectToken'.
  func makerejectTokenInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'airdropTokens'.
  func makeairdropTokensInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'cancelAirdrop'.
  func makecancelAirdropInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when invoking 'claimAirdrop'.
  func makeclaimAirdropInterceptors() -> [ClientInterceptor<Proto_Transaction, Proto_TransactionResponse>]
}

public enum Proto_TokenServiceClientMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "TokenService",
    fullName: "proto.TokenService",
    methods: [
      Proto_TokenServiceClientMetadata.Methods.createToken,
      Proto_TokenServiceClientMetadata.Methods.updateToken,
      Proto_TokenServiceClientMetadata.Methods.mintToken,
      Proto_TokenServiceClientMetadata.Methods.burnToken,
      Proto_TokenServiceClientMetadata.Methods.deleteToken,
      Proto_TokenServiceClientMetadata.Methods.wipeTokenAccount,
      Proto_TokenServiceClientMetadata.Methods.freezeTokenAccount,
      Proto_TokenServiceClientMetadata.Methods.unfreezeTokenAccount,
      Proto_TokenServiceClientMetadata.Methods.grantKycToTokenAccount,
      Proto_TokenServiceClientMetadata.Methods.revokeKycFromTokenAccount,
      Proto_TokenServiceClientMetadata.Methods.associateTokens,
      Proto_TokenServiceClientMetadata.Methods.dissociateTokens,
      Proto_TokenServiceClientMetadata.Methods.updateTokenFeeSchedule,
      Proto_TokenServiceClientMetadata.Methods.getTokenInfo,
      Proto_TokenServiceClientMetadata.Methods.getTokenNftInfo,
      Proto_TokenServiceClientMetadata.Methods.pauseToken,
      Proto_TokenServiceClientMetadata.Methods.unpauseToken,
      Proto_TokenServiceClientMetadata.Methods.updateNfts,
      Proto_TokenServiceClientMetadata.Methods.rejectToken,
      Proto_TokenServiceClientMetadata.Methods.airdropTokens,
      Proto_TokenServiceClientMetadata.Methods.cancelAirdrop,
      Proto_TokenServiceClientMetadata.Methods.claimAirdrop,
    ]
  )

  public enum Methods {
    public static let createToken = GRPCMethodDescriptor(
      name: "createToken",
      path: "/proto.TokenService/createToken",
      type: GRPCCallType.unary
    )

    public static let updateToken = GRPCMethodDescriptor(
      name: "updateToken",
      path: "/proto.TokenService/updateToken",
      type: GRPCCallType.unary
    )

    public static let mintToken = GRPCMethodDescriptor(
      name: "mintToken",
      path: "/proto.TokenService/mintToken",
      type: GRPCCallType.unary
    )

    public static let burnToken = GRPCMethodDescriptor(
      name: "burnToken",
      path: "/proto.TokenService/burnToken",
      type: GRPCCallType.unary
    )

    public static let deleteToken = GRPCMethodDescriptor(
      name: "deleteToken",
      path: "/proto.TokenService/deleteToken",
      type: GRPCCallType.unary
    )

    public static let wipeTokenAccount = GRPCMethodDescriptor(
      name: "wipeTokenAccount",
      path: "/proto.TokenService/wipeTokenAccount",
      type: GRPCCallType.unary
    )

    public static let freezeTokenAccount = GRPCMethodDescriptor(
      name: "freezeTokenAccount",
      path: "/proto.TokenService/freezeTokenAccount",
      type: GRPCCallType.unary
    )

    public static let unfreezeTokenAccount = GRPCMethodDescriptor(
      name: "unfreezeTokenAccount",
      path: "/proto.TokenService/unfreezeTokenAccount",
      type: GRPCCallType.unary
    )

    public static let grantKycToTokenAccount = GRPCMethodDescriptor(
      name: "grantKycToTokenAccount",
      path: "/proto.TokenService/grantKycToTokenAccount",
      type: GRPCCallType.unary
    )

    public static let revokeKycFromTokenAccount = GRPCMethodDescriptor(
      name: "revokeKycFromTokenAccount",
      path: "/proto.TokenService/revokeKycFromTokenAccount",
      type: GRPCCallType.unary
    )

    public static let associateTokens = GRPCMethodDescriptor(
      name: "associateTokens",
      path: "/proto.TokenService/associateTokens",
      type: GRPCCallType.unary
    )

    public static let dissociateTokens = GRPCMethodDescriptor(
      name: "dissociateTokens",
      path: "/proto.TokenService/dissociateTokens",
      type: GRPCCallType.unary
    )

    public static let updateTokenFeeSchedule = GRPCMethodDescriptor(
      name: "updateTokenFeeSchedule",
      path: "/proto.TokenService/updateTokenFeeSchedule",
      type: GRPCCallType.unary
    )

    public static let getTokenInfo = GRPCMethodDescriptor(
      name: "getTokenInfo",
      path: "/proto.TokenService/getTokenInfo",
      type: GRPCCallType.unary
    )

    public static let getTokenNftInfo = GRPCMethodDescriptor(
      name: "getTokenNftInfo",
      path: "/proto.TokenService/getTokenNftInfo",
      type: GRPCCallType.unary
    )

    public static let pauseToken = GRPCMethodDescriptor(
      name: "pauseToken",
      path: "/proto.TokenService/pauseToken",
      type: GRPCCallType.unary
    )

    public static let unpauseToken = GRPCMethodDescriptor(
      name: "unpauseToken",
      path: "/proto.TokenService/unpauseToken",
      type: GRPCCallType.unary
    )

    public static let updateNfts = GRPCMethodDescriptor(
      name: "updateNfts",
      path: "/proto.TokenService/updateNfts",
      type: GRPCCallType.unary
    )

    public static let rejectToken = GRPCMethodDescriptor(
      name: "rejectToken",
      path: "/proto.TokenService/rejectToken",
      type: GRPCCallType.unary
    )

    public static let airdropTokens = GRPCMethodDescriptor(
      name: "airdropTokens",
      path: "/proto.TokenService/airdropTokens",
      type: GRPCCallType.unary
    )

    public static let cancelAirdrop = GRPCMethodDescriptor(
      name: "cancelAirdrop",
      path: "/proto.TokenService/cancelAirdrop",
      type: GRPCCallType.unary
    )

    public static let claimAirdrop = GRPCMethodDescriptor(
      name: "claimAirdrop",
      path: "/proto.TokenService/claimAirdrop",
      type: GRPCCallType.unary
    )
  }
}

///*
/// Transactions and queries for the Token Service
///
/// To build a server, implement a class that conforms to this protocol.
public protocol Proto_TokenServiceProvider: CallHandlerProvider {
  var interceptors: Proto_TokenServiceServerInterceptorFactoryProtocol? { get }

  ///*
  /// Create a new token.
  func createToken(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Update a token.
  func updateToken(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Mint one or more tokens to the treasury account.
  /// <p>
  /// This MAY specify a quantity of fungible/common tokens or
  /// a list of specific non-fungible/unique tokes, but
  /// MUST NOT specify both.
  func mintToken(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Burn one or more tokens from the treasury account.
  /// <p>
  /// This MAY specify a quantity of fungible/common tokens or
  /// a list of specific non-fungible/unique tokes, but
  /// MUST NOT specify both.
  func burnToken(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Delete a token.
  func deleteToken(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Wipe one or more tokens from an identified Account.
  /// <p>
  /// This MAY specify a quantity of fungible/common tokens or
  /// a list of specific non-fungible/unique tokes, but
  /// MUST NOT specify both.
  func wipeTokenAccount(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Freeze the transfer of tokens to or from an identified Account.
  func freezeTokenAccount(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Unfreeze the transfer of tokens to or from an identified Account.
  func unfreezeTokenAccount(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Assert that KYC requirements are met for a specific account with
  /// respect to a specific token.
  func grantKycToTokenAccount(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Assert that KYC requirements are _not_ met for a specific account with
  /// respect to a specific token.
  func revokeKycFromTokenAccount(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Associate one or more tokens to an account.
  func associateTokens(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Dissociate one or more tokens from an account.
  func dissociateTokens(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Update the custom fee schedule for a token.
  func updateTokenFeeSchedule(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Retrieve the detail characteristics for a token.
  /// <p>
  /// This query SHALL return information for the token type as a whole.<br/>
  /// This query SHALL NOT return information for individual tokens.
  func getTokenInfo(request: Proto_Query, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_Response>

  ///*
  /// Retrieve the metadata for a specific non-fungible/unique token.<br/>
  /// The NFT to query is identified by token identifier and serial number.
  /// <p>
  /// This query SHALL return token metadata and, if an allowance is defined,
  /// the designated "spender" account for the queried NFT.
  func getTokenNftInfo(request: Proto_Query, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_Response>

  ///*
  /// Pause a token.
  func pauseToken(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Unpause (resume) a token.
  func unpauseToken(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Update multiple non-fungible/unique tokens (NFTs) in a collection.<br/>
  /// The NFTs are identified by token identifier and one or more
  /// serial numbers.
  /// <p>
  /// This transaction SHALL update NFT metadata only.<br/>
  /// This transaction MUST be signed by the token `metadata_key`.
  func updateNfts(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Reject one or more tokens.
  /// <p>
  /// This transaction SHALL transfer the full balance of one or more tokens
  /// from the requesting account to the treasury for each token.<br/>
  /// This transfer SHALL NOT charge any custom fee or royalty defined for
  /// the token(s) to be rejected.<br/>
  /// ### Effects on success
  /// <ul>
  ///   <li>If the rejected token is fungible/common, the requesting account
  ///       SHALL have a balance of 0 for the rejected token.<br/>
  ///       The treasury balance SHALL increase by the amount that the
  ///       requesting account decreased.</li>
  ///   <li>If the rejected token is non-fungible/unique the requesting
  ///       account SHALL NOT hold the specific serialized token that
  ///       is rejected.<br/>
  ///       The treasury account SHALL hold each specific serialized token
  ///       that was rejected.</li>
  /// </li>
  func rejectToken(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Airdrop one or more tokens to one or more accounts.
  /// <p>
  /// This transaction SHALL distribute tokens from the balance of one or
  /// more sending account(s) to the balance of one or more
  /// recipient accounts.<br/>
  /// Accounts SHALL receive the tokens in one of four ways.
  /// <ul>
  ///   <li>An account already associated to the token to be distributed
  ///       SHALL receive the airdropped tokens immediately to the
  ///       recipient account balance.</li>
  ///   <li>An account with available automatic association slots SHALL
  ///       be automatically associated to the token, and SHALL
  ///       immediately receive the airdropped tokens to the recipient
  ///       account balance.</li>
  ///   <li>An account with "receiver signature required" set SHALL have
  ///       a "Pending Airdrop" created and MUST claim that airdrop with
  ///       a `claimAirdrop` transaction.</li>
  ///   <li>An account with no available automatic association slots SHALL
  ///       have a "Pending Airdrop" created and MUST claim that airdrop
  ///       with a `claimAirdrop` transaction. </li>
  /// </ul>
  /// Any airdrop that completes immediately SHALL be irreversible.<br/>
  /// Any airdrop that results in a "Pending Airdrop" MAY be canceled via
  /// a `cancelAirdrop` transaction.<br/>
  /// All transfer fees (including custom fees and royalties), as well as
  /// the rent cost for the first auto-renewal period for any
  /// automatic-association slot occupied by the airdropped tokens,
  /// SHALL be charged to the account submitting this transaction.
  func airdropTokens(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Cancel one or more pending airdrops.
  /// <p>
  /// This transaction MUST be signed by _each_ account *sending* an
  /// airdrop to be canceled.
  func cancelAirdrop(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>

  ///*
  /// Claim one or more pending airdrops.
  /// <p>
  /// This transaction MUST be signed by _each_ account **receiving**
  /// an airdrop to be claimed.<br>
  /// If a "Sender" lacks sufficient balance to fulfill the airdrop at
  /// the time the claim is made, that claim SHALL fail.
  func claimAirdrop(request: Proto_Transaction, context: StatusOnlyCallContext) -> EventLoopFuture<Proto_TransactionResponse>
}

extension Proto_TokenServiceProvider {
  public var serviceName: Substring {
    return Proto_TokenServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "createToken":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makecreateTokenInterceptors() ?? [],
        userFunction: self.createToken(request:context:)
      )

    case "updateToken":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeupdateTokenInterceptors() ?? [],
        userFunction: self.updateToken(request:context:)
      )

    case "mintToken":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makemintTokenInterceptors() ?? [],
        userFunction: self.mintToken(request:context:)
      )

    case "burnToken":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeburnTokenInterceptors() ?? [],
        userFunction: self.burnToken(request:context:)
      )

    case "deleteToken":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makedeleteTokenInterceptors() ?? [],
        userFunction: self.deleteToken(request:context:)
      )

    case "wipeTokenAccount":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makewipeTokenAccountInterceptors() ?? [],
        userFunction: self.wipeTokenAccount(request:context:)
      )

    case "freezeTokenAccount":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makefreezeTokenAccountInterceptors() ?? [],
        userFunction: self.freezeTokenAccount(request:context:)
      )

    case "unfreezeTokenAccount":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeunfreezeTokenAccountInterceptors() ?? [],
        userFunction: self.unfreezeTokenAccount(request:context:)
      )

    case "grantKycToTokenAccount":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makegrantKycToTokenAccountInterceptors() ?? [],
        userFunction: self.grantKycToTokenAccount(request:context:)
      )

    case "revokeKycFromTokenAccount":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makerevokeKycFromTokenAccountInterceptors() ?? [],
        userFunction: self.revokeKycFromTokenAccount(request:context:)
      )

    case "associateTokens":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeassociateTokensInterceptors() ?? [],
        userFunction: self.associateTokens(request:context:)
      )

    case "dissociateTokens":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makedissociateTokensInterceptors() ?? [],
        userFunction: self.dissociateTokens(request:context:)
      )

    case "updateTokenFeeSchedule":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeupdateTokenFeeScheduleInterceptors() ?? [],
        userFunction: self.updateTokenFeeSchedule(request:context:)
      )

    case "getTokenInfo":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Query>(),
        responseSerializer: ProtobufSerializer<Proto_Response>(),
        interceptors: self.interceptors?.makegetTokenInfoInterceptors() ?? [],
        userFunction: self.getTokenInfo(request:context:)
      )

    case "getTokenNftInfo":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Query>(),
        responseSerializer: ProtobufSerializer<Proto_Response>(),
        interceptors: self.interceptors?.makegetTokenNftInfoInterceptors() ?? [],
        userFunction: self.getTokenNftInfo(request:context:)
      )

    case "pauseToken":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makepauseTokenInterceptors() ?? [],
        userFunction: self.pauseToken(request:context:)
      )

    case "unpauseToken":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeunpauseTokenInterceptors() ?? [],
        userFunction: self.unpauseToken(request:context:)
      )

    case "updateNfts":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeupdateNftsInterceptors() ?? [],
        userFunction: self.updateNfts(request:context:)
      )

    case "rejectToken":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makerejectTokenInterceptors() ?? [],
        userFunction: self.rejectToken(request:context:)
      )

    case "airdropTokens":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeairdropTokensInterceptors() ?? [],
        userFunction: self.airdropTokens(request:context:)
      )

    case "cancelAirdrop":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makecancelAirdropInterceptors() ?? [],
        userFunction: self.cancelAirdrop(request:context:)
      )

    case "claimAirdrop":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeclaimAirdropInterceptors() ?? [],
        userFunction: self.claimAirdrop(request:context:)
      )

    default:
      return nil
    }
  }
}

///*
/// Transactions and queries for the Token Service
///
/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol Proto_TokenServiceAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Proto_TokenServiceServerInterceptorFactoryProtocol? { get }

  ///*
  /// Create a new token.
  func createToken(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Update a token.
  func updateToken(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Mint one or more tokens to the treasury account.
  /// <p>
  /// This MAY specify a quantity of fungible/common tokens or
  /// a list of specific non-fungible/unique tokes, but
  /// MUST NOT specify both.
  func mintToken(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Burn one or more tokens from the treasury account.
  /// <p>
  /// This MAY specify a quantity of fungible/common tokens or
  /// a list of specific non-fungible/unique tokes, but
  /// MUST NOT specify both.
  func burnToken(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Delete a token.
  func deleteToken(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Wipe one or more tokens from an identified Account.
  /// <p>
  /// This MAY specify a quantity of fungible/common tokens or
  /// a list of specific non-fungible/unique tokes, but
  /// MUST NOT specify both.
  func wipeTokenAccount(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Freeze the transfer of tokens to or from an identified Account.
  func freezeTokenAccount(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Unfreeze the transfer of tokens to or from an identified Account.
  func unfreezeTokenAccount(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Assert that KYC requirements are met for a specific account with
  /// respect to a specific token.
  func grantKycToTokenAccount(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Assert that KYC requirements are _not_ met for a specific account with
  /// respect to a specific token.
  func revokeKycFromTokenAccount(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Associate one or more tokens to an account.
  func associateTokens(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Dissociate one or more tokens from an account.
  func dissociateTokens(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Update the custom fee schedule for a token.
  func updateTokenFeeSchedule(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Retrieve the detail characteristics for a token.
  /// <p>
  /// This query SHALL return information for the token type as a whole.<br/>
  /// This query SHALL NOT return information for individual tokens.
  func getTokenInfo(
    request: Proto_Query,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_Response

  ///*
  /// Retrieve the metadata for a specific non-fungible/unique token.<br/>
  /// The NFT to query is identified by token identifier and serial number.
  /// <p>
  /// This query SHALL return token metadata and, if an allowance is defined,
  /// the designated "spender" account for the queried NFT.
  func getTokenNftInfo(
    request: Proto_Query,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_Response

  ///*
  /// Pause a token.
  func pauseToken(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Unpause (resume) a token.
  func unpauseToken(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Update multiple non-fungible/unique tokens (NFTs) in a collection.<br/>
  /// The NFTs are identified by token identifier and one or more
  /// serial numbers.
  /// <p>
  /// This transaction SHALL update NFT metadata only.<br/>
  /// This transaction MUST be signed by the token `metadata_key`.
  func updateNfts(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Reject one or more tokens.
  /// <p>
  /// This transaction SHALL transfer the full balance of one or more tokens
  /// from the requesting account to the treasury for each token.<br/>
  /// This transfer SHALL NOT charge any custom fee or royalty defined for
  /// the token(s) to be rejected.<br/>
  /// ### Effects on success
  /// <ul>
  ///   <li>If the rejected token is fungible/common, the requesting account
  ///       SHALL have a balance of 0 for the rejected token.<br/>
  ///       The treasury balance SHALL increase by the amount that the
  ///       requesting account decreased.</li>
  ///   <li>If the rejected token is non-fungible/unique the requesting
  ///       account SHALL NOT hold the specific serialized token that
  ///       is rejected.<br/>
  ///       The treasury account SHALL hold each specific serialized token
  ///       that was rejected.</li>
  /// </li>
  func rejectToken(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Airdrop one or more tokens to one or more accounts.
  /// <p>
  /// This transaction SHALL distribute tokens from the balance of one or
  /// more sending account(s) to the balance of one or more
  /// recipient accounts.<br/>
  /// Accounts SHALL receive the tokens in one of four ways.
  /// <ul>
  ///   <li>An account already associated to the token to be distributed
  ///       SHALL receive the airdropped tokens immediately to the
  ///       recipient account balance.</li>
  ///   <li>An account with available automatic association slots SHALL
  ///       be automatically associated to the token, and SHALL
  ///       immediately receive the airdropped tokens to the recipient
  ///       account balance.</li>
  ///   <li>An account with "receiver signature required" set SHALL have
  ///       a "Pending Airdrop" created and MUST claim that airdrop with
  ///       a `claimAirdrop` transaction.</li>
  ///   <li>An account with no available automatic association slots SHALL
  ///       have a "Pending Airdrop" created and MUST claim that airdrop
  ///       with a `claimAirdrop` transaction. </li>
  /// </ul>
  /// Any airdrop that completes immediately SHALL be irreversible.<br/>
  /// Any airdrop that results in a "Pending Airdrop" MAY be canceled via
  /// a `cancelAirdrop` transaction.<br/>
  /// All transfer fees (including custom fees and royalties), as well as
  /// the rent cost for the first auto-renewal period for any
  /// automatic-association slot occupied by the airdropped tokens,
  /// SHALL be charged to the account submitting this transaction.
  func airdropTokens(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Cancel one or more pending airdrops.
  /// <p>
  /// This transaction MUST be signed by _each_ account *sending* an
  /// airdrop to be canceled.
  func cancelAirdrop(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse

  ///*
  /// Claim one or more pending airdrops.
  /// <p>
  /// This transaction MUST be signed by _each_ account **receiving**
  /// an airdrop to be claimed.<br>
  /// If a "Sender" lacks sufficient balance to fulfill the airdrop at
  /// the time the claim is made, that claim SHALL fail.
  func claimAirdrop(
    request: Proto_Transaction,
    context: GRPCAsyncServerCallContext
  ) async throws -> Proto_TransactionResponse
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Proto_TokenServiceAsyncProvider {
  public static var serviceDescriptor: GRPCServiceDescriptor {
    return Proto_TokenServiceServerMetadata.serviceDescriptor
  }

  public var serviceName: Substring {
    return Proto_TokenServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  public var interceptors: Proto_TokenServiceServerInterceptorFactoryProtocol? {
    return nil
  }

  public func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "createToken":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makecreateTokenInterceptors() ?? [],
        wrapping: { try await self.createToken(request: $0, context: $1) }
      )

    case "updateToken":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeupdateTokenInterceptors() ?? [],
        wrapping: { try await self.updateToken(request: $0, context: $1) }
      )

    case "mintToken":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makemintTokenInterceptors() ?? [],
        wrapping: { try await self.mintToken(request: $0, context: $1) }
      )

    case "burnToken":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeburnTokenInterceptors() ?? [],
        wrapping: { try await self.burnToken(request: $0, context: $1) }
      )

    case "deleteToken":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makedeleteTokenInterceptors() ?? [],
        wrapping: { try await self.deleteToken(request: $0, context: $1) }
      )

    case "wipeTokenAccount":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makewipeTokenAccountInterceptors() ?? [],
        wrapping: { try await self.wipeTokenAccount(request: $0, context: $1) }
      )

    case "freezeTokenAccount":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makefreezeTokenAccountInterceptors() ?? [],
        wrapping: { try await self.freezeTokenAccount(request: $0, context: $1) }
      )

    case "unfreezeTokenAccount":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeunfreezeTokenAccountInterceptors() ?? [],
        wrapping: { try await self.unfreezeTokenAccount(request: $0, context: $1) }
      )

    case "grantKycToTokenAccount":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makegrantKycToTokenAccountInterceptors() ?? [],
        wrapping: { try await self.grantKycToTokenAccount(request: $0, context: $1) }
      )

    case "revokeKycFromTokenAccount":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makerevokeKycFromTokenAccountInterceptors() ?? [],
        wrapping: { try await self.revokeKycFromTokenAccount(request: $0, context: $1) }
      )

    case "associateTokens":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeassociateTokensInterceptors() ?? [],
        wrapping: { try await self.associateTokens(request: $0, context: $1) }
      )

    case "dissociateTokens":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makedissociateTokensInterceptors() ?? [],
        wrapping: { try await self.dissociateTokens(request: $0, context: $1) }
      )

    case "updateTokenFeeSchedule":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeupdateTokenFeeScheduleInterceptors() ?? [],
        wrapping: { try await self.updateTokenFeeSchedule(request: $0, context: $1) }
      )

    case "getTokenInfo":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Query>(),
        responseSerializer: ProtobufSerializer<Proto_Response>(),
        interceptors: self.interceptors?.makegetTokenInfoInterceptors() ?? [],
        wrapping: { try await self.getTokenInfo(request: $0, context: $1) }
      )

    case "getTokenNftInfo":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Query>(),
        responseSerializer: ProtobufSerializer<Proto_Response>(),
        interceptors: self.interceptors?.makegetTokenNftInfoInterceptors() ?? [],
        wrapping: { try await self.getTokenNftInfo(request: $0, context: $1) }
      )

    case "pauseToken":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makepauseTokenInterceptors() ?? [],
        wrapping: { try await self.pauseToken(request: $0, context: $1) }
      )

    case "unpauseToken":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeunpauseTokenInterceptors() ?? [],
        wrapping: { try await self.unpauseToken(request: $0, context: $1) }
      )

    case "updateNfts":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeupdateNftsInterceptors() ?? [],
        wrapping: { try await self.updateNfts(request: $0, context: $1) }
      )

    case "rejectToken":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makerejectTokenInterceptors() ?? [],
        wrapping: { try await self.rejectToken(request: $0, context: $1) }
      )

    case "airdropTokens":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeairdropTokensInterceptors() ?? [],
        wrapping: { try await self.airdropTokens(request: $0, context: $1) }
      )

    case "cancelAirdrop":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makecancelAirdropInterceptors() ?? [],
        wrapping: { try await self.cancelAirdrop(request: $0, context: $1) }
      )

    case "claimAirdrop":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Proto_Transaction>(),
        responseSerializer: ProtobufSerializer<Proto_TransactionResponse>(),
        interceptors: self.interceptors?.makeclaimAirdropInterceptors() ?? [],
        wrapping: { try await self.claimAirdrop(request: $0, context: $1) }
      )

    default:
      return nil
    }
  }
}

public protocol Proto_TokenServiceServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'createToken'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makecreateTokenInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'updateToken'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeupdateTokenInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'mintToken'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makemintTokenInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'burnToken'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeburnTokenInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'deleteToken'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makedeleteTokenInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'wipeTokenAccount'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makewipeTokenAccountInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'freezeTokenAccount'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makefreezeTokenAccountInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'unfreezeTokenAccount'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeunfreezeTokenAccountInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'grantKycToTokenAccount'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makegrantKycToTokenAccountInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'revokeKycFromTokenAccount'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makerevokeKycFromTokenAccountInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'associateTokens'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeassociateTokensInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'dissociateTokens'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makedissociateTokensInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'updateTokenFeeSchedule'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeupdateTokenFeeScheduleInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'getTokenInfo'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makegetTokenInfoInterceptors() -> [ServerInterceptor<Proto_Query, Proto_Response>]

  /// - Returns: Interceptors to use when handling 'getTokenNftInfo'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makegetTokenNftInfoInterceptors() -> [ServerInterceptor<Proto_Query, Proto_Response>]

  /// - Returns: Interceptors to use when handling 'pauseToken'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makepauseTokenInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'unpauseToken'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeunpauseTokenInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'updateNfts'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeupdateNftsInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'rejectToken'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makerejectTokenInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'airdropTokens'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeairdropTokensInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'cancelAirdrop'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makecancelAirdropInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]

  /// - Returns: Interceptors to use when handling 'claimAirdrop'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeclaimAirdropInterceptors() -> [ServerInterceptor<Proto_Transaction, Proto_TransactionResponse>]
}

public enum Proto_TokenServiceServerMetadata {
  public static let serviceDescriptor = GRPCServiceDescriptor(
    name: "TokenService",
    fullName: "proto.TokenService",
    methods: [
      Proto_TokenServiceServerMetadata.Methods.createToken,
      Proto_TokenServiceServerMetadata.Methods.updateToken,
      Proto_TokenServiceServerMetadata.Methods.mintToken,
      Proto_TokenServiceServerMetadata.Methods.burnToken,
      Proto_TokenServiceServerMetadata.Methods.deleteToken,
      Proto_TokenServiceServerMetadata.Methods.wipeTokenAccount,
      Proto_TokenServiceServerMetadata.Methods.freezeTokenAccount,
      Proto_TokenServiceServerMetadata.Methods.unfreezeTokenAccount,
      Proto_TokenServiceServerMetadata.Methods.grantKycToTokenAccount,
      Proto_TokenServiceServerMetadata.Methods.revokeKycFromTokenAccount,
      Proto_TokenServiceServerMetadata.Methods.associateTokens,
      Proto_TokenServiceServerMetadata.Methods.dissociateTokens,
      Proto_TokenServiceServerMetadata.Methods.updateTokenFeeSchedule,
      Proto_TokenServiceServerMetadata.Methods.getTokenInfo,
      Proto_TokenServiceServerMetadata.Methods.getTokenNftInfo,
      Proto_TokenServiceServerMetadata.Methods.pauseToken,
      Proto_TokenServiceServerMetadata.Methods.unpauseToken,
      Proto_TokenServiceServerMetadata.Methods.updateNfts,
      Proto_TokenServiceServerMetadata.Methods.rejectToken,
      Proto_TokenServiceServerMetadata.Methods.airdropTokens,
      Proto_TokenServiceServerMetadata.Methods.cancelAirdrop,
      Proto_TokenServiceServerMetadata.Methods.claimAirdrop,
    ]
  )

  public enum Methods {
    public static let createToken = GRPCMethodDescriptor(
      name: "createToken",
      path: "/proto.TokenService/createToken",
      type: GRPCCallType.unary
    )

    public static let updateToken = GRPCMethodDescriptor(
      name: "updateToken",
      path: "/proto.TokenService/updateToken",
      type: GRPCCallType.unary
    )

    public static let mintToken = GRPCMethodDescriptor(
      name: "mintToken",
      path: "/proto.TokenService/mintToken",
      type: GRPCCallType.unary
    )

    public static let burnToken = GRPCMethodDescriptor(
      name: "burnToken",
      path: "/proto.TokenService/burnToken",
      type: GRPCCallType.unary
    )

    public static let deleteToken = GRPCMethodDescriptor(
      name: "deleteToken",
      path: "/proto.TokenService/deleteToken",
      type: GRPCCallType.unary
    )

    public static let wipeTokenAccount = GRPCMethodDescriptor(
      name: "wipeTokenAccount",
      path: "/proto.TokenService/wipeTokenAccount",
      type: GRPCCallType.unary
    )

    public static let freezeTokenAccount = GRPCMethodDescriptor(
      name: "freezeTokenAccount",
      path: "/proto.TokenService/freezeTokenAccount",
      type: GRPCCallType.unary
    )

    public static let unfreezeTokenAccount = GRPCMethodDescriptor(
      name: "unfreezeTokenAccount",
      path: "/proto.TokenService/unfreezeTokenAccount",
      type: GRPCCallType.unary
    )

    public static let grantKycToTokenAccount = GRPCMethodDescriptor(
      name: "grantKycToTokenAccount",
      path: "/proto.TokenService/grantKycToTokenAccount",
      type: GRPCCallType.unary
    )

    public static let revokeKycFromTokenAccount = GRPCMethodDescriptor(
      name: "revokeKycFromTokenAccount",
      path: "/proto.TokenService/revokeKycFromTokenAccount",
      type: GRPCCallType.unary
    )

    public static let associateTokens = GRPCMethodDescriptor(
      name: "associateTokens",
      path: "/proto.TokenService/associateTokens",
      type: GRPCCallType.unary
    )

    public static let dissociateTokens = GRPCMethodDescriptor(
      name: "dissociateTokens",
      path: "/proto.TokenService/dissociateTokens",
      type: GRPCCallType.unary
    )

    public static let updateTokenFeeSchedule = GRPCMethodDescriptor(
      name: "updateTokenFeeSchedule",
      path: "/proto.TokenService/updateTokenFeeSchedule",
      type: GRPCCallType.unary
    )

    public static let getTokenInfo = GRPCMethodDescriptor(
      name: "getTokenInfo",
      path: "/proto.TokenService/getTokenInfo",
      type: GRPCCallType.unary
    )

    public static let getTokenNftInfo = GRPCMethodDescriptor(
      name: "getTokenNftInfo",
      path: "/proto.TokenService/getTokenNftInfo",
      type: GRPCCallType.unary
    )

    public static let pauseToken = GRPCMethodDescriptor(
      name: "pauseToken",
      path: "/proto.TokenService/pauseToken",
      type: GRPCCallType.unary
    )

    public static let unpauseToken = GRPCMethodDescriptor(
      name: "unpauseToken",
      path: "/proto.TokenService/unpauseToken",
      type: GRPCCallType.unary
    )

    public static let updateNfts = GRPCMethodDescriptor(
      name: "updateNfts",
      path: "/proto.TokenService/updateNfts",
      type: GRPCCallType.unary
    )

    public static let rejectToken = GRPCMethodDescriptor(
      name: "rejectToken",
      path: "/proto.TokenService/rejectToken",
      type: GRPCCallType.unary
    )

    public static let airdropTokens = GRPCMethodDescriptor(
      name: "airdropTokens",
      path: "/proto.TokenService/airdropTokens",
      type: GRPCCallType.unary
    )

    public static let cancelAirdrop = GRPCMethodDescriptor(
      name: "cancelAirdrop",
      path: "/proto.TokenService/cancelAirdrop",
      type: GRPCCallType.unary
    )

    public static let claimAirdrop = GRPCMethodDescriptor(
      name: "claimAirdrop",
      path: "/proto.TokenService/claimAirdrop",
      type: GRPCCallType.unary
    )
  }
}
