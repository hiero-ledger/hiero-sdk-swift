// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/state/hints/hints_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// The stage of a CRS construction.
public enum Com_Hedera_Hapi_Node_State_Hints_CRSStage: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///*
  /// The network is gathering contributions to the CRS from all nodes.
  case gatheringContributions // = 0

  ///*
  /// The network is waiting for some grace period to allow the verification future
  /// to be completed after the last node has contributed to the CRS.
  case waitingForAdoptingFinalCrs // = 1

  ///*
  /// The network has completed the CRS construction and is set in the CrsState.
  case completed // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .gatheringContributions
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gatheringContributions
    case 1: self = .waitingForAdoptingFinalCrs
    case 2: self = .completed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .gatheringContributions: return 0
    case .waitingForAdoptingFinalCrs: return 1
    case .completed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Com_Hedera_Hapi_Node_State_Hints_CRSStage] = [
    .gatheringContributions,
    .waitingForAdoptingFinalCrs,
    .completed,
  ]

}

///*
/// The id of a party in a hinTS scheme with a certain
/// number of parties.
public struct Com_Hedera_Hapi_Node_State_Hints_HintsPartyId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The party id, in the range [0, num_parties).
  public var partyID: UInt32 = 0

  ///*
  /// The number of parties in the hinTS scheme.
  public var numParties: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A set of hinTS keys submitted by a node.
public struct Com_Hedera_Hapi_Node_State_Hints_HintsKeySet: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The id of the node submitting these keys.
  public var nodeID: UInt64 = 0

  ///*
  /// The consensus time at which the network adopted the active
  /// hinTS key in this set.
  public var adoptionTime: Proto_Timestamp {
    get {return _adoptionTime ?? Proto_Timestamp()}
    set {_adoptionTime = newValue}
  }
  /// Returns true if `adoptionTime` has been explicitly set.
  public var hasAdoptionTime: Bool {return self._adoptionTime != nil}
  /// Clears the value of `adoptionTime`. Subsequent reads from it will return its default value.
  public mutating func clearAdoptionTime() {self._adoptionTime = nil}

  ///*
  /// The party's active hinTS key.
  public var key: Data = Data()

  ///*
  /// If set, the new hinTS key the node wants to use when
  /// the next construction begins.
  public var nextKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _adoptionTime: Proto_Timestamp? = nil
}

///*
/// The output of the hinTS preprocessing algorithm; that is, a
/// linear-size aggregation key and a succinct verification key.
public struct Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The aggregation key for the hinTS scheme
  public var aggregationKey: Data = Data()

  ///*
  /// The succinct verification key for the hinTS scheme.
  public var verificationKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The id for a node's vote for the output of the
/// preprocessing output of a hinTS construction.
public struct Com_Hedera_Hapi_Node_State_Hints_PreprocessingVoteId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The construction this vote is connected to.
  public var constructionID: UInt64 = 0

  ///*
  /// The id of the node submitting the vote.
  public var nodeID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// A node's vote for the consensus output of a hinTS preprocessing
/// algorithm.
public struct Com_Hedera_Hapi_Node_State_Hints_PreprocessingVote: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vote: Com_Hedera_Hapi_Node_State_Hints_PreprocessingVote.OneOf_Vote? = nil

  ///*
  /// The preprocessed keys this node is voting for.
  public var preprocessedKeys: Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys {
    get {
      if case .preprocessedKeys(let v)? = vote {return v}
      return Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys()
    }
    set {vote = .preprocessedKeys(newValue)}
  }

  ///*
  /// The id of any node that already voted for the exact keys
  /// that this node wanted to vote for.
  public var congruentNodeID: UInt64 {
    get {
      if case .congruentNodeID(let v)? = vote {return v}
      return 0
    }
    set {vote = .congruentNodeID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Vote: Equatable, Sendable {
    ///*
    /// The preprocessed keys this node is voting for.
    case preprocessedKeys(Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys)
    ///*
    /// The id of any node that already voted for the exact keys
    /// that this node wanted to vote for.
    case congruentNodeID(UInt64)

  }

  public init() {}
}

///*
/// A node's hinTS party id.
public struct Com_Hedera_Hapi_Node_State_Hints_NodePartyId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The node id.
  public var nodeID: UInt64 = 0

  ///*
  /// The party id.
  public var partyID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///*
/// The information constituting the hinTS scheme Hiero TSS.
public struct Com_Hedera_Hapi_Node_State_Hints_HintsScheme: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The aggregation and verification keys for the scheme.
  public var preprocessedKeys: Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys {
    get {return _preprocessedKeys ?? Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys()}
    set {_preprocessedKeys = newValue}
  }
  /// Returns true if `preprocessedKeys` has been explicitly set.
  public var hasPreprocessedKeys: Bool {return self._preprocessedKeys != nil}
  /// Clears the value of `preprocessedKeys`. Subsequent reads from it will return its default value.
  public mutating func clearPreprocessedKeys() {self._preprocessedKeys = nil}

  ///*
  /// The final party ids assigned to each node in the target roster.
  public var nodePartyIds: [Com_Hedera_Hapi_Node_State_Hints_NodePartyId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _preprocessedKeys: Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys? = nil
}

///*
/// A summary of progress in constructing a hinTS scheme.
public struct Com_Hedera_Hapi_Node_State_Hints_HintsConstruction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The id of the construction.
  public var constructionID: UInt64 = 0

  ///*
  /// The hash of the roster whose weights are used to determine when
  /// the >=1/3 weight signing threshold is reached.
  public var sourceRosterHash: Data = Data()

  ///*
  /// The hash of the roster whose weights are used to determine when
  /// the >2/3 weight availability threshold is reached.
  public var targetRosterHash: Data = Data()

  public var preprocessingState: Com_Hedera_Hapi_Node_State_Hints_HintsConstruction.OneOf_PreprocessingState? = nil

  ///*
  /// If the network is still gathering hinTS keys for this construction,
  /// the time at which honest nodes should stop waiting for tardy
  /// publications and begin preprocessing as soon as there are valid
  /// hinTS keys for nodes with >2/3 weight in the target roster.
  public var gracePeriodEndTime: Proto_Timestamp {
    get {
      if case .gracePeriodEndTime(let v)? = preprocessingState {return v}
      return Proto_Timestamp()
    }
    set {preprocessingState = .gracePeriodEndTime(newValue)}
  }

  ///*
  /// If the network has gathered enough hinTS keys for this construction
  /// to begin preprocessing, the cutoff time by which keys must have been
  /// adopted to be included as input to the preprocessing algorithm.
  public var preprocessingStartTime: Proto_Timestamp {
    get {
      if case .preprocessingStartTime(let v)? = preprocessingState {return v}
      return Proto_Timestamp()
    }
    set {preprocessingState = .preprocessingStartTime(newValue)}
  }

  ///*
  /// If set, the completed hinTS scheme.
  public var hintsScheme: Com_Hedera_Hapi_Node_State_Hints_HintsScheme {
    get {
      if case .hintsScheme(let v)? = preprocessingState {return v}
      return Com_Hedera_Hapi_Node_State_Hints_HintsScheme()
    }
    set {preprocessingState = .hintsScheme(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PreprocessingState: Equatable, Sendable {
    ///*
    /// If the network is still gathering hinTS keys for this construction,
    /// the time at which honest nodes should stop waiting for tardy
    /// publications and begin preprocessing as soon as there are valid
    /// hinTS keys for nodes with >2/3 weight in the target roster.
    case gracePeriodEndTime(Proto_Timestamp)
    ///*
    /// If the network has gathered enough hinTS keys for this construction
    /// to begin preprocessing, the cutoff time by which keys must have been
    /// adopted to be included as input to the preprocessing algorithm.
    case preprocessingStartTime(Proto_Timestamp)
    ///*
    /// If set, the completed hinTS scheme.
    case hintsScheme(Com_Hedera_Hapi_Node_State_Hints_HintsScheme)

  }

  public init() {}
}

///*
/// The state of a CRS construction.
public struct Com_Hedera_Hapi_Node_State_Hints_CRSState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The bytes of the CRS. Based on the CRSStage, this may be the initial CRS
  /// or the final CRS.
  public var crs: Data = Data()

  ///*
  /// The stage of the CRS construction.
  public var stage: Com_Hedera_Hapi_Node_State_Hints_CRSStage = .gatheringContributions

  ///*
  /// The id of the next node that should contribute to the CRS. This is used
  /// to ensure that all nodes contribute to the CRS in a round-robin fashion.
  /// If this is null, then all nodes in the network have contributed to the CRS.
  public var nextContributingNodeID: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _nextContributingNodeID ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_nextContributingNodeID = newValue}
  }
  /// Returns true if `nextContributingNodeID` has been explicitly set.
  public var hasNextContributingNodeID: Bool {return self._nextContributingNodeID != nil}
  /// Clears the value of `nextContributingNodeID`. Subsequent reads from it will return its default value.
  public mutating func clearNextContributingNodeID() {self._nextContributingNodeID = nil}

  ///*
  /// The time at which the network should stop waiting for the node's contributions
  /// and move on to the next node in the round-robin fashion.
  public var contributionEndTime: Proto_Timestamp {
    get {return _contributionEndTime ?? Proto_Timestamp()}
    set {_contributionEndTime = newValue}
  }
  /// Returns true if `contributionEndTime` has been explicitly set.
  public var hasContributionEndTime: Bool {return self._contributionEndTime != nil}
  /// Clears the value of `contributionEndTime`. Subsequent reads from it will return its default value.
  public mutating func clearContributionEndTime() {self._contributionEndTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nextContributingNodeID: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
  fileprivate var _contributionEndTime: Proto_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.hedera.hapi.node.state.hints"

extension Com_Hedera_Hapi_Node_State_Hints_CRSStage: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GATHERING_CONTRIBUTIONS"),
    1: .same(proto: "WAITING_FOR_ADOPTING_FINAL_CRS"),
    2: .same(proto: "COMPLETED"),
  ]
}

extension Com_Hedera_Hapi_Node_State_Hints_HintsPartyId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HintsPartyId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "party_id"),
    2: .standard(proto: "num_parties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.partyID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numParties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.partyID != 0 {
      try visitor.visitSingularUInt32Field(value: self.partyID, fieldNumber: 1)
    }
    if self.numParties != 0 {
      try visitor.visitSingularUInt32Field(value: self.numParties, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_Hints_HintsPartyId, rhs: Com_Hedera_Hapi_Node_State_Hints_HintsPartyId) -> Bool {
    if lhs.partyID != rhs.partyID {return false}
    if lhs.numParties != rhs.numParties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_Hints_HintsKeySet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HintsKeySet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "adoption_time"),
    3: .same(proto: "key"),
    4: .standard(proto: "next_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._adoptionTime) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nextKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.nodeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.nodeID, fieldNumber: 1)
    }
    try { if let v = self._adoptionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 3)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_Hints_HintsKeySet, rhs: Com_Hedera_Hapi_Node_State_Hints_HintsKeySet) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs._adoptionTime != rhs._adoptionTime {return false}
    if lhs.key != rhs.key {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreprocessedKeys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregation_key"),
    2: .standard(proto: "verification_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.aggregationKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.verificationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aggregationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.aggregationKey, fieldNumber: 1)
    }
    if !self.verificationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.verificationKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys, rhs: Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys) -> Bool {
    if lhs.aggregationKey != rhs.aggregationKey {return false}
    if lhs.verificationKey != rhs.verificationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_Hints_PreprocessingVoteId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreprocessingVoteId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "construction_id"),
    2: .standard(proto: "node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.constructionID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nodeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.constructionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.constructionID, fieldNumber: 1)
    }
    if self.nodeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.nodeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_Hints_PreprocessingVoteId, rhs: Com_Hedera_Hapi_Node_State_Hints_PreprocessingVoteId) -> Bool {
    if lhs.constructionID != rhs.constructionID {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_Hints_PreprocessingVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreprocessingVote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preprocessed_keys"),
    2: .standard(proto: "congruent_node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Com_Hedera_Hapi_Node_State_Hints_PreprocessedKeys?
        var hadOneofValue = false
        if let current = self.vote {
          hadOneofValue = true
          if case .preprocessedKeys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vote = .preprocessedKeys(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.vote != nil {try decoder.handleConflictingOneOf()}
          self.vote = .congruentNodeID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.vote {
    case .preprocessedKeys?: try {
      guard case .preprocessedKeys(let v)? = self.vote else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .congruentNodeID?: try {
      guard case .congruentNodeID(let v)? = self.vote else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_Hints_PreprocessingVote, rhs: Com_Hedera_Hapi_Node_State_Hints_PreprocessingVote) -> Bool {
    if lhs.vote != rhs.vote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_Hints_NodePartyId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodePartyId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "party_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.partyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.nodeID, fieldNumber: 1)
    }
    if self.partyID != 0 {
      try visitor.visitSingularUInt32Field(value: self.partyID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_Hints_NodePartyId, rhs: Com_Hedera_Hapi_Node_State_Hints_NodePartyId) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.partyID != rhs.partyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_Hints_HintsScheme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HintsScheme"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preprocessed_keys"),
    2: .standard(proto: "node_party_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._preprocessedKeys) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nodePartyIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._preprocessedKeys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodePartyIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodePartyIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_Hints_HintsScheme, rhs: Com_Hedera_Hapi_Node_State_Hints_HintsScheme) -> Bool {
    if lhs._preprocessedKeys != rhs._preprocessedKeys {return false}
    if lhs.nodePartyIds != rhs.nodePartyIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_Hints_HintsConstruction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HintsConstruction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "construction_id"),
    2: .standard(proto: "source_roster_hash"),
    3: .standard(proto: "target_roster_hash"),
    4: .standard(proto: "grace_period_end_time"),
    5: .standard(proto: "preprocessing_start_time"),
    6: .standard(proto: "hints_scheme"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.constructionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sourceRosterHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.targetRosterHash) }()
      case 4: try {
        var v: Proto_Timestamp?
        var hadOneofValue = false
        if let current = self.preprocessingState {
          hadOneofValue = true
          if case .gracePeriodEndTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.preprocessingState = .gracePeriodEndTime(v)
        }
      }()
      case 5: try {
        var v: Proto_Timestamp?
        var hadOneofValue = false
        if let current = self.preprocessingState {
          hadOneofValue = true
          if case .preprocessingStartTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.preprocessingState = .preprocessingStartTime(v)
        }
      }()
      case 6: try {
        var v: Com_Hedera_Hapi_Node_State_Hints_HintsScheme?
        var hadOneofValue = false
        if let current = self.preprocessingState {
          hadOneofValue = true
          if case .hintsScheme(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.preprocessingState = .hintsScheme(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.constructionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.constructionID, fieldNumber: 1)
    }
    if !self.sourceRosterHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.sourceRosterHash, fieldNumber: 2)
    }
    if !self.targetRosterHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.targetRosterHash, fieldNumber: 3)
    }
    switch self.preprocessingState {
    case .gracePeriodEndTime?: try {
      guard case .gracePeriodEndTime(let v)? = self.preprocessingState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .preprocessingStartTime?: try {
      guard case .preprocessingStartTime(let v)? = self.preprocessingState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .hintsScheme?: try {
      guard case .hintsScheme(let v)? = self.preprocessingState else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_Hints_HintsConstruction, rhs: Com_Hedera_Hapi_Node_State_Hints_HintsConstruction) -> Bool {
    if lhs.constructionID != rhs.constructionID {return false}
    if lhs.sourceRosterHash != rhs.sourceRosterHash {return false}
    if lhs.targetRosterHash != rhs.targetRosterHash {return false}
    if lhs.preprocessingState != rhs.preprocessingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Hedera_Hapi_Node_State_Hints_CRSState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CRSState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "crs"),
    2: .same(proto: "stage"),
    3: .standard(proto: "next_contributing_node_id"),
    4: .standard(proto: "contribution_end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.crs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._nextContributingNodeID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._contributionEndTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.crs.isEmpty {
      try visitor.visitSingularBytesField(value: self.crs, fieldNumber: 1)
    }
    if self.stage != .gatheringContributions {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 2)
    }
    try { if let v = self._nextContributingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._contributionEndTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Hedera_Hapi_Node_State_Hints_CRSState, rhs: Com_Hedera_Hapi_Node_State_Hints_CRSState) -> Bool {
    if lhs.crs != rhs.crs {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs._nextContributingNodeID != rhs._nextContributingNodeID {return false}
    if lhs._contributionEndTime != rhs._contributionEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
