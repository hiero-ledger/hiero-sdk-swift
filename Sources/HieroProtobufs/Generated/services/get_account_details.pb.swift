// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: services/get_account_details.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///*
/// # Get Account Details
/// A standard query to inspect the full detail of an account.
///
/// ### Keywords
/// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
/// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
/// document are to be interpreted as described in
/// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
/// [RFC8174](https://www.ietf.org/rfc/rfc8174).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Request detail information about an account.
///
/// The returned information SHALL include balance and allowances.<br/>
/// The returned information SHALL NOT include a list of account records.
///
/// #### Important
/// This query is a _privileged_ query. Only "system" accounts SHALL be
/// permitted to submit this query.
public struct Proto_GetAccountDetailsQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// Standard information sent with every query operation.<br/>
  /// This includes the signed payment and what kind of response is requested
  /// (cost, state proof, both, or neither).
  public var header: Proto_QueryHeader {
    get {return _header ?? Proto_QueryHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  ///*
  /// An account ID for which information is requested
  /// <p>
  /// This value SHALL identify the account to be queried.<br/>
  /// This value MUST identify a valid account.<br/>
  /// This field is REQUIRED.
  public var accountID: Proto_AccountID {
    get {return _accountID ?? Proto_AccountID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Proto_QueryHeader? = nil
  fileprivate var _accountID: Proto_AccountID? = nil
}

///*
/// A response to a `GetAccountDetailsQuery`.
///
/// This SHALL contain the account details if requested and successful.
public struct Proto_GetAccountDetailsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The standard response information for queries.<br/>
  /// This includes the values requested in the `QueryHeader`
  /// (cost, state proof, both, or neither).
  public var header: Proto_ResponseHeader {
    get {return _header ?? Proto_ResponseHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  ///*
  /// Details of the account.
  /// <p>
  /// A state proof MAY be generated for this field.
  public var accountDetails: Proto_GetAccountDetailsResponse.AccountDetails {
    get {return _accountDetails ?? Proto_GetAccountDetailsResponse.AccountDetails()}
    set {_accountDetails = newValue}
  }
  /// Returns true if `accountDetails` has been explicitly set.
  public var hasAccountDetails: Bool {return self._accountDetails != nil}
  /// Clears the value of `accountDetails`. Subsequent reads from it will return its default value.
  public mutating func clearAccountDetails() {self._accountDetails = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///*
  /// Information describing a single Account in the Hedera distributed ledger.
  ///
  /// #### Attributes
  /// Each Account may have a unique three-part identifier, a Key, and one or
  /// more token balances. Accounts also have an alias, which has multiple
  /// forms, and may be set automatically. Several additional items are
  /// associated with the Account to enable full functionality.
  ///
  /// #### Expiration
  /// Accounts, as most items in the network, have an expiration time, recorded
  /// as a `Timestamp`, and must be "renewed" for a small fee at expiration.
  /// This helps to reduce the amount of inactive accounts retained in state.
  /// Another account may be designated to pay any renewal fees and
  /// automatically renew the account for (by default) 30-90 days at a time as
  /// a means to optionally ensure important accounts remain active.
  ///
  /// ### Staking
  /// Accounts may participate in securing the network by "staking" the account
  /// balances to a particular network node, and receive a portion of network
  /// fees as a reward. An account may optionally decline these rewards but
  /// still stake its balances.
  ///
  /// #### Transfer Restrictions
  /// An account may optionally require that inbound transfer transactions be
  /// signed by that account as receiver (in addition to any other signatures
  /// required, including sender).
  public struct AccountDetails: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///*
    /// The unique ID of this account.
    /// <p>
    /// An account ID, when assigned to this field, SHALL be of
    /// the form `shard.realm.number`.<br/>
    /// Transactions MAY reference the account by alias, but the account
    /// itself MUST always have a purely numeric identifier. This numeric
    /// ID is the value used to reference the account in query responses,
    /// transaction receipts, transaction records, and the block stream.
    public var accountID: Proto_AccountID {
      get {return _storage._accountID ?? Proto_AccountID()}
      set {_uniqueStorage()._accountID = newValue}
    }
    /// Returns true if `accountID` has been explicitly set.
    public var hasAccountID: Bool {return _storage._accountID != nil}
    /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
    public mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

    ///*
    /// A Solidity ID.<br/>
    /// This identifies the contract instance, and the `Account` associated
    /// with that contract instance.
    /// <p>
    /// This SHALL be populated if this account is a smart contract, and
    /// SHALL NOT be populated otherwise.<br/>
    /// This SHALL be formatted as a string according to Solidity ID
    /// standards.
    public var contractAccountID: String {
      get {return _storage._contractAccountID}
      set {_uniqueStorage()._contractAccountID = newValue}
    }

    ///*
    /// A boolean indicating that this account is deleted.
    public var deleted: Bool {
      get {return _storage._deleted}
      set {_uniqueStorage()._deleted = newValue}
    }

    ///*
    /// Replaced by StakingInfo.<br/>
    /// ID of the account to which this account is staking its balances. If
    /// this account is not currently staking its balances, then this field,
    /// if set, SHALL be the sentinel value of `0.0.0`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var proxyAccountID: Proto_AccountID {
      get {return _storage._proxyAccountID ?? Proto_AccountID()}
      set {_uniqueStorage()._proxyAccountID = newValue}
    }
    /// Returns true if `proxyAccountID` has been explicitly set.
    public var hasProxyAccountID: Bool {return _storage._proxyAccountID != nil}
    /// Clears the value of `proxyAccountID`. Subsequent reads from it will return its default value.
    public mutating func clearProxyAccountID() {_uniqueStorage()._proxyAccountID = nil}

    ///*
    /// The total amount of tinybar proxy staked to this account.
    public var proxyReceived: Int64 {
      get {return _storage._proxyReceived}
      set {_uniqueStorage()._proxyReceived = newValue}
    }

    ///*
    /// The key to be used to sign transactions from this account, if any.
    /// <p>
    /// This key SHALL NOT be set for hollow accounts until the account
    /// is finalized.<br/>
    /// This key SHALL be set on all other accounts, except for certain
    /// immutable accounts (0.0.800 and 0.0.801) necessary for network
    /// function and otherwise secured by the governing council.
    public var key: Proto_Key {
      get {return _storage._key ?? Proto_Key()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {_uniqueStorage()._key = nil}

    ///*
    /// The HBAR balance of this account, in tinybar (10<sup>-8</sup> HBAR).
    /// <p>
    /// This value SHALL always be a whole number.
    public var balance: UInt64 {
      get {return _storage._balance}
      set {_uniqueStorage()._balance = newValue}
    }

    ///*
    /// A boolean indicating that the account requires a receiver signature
    /// for inbound token transfer transactions.
    /// <p>
    /// If this value is `true` then a transaction to transfer tokens to this
    /// account SHALL NOT succeed unless this account has signed the
    /// transfer transaction.
    public var receiverSigRequired: Bool {
      get {return _storage._receiverSigRequired}
      set {_uniqueStorage()._receiverSigRequired = newValue}
    }

    ///*
    /// The current expiration time for this account.
    /// <p>
    /// This account SHALL be due standard renewal fees when the network
    /// consensus time exceeds this time.<br/>
    /// If rent and expiration are enabled for the network, and automatic
    /// renewal is enabled for this account, renewal fees SHALL be charged
    /// after this time, and, if charged, the expiration time SHALL be
    /// extended for another renewal period.<br/>
    /// This account MAY be expired and removed from state at any point
    /// after this time if not renewed.<br/>
    /// An account holder MAY extend this time by submitting an account
    /// update transaction to modify expiration time, subject to the current
    /// maximum expiration time for the network.
    public var expirationTime: Proto_Timestamp {
      get {return _storage._expirationTime ?? Proto_Timestamp()}
      set {_uniqueStorage()._expirationTime = newValue}
    }
    /// Returns true if `expirationTime` has been explicitly set.
    public var hasExpirationTime: Bool {return _storage._expirationTime != nil}
    /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
    public mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

    ///*
    /// A duration to extend this account's expiration.
    /// <p>
    /// The network SHALL extend the account's expiration by this
    /// duration, if funds are available, upon automatic renewal.<br/>
    /// This SHALL NOT apply if the account is already deleted
    /// upon expiration.<br/>
    /// If this is not provided in an allowed range on account creation, the
    /// transaction SHALL fail with INVALID_AUTO_RENEWAL_PERIOD. The default
    /// values for the minimum period and maximum period are currently
    /// 30 days and 90 days, respectively.
    public var autoRenewPeriod: Proto_Duration {
      get {return _storage._autoRenewPeriod ?? Proto_Duration()}
      set {_uniqueStorage()._autoRenewPeriod = newValue}
    }
    /// Returns true if `autoRenewPeriod` has been explicitly set.
    public var hasAutoRenewPeriod: Bool {return _storage._autoRenewPeriod != nil}
    /// Clears the value of `autoRenewPeriod`. Subsequent reads from it will return its default value.
    public mutating func clearAutoRenewPeriod() {_uniqueStorage()._autoRenewPeriod = nil}

    ///*
    /// As of `HIP-367`, which enabled unlimited token associations, the
    /// potential scale for this value requires that users consult a mirror
    /// node for this information. Only the top `maxRelsPerInfoQuery`
    /// (default 1000) relationships will be returned by this query.<br/>
    /// A list of tokens to which this account is "associated", enabling the
    /// transfer of that token type by this account.
    public var tokenRelationships: [Proto_TokenRelationship] {
      get {return _storage._tokenRelationships}
      set {_uniqueStorage()._tokenRelationships = newValue}
    }

    ///*
    /// A short description of this account.
    /// <p>
    /// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
    /// (default 100) bytes when encoded as UTF-8.
    public var memo: String {
      get {return _storage._memo}
      set {_uniqueStorage()._memo = newValue}
    }

    ///*
    /// The total number of non-fungible/unique tokens owned by this account.
    public var ownedNfts: Int64 {
      get {return _storage._ownedNfts}
      set {_uniqueStorage()._ownedNfts = newValue}
    }

    ///*
    /// The maximum number of tokens that can be auto-associated with the
    /// account.
    /// <p>
    /// If this is less than or equal to `used_auto_associations` (or 0),
    /// then this account MUST manually associate with a token before
    /// transacting in that token.<br/>
    /// Following HIP-904 This value may also be `-1` to indicate no
    /// limit.<br/>
    /// This value MUST NOT be less than `-1`.
    public var maxAutomaticTokenAssociations: Int32 {
      get {return _storage._maxAutomaticTokenAssociations}
      set {_uniqueStorage()._maxAutomaticTokenAssociations = newValue}
    }

    ///*
    /// An account EVM alias.<br/>
    /// This is a value used in some contexts to reference an account when
    /// the tripartite account identifier is not available.
    /// <p>
    /// This field, when set to a non-default value, is immutable and
    /// SHALL NOT be changed.
    public var alias: Data {
      get {return _storage._alias}
      set {_uniqueStorage()._alias = newValue}
    }

    ///*
    /// The ledger ID of the network that generated this response.
    /// <p>
    /// This value SHALL identify the distributed ledger that responded to
    /// this query.
    public var ledgerID: Data {
      get {return _storage._ledgerID}
      set {_uniqueStorage()._ledgerID = newValue}
    }

    ///*
    /// A list of crypto (HBAR) allowances approved by this account.
    /// <p>
    /// If this is not empty, each allowance SHALL permit a specified
    /// "spender" account to spend this account's HBAR balance, up
    /// to a designated limit.<br/>
    /// This field SHALL permit spending only HBAR balance, not other
    /// tokens the account may hold.<br/>
    /// Allowances for other tokens SHALL be listed in the
    /// `token_allowances` field or the
    /// `approve_for_all_nft_allowances` field.
    public var grantedCryptoAllowances: [Proto_GrantedCryptoAllowance] {
      get {return _storage._grantedCryptoAllowances}
      set {_uniqueStorage()._grantedCryptoAllowances = newValue}
    }

    ///*
    /// A list of non-fungible token (NFT) allowances approved by
    /// this account.
    /// <p>
    /// If this is not empty, each allowance SHALL permit a specified
    /// "spender" account to transfer _all_ of this account's
    /// non-fungible/unique tokens from a particular collection.<br/>
    /// Allowances for a specific serial number MUST be directly
    /// associated with that specific non-fungible/unique token, rather
    /// than the holding account.
    public var grantedNftAllowances: [Proto_GrantedNftAllowance] {
      get {return _storage._grantedNftAllowances}
      set {_uniqueStorage()._grantedNftAllowances = newValue}
    }

    ///*
    /// A list of fungible token allowances approved by this account.
    /// <p>
    /// If this is not empty, each allowance SHALL permit a specified
    /// "spender" to spend this account's fungible tokens, of the
    /// designated type, up to a designated limit.
    public var grantedTokenAllowances: [Proto_GrantedTokenAllowance] {
      get {return _storage._grantedTokenAllowances}
      set {_uniqueStorage()._grantedTokenAllowances = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _header: Proto_ResponseHeader? = nil
  fileprivate var _accountDetails: Proto_GetAccountDetailsResponse.AccountDetails? = nil
}

///*
/// Permission granted by one account (the "funding" account) to another
/// account (the "spender" account) that allows the spender to spend a
/// specified amount of HBAR owned by the funding account.
///
/// An allowance SHALL NOT transfer any HBAR directly, it only permits
/// transactions signed only by the spender account to transfer HBAR, up
/// to the amount specified, from the funding account.
///
/// Once the specified amount is spent, the allowance SHALL be consumed
/// and a new allowance SHALL be required before that spending account
/// may spend additional HBAR from the funding account.
public struct Proto_GrantedCryptoAllowance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The identifier for the spending account associated with this allowance.
  /// <p>
  /// This account SHALL be permitted to sign transactions to spend
  /// HBAR from the funding/allowing account.<br/>
  /// This permission SHALL be limited to no more than the specified `amount`.
  public var spender: Proto_AccountID {
    get {return _spender ?? Proto_AccountID()}
    set {_spender = newValue}
  }
  /// Returns true if `spender` has been explicitly set.
  public var hasSpender: Bool {return self._spender != nil}
  /// Clears the value of `spender`. Subsequent reads from it will return its default value.
  public mutating func clearSpender() {self._spender = nil}

  ///*
  /// The maximum amount that the spender account may transfer within
  /// the scope of this allowance.
  /// <p>
  /// This allowance SHALL be consumed if any combination of transfers
  /// authorized via this allowance meet this value in total.<br/>
  /// This value MUST be specified in tinybar (i.e. 10<sup>-8</sup> HBAR).
  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spender: Proto_AccountID? = nil
}

///*
/// Permission granted by one account (the "funding" account) to another
/// account (the "spender" account) that allows the spender to transfer
/// all serial numbers of a specific non-fungible/unique token (NFT)
/// collection owned by the funding account.<br/>
/// This is a broad permission, as it does not matter how many NFTs of the
/// specified collection the funding account owns, the spender MAY dispose
/// of any or all of them with this allowance.<br/>
/// Each token type (typically a collection of NFTs) SHALL require
/// a separate allowance.<br/>
/// Allowances for a specific serial number MUST be directly associated
/// with that specific non-fungible/unique token, rather than
/// the holding account.
///
/// An allowance SHALL NOT transfer any tokens directly, it only permits
/// transactions signed only by the spender account to transfer any
/// non-fungible/unique tokens of the specified type owned by
/// the funding account.
public struct Proto_GrantedNftAllowance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The identifier for the token associated with this allowance.
  /// <p>
  /// This token MUST be a non-fungible/unique token.
  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  ///*
  /// The identifier for the spending account associated with this allowance.
  /// <p>
  /// This account SHALL be permitted to sign transactions to spend
  /// tokens of the associated token type from the funding/allowing account.
  public var spender: Proto_AccountID {
    get {return _spender ?? Proto_AccountID()}
    set {_spender = newValue}
  }
  /// Returns true if `spender` has been explicitly set.
  public var hasSpender: Bool {return self._spender != nil}
  /// Clears the value of `spender`. Subsequent reads from it will return its default value.
  public mutating func clearSpender() {self._spender = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
  fileprivate var _spender: Proto_AccountID? = nil
}

///*
/// Permission granted by one account (the "funding" account) to another
/// account (the "spender" account) that allows the spender to spend a
/// specified amount of a specific non-HBAR fungible token from the
/// balance owned by the funding account.
///
/// An allowance SHALL NOT transfer any tokens directly, it only permits
/// transactions signed only by the spender account to transfer tokens
/// of the specified type, up to the amount specified, from the funding account.
///
/// Once the specified amount is spent, the allowance SHALL be consumed
/// and a new allowance SHALL be required before that spending account
/// may spend additional tokens from the funding account.
public struct Proto_GrantedTokenAllowance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  /// The identifier for the token associated with this allowance.
  /// <p>
  /// This token MUST be a fungible/common token.
  public var tokenID: Proto_TokenID {
    get {return _tokenID ?? Proto_TokenID()}
    set {_tokenID = newValue}
  }
  /// Returns true if `tokenID` has been explicitly set.
  public var hasTokenID: Bool {return self._tokenID != nil}
  /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
  public mutating func clearTokenID() {self._tokenID = nil}

  ///*
  /// The identifier for the spending account associated with this allowance.
  /// <p>
  /// This account SHALL be permitted to sign transactions to spend tokens
  /// of the associated token type from the funding/allowing account.<br/>
  /// This permission SHALL be limited to no more than the specified `amount`.
  public var spender: Proto_AccountID {
    get {return _spender ?? Proto_AccountID()}
    set {_spender = newValue}
  }
  /// Returns true if `spender` has been explicitly set.
  public var hasSpender: Bool {return self._spender != nil}
  /// Clears the value of `spender`. Subsequent reads from it will return its default value.
  public mutating func clearSpender() {self._spender = nil}

  ///
  /// The maximum amount that the spender account may transfer within
  /// the scope of this allowance.
  /// <p>
  /// This allowance SHALL be consumed if any combination of transfers
  /// authorized via this allowance meet this value in total.<br/>
  /// This value MUST be specified in the smallest units of the relevant
  /// token (i.e. 10<sup>-decimals</sup> whole tokens).
  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenID: Proto_TokenID? = nil
  fileprivate var _spender: Proto_AccountID? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_GetAccountDetailsQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountDetailsQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GetAccountDetailsQuery, rhs: Proto_GetAccountDetailsQuery) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetAccountDetailsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountDetailsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "account_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GetAccountDetailsResponse, rhs: Proto_GetAccountDetailsResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._accountDetails != rhs._accountDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetAccountDetailsResponse.AccountDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Proto_GetAccountDetailsResponse.protoMessageName + ".AccountDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "contract_account_id"),
    3: .same(proto: "deleted"),
    4: .standard(proto: "proxy_account_id"),
    5: .standard(proto: "proxy_received"),
    6: .same(proto: "key"),
    7: .same(proto: "balance"),
    8: .standard(proto: "receiver_sig_required"),
    9: .standard(proto: "expiration_time"),
    10: .standard(proto: "auto_renew_period"),
    11: .standard(proto: "token_relationships"),
    12: .same(proto: "memo"),
    13: .standard(proto: "owned_nfts"),
    14: .standard(proto: "max_automatic_token_associations"),
    15: .same(proto: "alias"),
    16: .standard(proto: "ledger_id"),
    17: .standard(proto: "granted_crypto_allowances"),
    18: .standard(proto: "granted_nft_allowances"),
    19: .standard(proto: "granted_token_allowances"),
  ]

  fileprivate class _StorageClass {
    var _accountID: Proto_AccountID? = nil
    var _contractAccountID: String = String()
    var _deleted: Bool = false
    var _proxyAccountID: Proto_AccountID? = nil
    var _proxyReceived: Int64 = 0
    var _key: Proto_Key? = nil
    var _balance: UInt64 = 0
    var _receiverSigRequired: Bool = false
    var _expirationTime: Proto_Timestamp? = nil
    var _autoRenewPeriod: Proto_Duration? = nil
    var _tokenRelationships: [Proto_TokenRelationship] = []
    var _memo: String = String()
    var _ownedNfts: Int64 = 0
    var _maxAutomaticTokenAssociations: Int32 = 0
    var _alias: Data = Data()
    var _ledgerID: Data = Data()
    var _grantedCryptoAllowances: [Proto_GrantedCryptoAllowance] = []
    var _grantedNftAllowances: [Proto_GrantedNftAllowance] = []
    var _grantedTokenAllowances: [Proto_GrantedTokenAllowance] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _contractAccountID = source._contractAccountID
      _deleted = source._deleted
      _proxyAccountID = source._proxyAccountID
      _proxyReceived = source._proxyReceived
      _key = source._key
      _balance = source._balance
      _receiverSigRequired = source._receiverSigRequired
      _expirationTime = source._expirationTime
      _autoRenewPeriod = source._autoRenewPeriod
      _tokenRelationships = source._tokenRelationships
      _memo = source._memo
      _ownedNfts = source._ownedNfts
      _maxAutomaticTokenAssociations = source._maxAutomaticTokenAssociations
      _alias = source._alias
      _ledgerID = source._ledgerID
      _grantedCryptoAllowances = source._grantedCryptoAllowances
      _grantedNftAllowances = source._grantedNftAllowances
      _grantedTokenAllowances = source._grantedTokenAllowances
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._accountID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._contractAccountID) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._deleted) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._proxyAccountID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._proxyReceived) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._balance) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._receiverSigRequired) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._expirationTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._autoRenewPeriod) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokenRelationships) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._memo) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._ownedNfts) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._maxAutomaticTokenAssociations) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._alias) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._ledgerID) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._grantedCryptoAllowances) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._grantedNftAllowances) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._grantedTokenAllowances) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._contractAccountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contractAccountID, fieldNumber: 2)
      }
      if _storage._deleted != false {
        try visitor.visitSingularBoolField(value: _storage._deleted, fieldNumber: 3)
      }
      try { if let v = _storage._proxyAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._proxyReceived != 0 {
        try visitor.visitSingularInt64Field(value: _storage._proxyReceived, fieldNumber: 5)
      }
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._balance != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._balance, fieldNumber: 7)
      }
      if _storage._receiverSigRequired != false {
        try visitor.visitSingularBoolField(value: _storage._receiverSigRequired, fieldNumber: 8)
      }
      try { if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._autoRenewPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._tokenRelationships.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokenRelationships, fieldNumber: 11)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memo, fieldNumber: 12)
      }
      if _storage._ownedNfts != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ownedNfts, fieldNumber: 13)
      }
      if _storage._maxAutomaticTokenAssociations != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxAutomaticTokenAssociations, fieldNumber: 14)
      }
      if !_storage._alias.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._alias, fieldNumber: 15)
      }
      if !_storage._ledgerID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._ledgerID, fieldNumber: 16)
      }
      if !_storage._grantedCryptoAllowances.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._grantedCryptoAllowances, fieldNumber: 17)
      }
      if !_storage._grantedNftAllowances.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._grantedNftAllowances, fieldNumber: 18)
      }
      if !_storage._grantedTokenAllowances.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._grantedTokenAllowances, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GetAccountDetailsResponse.AccountDetails, rhs: Proto_GetAccountDetailsResponse.AccountDetails) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._contractAccountID != rhs_storage._contractAccountID {return false}
        if _storage._deleted != rhs_storage._deleted {return false}
        if _storage._proxyAccountID != rhs_storage._proxyAccountID {return false}
        if _storage._proxyReceived != rhs_storage._proxyReceived {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._receiverSigRequired != rhs_storage._receiverSigRequired {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._autoRenewPeriod != rhs_storage._autoRenewPeriod {return false}
        if _storage._tokenRelationships != rhs_storage._tokenRelationships {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._ownedNfts != rhs_storage._ownedNfts {return false}
        if _storage._maxAutomaticTokenAssociations != rhs_storage._maxAutomaticTokenAssociations {return false}
        if _storage._alias != rhs_storage._alias {return false}
        if _storage._ledgerID != rhs_storage._ledgerID {return false}
        if _storage._grantedCryptoAllowances != rhs_storage._grantedCryptoAllowances {return false}
        if _storage._grantedNftAllowances != rhs_storage._grantedNftAllowances {return false}
        if _storage._grantedTokenAllowances != rhs_storage._grantedTokenAllowances {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GrantedCryptoAllowance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrantedCryptoAllowance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spender"),
    2: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spender) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GrantedCryptoAllowance, rhs: Proto_GrantedCryptoAllowance) -> Bool {
    if lhs._spender != rhs._spender {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GrantedNftAllowance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrantedNftAllowance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .same(proto: "spender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GrantedNftAllowance, rhs: Proto_GrantedNftAllowance) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs._spender != rhs._spender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GrantedTokenAllowance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrantedTokenAllowance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .same(proto: "spender"),
    3: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spender) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Proto_GrantedTokenAllowance, rhs: Proto_GrantedTokenAllowance) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs._spender != rhs._spender {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
